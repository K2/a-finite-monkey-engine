from http.client import REQUEST_TIMEOUT
from typing import Dict, List, Any, Optional, AsyncIterator
import asyncio
from loguru import logger

from llama_index.core.llms import ChatMessage, MessageRole

from finite_monkey import nodes_config
from ..pipeline.core import Context
from ..models.security import SecurityFinding, SecurityAnalysisResult
from finite_monkey.nodes_config import config  # Use the correct config import
import json
from box import Box


class VulnerabilityScanner:
    """Scanner for common smart contract vulnerabilities"""
    
    def __init__(self, llm_adapter=None, validator_adapter=None):
        """
        Initialize with LLM adapter
        
        Args:
            llm_adapter: LlamaIndexAdapter instance for LLM access
            validator_adapter: Validator adapter for validating findings
        """
        if llm_adapter is None:
            try:
                from ..llm.llama_index_adapter import LlamaIndexAdapter
                
                # Use scan model for vulnerability scanning
                self.llm_adapter = LlamaIndexAdapter(
                    model_name=config.SCAN_MODEL,
                    provider=config.SCAN_MODEL_PROVIDER,
                    base_url=config.SCAN_MODEL_BASE_URL,
                    request_timeout=config.REQUEST_TIMEOUT
                )
                logger.info(f"Created vulnerability scanner LLM adapter with model: {config.SCAN_MODEL}")
            except Exception as e:
                logger.error(f"Failed to create vulnerability scanner LLM adapter: {e}")
                self.llm_adapter = None
        else:
            self.llm_adapter = llm_adapter

        self.validator_adapter = validator_adapter
        self.scan_results_cache = {}  # Cache scan results to avoid duplicate work
    
    async def process(self, context: Context) -> Context:
        """Process the context to scan for vulnerabilities"""
        logger.info("Scanning for smart contract vulnerabilities")
        
        # Initialize findings list if needed
        if not hasattr(context, "findings"):
            context.findings = []
        
        # Get list of files to scan
        solidity_files = [(file_id, file_data) for file_id, file_data in context.files.items() 
                          if file_data.get("is_solidity", False)]
        
        logger.info(f"Scanning {len(solidity_files)} Solidity files for vulnerabilities")
        
        # Scan in chunks to manage resources
        chunk_size = 2  # Process 2 files concurrently
        for i in range(0, len(solidity_files), chunk_size):
            chunk = solidity_files[i:i+chunk_size]
            
            # Process this chunk of files concurrently
            tasks = [self._scan_file(context, file_id, file_data) for file_id, file_data in chunk]
            await asyncio.gather(*tasks)
            
            # Small delay to prevent resource exhaustion
            await asyncio.sleep(0.1)
        
        logger.info(f"Vulnerability scan complete. Found {len(context.findings)} potential issues.")
        return context
    
    async def _scan_file(self, context: Context, file_id: str, file_data: Dict[str, Any]):
        """Scan a file for vulnerabilities asynchronously"""
        # Check cache first
        if file_id in self.scan_results_cache:
            # Use cached results
            file_findings = self.scan_results_cache[file_id]
            # Add findings to context
            for finding in file_findings:
                context.findings.append(finding)
                logger.debug(f"Added cached finding: {finding.title} in {file_id}")
            return
                
        # Do fresh scan
        try:
            # Analyze the file
            file_findings = await self._analyze_file(file_data)
            
            # Add findings to context
            for finding in file_findings:
                context.findings.append(finding)
                logger.debug(f"Added finding: {finding.title} in {file_id}")
            
            # Cache results to avoid duplicate work
            self.scan_results_cache[file_id] = file_findings
            
            # Validate findings if validator is available
            if self.validator_adapter:
                contract_name = file_data.get("name", file_id)
                file_findings = await self.validator_adapter.validate_findings(
                    findings=file_findings,
                    context=f"Contract: {contract_name}"
                )
                
        except Exception as e:
            logger.error(f"Error scanning file {file_id}: {str(e)}")
            context.add_error(
                stage="vulnerability_scan",
                message=f"Failed to scan file: {file_id}",
                exception=e
            )
    
    async def _analyze_file(self, file_data: Dict[str, Any]) -> List[SecurityFinding]:
        """
        Analyze a file for vulnerabilities using structured LLM output
        
        Args:
            file_data: Dictionary containing file information
            
        Returns:
            List of SecurityFinding objects representing detected vulnerabilities
        """
        # Check if LLM adapter is available
        if not self.llm_adapter or not hasattr(self.llm_adapter, 'llm'):
            logger.error("No LLM adapter available for vulnerability scanning")
            return []
            
        try:
            self.llm_adapter.llm.request_timeout = config.REQUEST_TIMEOUT
            # Create a structured LLM for SecurityAnalysisResult output
            structured_llm = self.llm_adapter.llm.as_structured_llm(SecurityAnalysisResult)
            
            # Create a prompt for the LLM with better instructions
            prompt = f"""
Analyze the following Solidity smart contract for security vulnerabilities.
Focus on critical issues like:
- Reentrancy vulnerabilities
- Integer overflow/underflow
- Access control issues
- Unchecked external calls
- Logic errors
- Oracle manipulation
- Flash loan attacks
- Time-based attacks

Solidity code:
```solidity
{file_data["content"]}
```

For each vulnerability found, provide the following information:
- Title: Brief name of vulnerability
- Severity: "high", "medium", or "low"
- Description: Detailed explanation of the issue
- Location: Function or line numbers where the issue occurs
- Recommendation: How to fix the issue
- (optional) CWE ID: Common Weakness Enumeration ID if applicable
- (optional) Impact: Description of the potential impact

Include a summary of the overall security posture and a risk score from 0-10."""

            system_prompt = """You are an expert smart contract security auditor with deep knowledge of 
Solidity security best practices. Analyze code carefully and provide actionable findings. """
            
            # Create chat message
            messages = [
                ChatMessage(role=MessageRole.SYSTEM, content=system_prompt),
                ChatMessage(role=MessageRole.USER, content=prompt)
            ]   
            
            # Generate the structured output
            try:
                result: SecurityAnalysisResult = Box(json.loads((await structured_llm.achat(messages)).message.content))
                findings = result.get("findings", [])
                logger.info(f"Successfully generated structured security analysis with {len(findings)} findings")
                
                # Add file path to each finding
                for finding in findings:
                    finding.location = f"{file_data.get('path', 'unknown')}: {finding.location}"
                
                return findings
                
            except asyncio.TimeoutError:
                logger.error(f"LLM analysis timed out for file {file_data.get('path', 'unknown')}")
                return []
                
        except Exception as e:
            logger.error(f"Error in vulnerability analysis: {str(e)}")
            return []
