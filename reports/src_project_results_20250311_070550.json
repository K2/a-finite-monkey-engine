{
  "project_id": "src",
  "file_count": 108,
  "files": {
    "LiFiDiamond.sol": {
      "file_id": "LiFiDiamond.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "LiFiDiamond": {
            "name": "LiFiDiamond",
            "inheritance": [],
            "functions": {},
            "state_variables": {
              "position": {
                "name": "position",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "LibDiamond.DIAMOND_STORAGE_POSITION"
              },
              "facet": {
                "name": "facet",
                "type": "address",
                "visibility": "internal",
                "initial_value": "ds.selectorToFacetAndPosition[msg.sig].facetAddress"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"./Libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"./Libraries/LibUtil.sol\";\n\n/// @title LIFI Diamond\n/// @author LI.FI (https://li.fi)\n/// @notice Base EIP-2535 Diamond Proxy Contract.\n/// @custom:version 1.0.0\ncontract LiFiDiamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        LibDiamond.FacetCut[] memory cut = new LibDiamond.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = LibDiamond.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: LibDiamond.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n\n        // get diamond storage\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\n        if (facet == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "LiFiDiamond": {}
      },
      "flow_data": {
        "LiFiDiamond": {}
      },
      "flow_paths": {
        "LiFiDiamond": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.493686"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.509789"
      },
      "final_report": {
        "file_id": "LiFiDiamond.sol",
        "timestamp": "2025-03-11T07:05:50.509811",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "LiFiDiamond": {
            "functions": 0,
            "state_variables": 2,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LiFiDiamond.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.509823"
    },
    "GenericErrors.sol": {
      "file_id": "GenericErrors.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nerror AlreadyInitialized();\nerror CannotAuthoriseSelf();\nerror CannotBridgeToSameNetwork();\nerror ContractCallNotAllowed();\nerror CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\nerror DiamondIsPaused();\nerror ExternalCallFailed();\nerror FunctionDoesNotExist();\nerror InformationMismatch();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror InvalidAmount();\nerror InvalidCallData();\nerror InvalidConfig();\nerror InvalidContract();\nerror InvalidDestinationChain();\nerror InvalidFallbackAddress();\nerror InvalidReceiver();\nerror InvalidSendingToken();\nerror NativeAssetNotSupported();\nerror NativeAssetTransferFailed();\nerror NoSwapDataProvided();\nerror NoSwapFromZeroBalance();\nerror NotAContract();\nerror NotInitialized();\nerror NoTransferToNullAddress();\nerror NullAddrIsNotAnERC20Token();\nerror NullAddrIsNotAValidSpender();\nerror OnlyContractOwner();\nerror RecoveryAddressCannotBeZero();\nerror ReentrancyError();\nerror TokenNotSupported();\nerror UnAuthorized();\nerror UnsupportedChainId(uint256 chainId);\nerror WithdrawFailed();\nerror ZeroAmount();\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.486151"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.494101"
      },
      "final_report": {
        "file_id": "GenericErrors.sol",
        "timestamp": "2025-03-11T07:05:50.494124",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GenericErrors.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.494137"
    },
    "AccessManagerFacet.sol": {
      "file_id": "AccessManagerFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AccessManagerFacet": {
            "name": "AccessManagerFacet",
            "inheritance": [],
            "functions": {
              "setCanExecute": {
                "name": "setCanExecute",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_selector"
                  },
                  {
                    "type": "address",
                    "name": "_executor"
                  },
                  {
                    "type": "bool",
                    "name": "_canExecute"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (_executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        LibDiamond.enforceIsContractOwner();\n        _canExecute\n            ? LibAccess.addAccess(_selector, _executor)\n            : LibAccess.removeAccess(_selector, _executor);\n        if (_canExecute) {\n            emit ExecutionAllowed(_executor, _selector);\n        } else {\n            emit ExecutionDenied(_executor, _selector);\n        }\n    }"
              },
              "addressCanExecuteMethod": {
                "name": "addressCanExecuteMethod",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_selector"
                  },
                  {
                    "type": "address",
                    "name": "_executor"
                  }
                ],
                "returns": [
                  {
                    "type": "bool"
                  }
                ],
                "modifiers": [],
                "code": "return LibAccess.accessStorage().execAccess[_selector][_executor];\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\n/// @custom:version 1.0.0\ncontract AccessManagerFacet {\n    /// Events ///\n\n    event ExecutionAllowed(address indexed account, bytes4 indexed method);\n    event ExecutionDenied(address indexed account, bytes4 indexed method);\n\n    /// External Methods ///\n\n    /// @notice Sets whether a specific address can call a method\n    /// @param _selector The method selector to set access for\n    /// @param _executor The address to set method access for\n    /// @param _canExecute Whether or not the address can execute the specified method\n    function setCanExecute(\n        bytes4 _selector,\n        address _executor,\n        bool _canExecute\n    ) external {\n        if (_executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        LibDiamond.enforceIsContractOwner();\n        _canExecute\n            ? LibAccess.addAccess(_selector, _executor)\n            : LibAccess.removeAccess(_selector, _executor);\n        if (_canExecute) {\n            emit ExecutionAllowed(_executor, _selector);\n        } else {\n            emit ExecutionDenied(_executor, _selector);\n        }\n    }\n\n    /// @notice Check if a method can be executed by a specific address\n    /// @param _selector The method selector to check\n    /// @param _executor The address to check\n    function addressCanExecuteMethod(\n        bytes4 _selector,\n        address _executor\n    ) external view returns (bool) {\n        return LibAccess.accessStorage().execAccess[_selector][_executor];\n    }\n}\n"
      },
      "call_graph": {
        "AccessManagerFacet": {
          "setCanExecute": [],
          "addressCanExecuteMethod": []
        }
      },
      "flow_data": {
        "AccessManagerFacet": {
          "setCanExecute": {
            "name": "setCanExecute",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "_executor == address(this",
                "line": 1
              },
              {
                "type": "if",
                "condition": "_canExecute",
                "line": 8
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (_executor == address(this)",
              "8": "if (_canExecute)"
            },
            "parameters": [
              {
                "type": "bytes4",
                "name": "_selector"
              },
              {
                "type": "address",
                "name": "_executor"
              },
              {
                "type": "bool",
                "name": "_canExecute"
              }
            ],
            "returns": []
          },
          "addressCanExecuteMethod": {
            "name": "addressCanExecuteMethod",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes4",
                "name": "_selector"
              },
              {
                "type": "address",
                "name": "_executor"
              }
            ],
            "returns": [
              {
                "type": "bool"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "AccessManagerFacet": {
          "setCanExecute": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "addressCanExecuteMethod": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.497169"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.501398"
      },
      "final_report": {
        "file_id": "AccessManagerFacet.sol",
        "timestamp": "2025-03-11T07:05:50.501426",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AccessManagerFacet": {
            "functions": 2,
            "state_variables": 0,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AccessManagerFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.501440"
    },
    "AcrossFacet.sol": {
      "file_id": "AcrossFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AcrossFacet": {
            "name": "AcrossFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "AcrossData",
                    "name": "_acrossData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            spokePool.deposit{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                wrappedNative,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.deposit(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "relayerFeePct": {
                "name": "relayerFeePct",
                "type": "int64",
                "visibility": "internal",
                "initial_value": null
              },
              "quoteTimestamp": {
                "name": "quoteTimestamp",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "message": {
                "name": "message",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "maxCount": {
                "name": "maxCount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Across Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across Protocol\n/// @custom:version 2.0.0\ncontract AcrossFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the spoke pool on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Types ///\n\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals.\n    /// @param quoteTimestamp The timestamp associated with the suggested fee.\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    struct AcrossData {\n        int64 relayerFeePct;\n        uint32 quoteTimestamp;\n        bytes message;\n        uint256 maxCount;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _spokePool The contract address of the spoke pool on the source chain.\n    /// @param _wrappedNative The address of the wrapped native token on the source chain.\n    constructor(IAcrossSpokePool _spokePool, address _wrappedNative) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function startBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// @notice Performs a swap before bridging via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _acrossData data specific to Across\n    function swapAndStartBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    ) internal {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            spokePool.deposit{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                wrappedNative,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.deposit(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "AcrossFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "AcrossFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "AcrossData",
                "name": "_acrossData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "AcrossFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.493424"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.509907"
      },
      "final_report": {
        "file_id": "AcrossFacet.sol",
        "timestamp": "2025-03-11T07:05:50.509924",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AcrossFacet": {
            "functions": 1,
            "state_variables": 4,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AcrossFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.509934"
    },
    "AcrossFacetPacked.sol": {
      "file_id": "AcrossFacetPacked.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AcrossFacetPacked": {
            "name": "AcrossFacetPacked",
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ],
            "functions": {
              "startBridgeTokensViaAcrossNativePacked": {
                "name": "startBridgeTokensViaAcrossNativePacked",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            wrappedNative, // wrappedNative address\n            msg.value, // minAmount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[36:44]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[44:48])), // uint32 quoteTimestamp\n            msg.data[80:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[48:80])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAcrossNativeMin": {
                "name": "startBridgeTokensViaAcrossNativeMin",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "int64",
                    "name": "relayerFeePct"
                  },
                  {
                    "type": "uint32",
                    "name": "quoteTimestamp"
                  },
                  {
                    "type": "bytes",
                    "name": "message"
                  },
                  {
                    "type": "uint256",
                    "name": "maxCount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            receiver,\n            wrappedNative,\n            msg.value,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }"
              },
              "startBridgeTokensViaAcrossERC20Packed": {
                "name": "startBridgeTokensViaAcrossERC20Packed",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            address(bytes20(msg.data[12:32])), // receiver\n            address(bytes20(msg.data[32:52])), // sendingAssetID\n            minAmount,\n            uint64(uint32(bytes4(msg.data[68:72]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[72:80]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[80:84])), // uint32 quoteTimestamp\n            msg.data[116:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[84:116])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAcrossERC20Min": {
                "name": "startBridgeTokensViaAcrossERC20Min",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "int64",
                    "name": "relayerFeePct"
                  },
                  {
                    "type": "uint32",
                    "name": "quoteTimestamp"
                  },
                  {
                    "type": "bytes",
                    "name": "message"
                  },
                  {
                    "type": "uint256",
                    "name": "maxCount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            receiver,\n            sendingAssetId,\n            minAmount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }"
              },
              "encode_startBridgeTokensViaAcrossNativePacked": {
                "name": "encode_startBridgeTokensViaAcrossNativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "int64",
                    "name": "relayerFeePct"
                  },
                  {
                    "type": "uint32",
                    "name": "quoteTimestamp"
                  },
                  {
                    "type": "uint256",
                    "name": "maxCount"
                  },
                  {
                    "type": "bytes",
                    "name": "message"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(quoteTimestamp),\n                bytes32(maxCount),\n                message\n            );\n    }"
              },
              "encode_startBridgeTokensViaAcrossERC20Packed": {
                "name": "encode_startBridgeTokensViaAcrossERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "int64",
                    "name": "relayerFeePct"
                  },
                  {
                    "type": "uint32",
                    "name": "quoteTimestamp"
                  },
                  {
                    "type": "bytes",
                    "name": "message"
                  },
                  {
                    "type": "uint256",
                    "name": "maxCount"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(uint32(quoteTimestamp)),\n                bytes32(maxCount),\n                message\n            );\n    }"
              },
              "decode_startBridgeTokensViaAcrossNativePacked": {
                "name": "decode_startBridgeTokensViaAcrossNativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory bridgeData"
                  },
                  {
                    "type": "AcrossFacet.AcrossData memory acrossData"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            data.length >= 108,\n            \"invalid calldata (must have length > 108)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[32:36])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[36:44])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[44:48]));\n        acrossData.maxCount = uint256(bytes32(data[48:80]));\n        acrossData.message = data[80:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }"
              },
              "decode_startBridgeTokensViaAcrossERC20Packed": {
                "name": "decode_startBridgeTokensViaAcrossERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory bridgeData"
                  },
                  {
                    "type": "AcrossFacet.AcrossData memory acrossData"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            data.length >= 144,\n            \"invalid calldata (must have length > 144)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.sendingAssetId = address(bytes20(data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[52:68])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[68:72])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[72:80])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[80:84]));\n        acrossData.maxCount = uint256(bytes32(data[84:116]));\n        acrossData.message = data[116:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }"
              }
            },
            "state_variables": {
              "calldataEndsAt": {
                "name": "calldataEndsAt",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "data.length - REFERRER_OFFSET"
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(bytes20(msg.data[32:52]))"
              },
              "minAmount": {
                "name": "minAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[52:68])))"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AcrossFacet } from \"./AcrossFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n\n/// @title AcrossFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AcrossFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    bytes public constant ACROSS_REFERRER_DELIMITER = hex\"d00dfeeddeadbeef\";\n    uint8 private constant ACROSS_REFERRER_ADDRESS_LENGTH = 20;\n    uint256 private constant REFERRER_OFFSET = 28;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Events ///\n\n    event LiFiAcrossTransfer(bytes8 _transactionId);\n    event CallExecutedAndFundsWithdrawn();\n\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract\n    /// @param _spokePool The contract address of the spoke pool on the source chain\n    /// @param _wrappedNative The address of the wrapped native token on the source chain\n    /// @param _owner The address of the contract owner\n    constructor(\n        IAcrossSpokePool _spokePool,\n        address _wrappedNative,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Across spoke pool Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the Across spoke pool\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give Across spoke pool approval to pull tokens from this facet\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(spokePool),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges native tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossNativePacked() external payable {\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            wrappedNative, // wrappedNative address\n            msg.value, // minAmount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[36:44]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[44:48])), // uint32 quoteTimestamp\n            msg.data[80:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[48:80])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges native tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            receiver,\n            wrappedNative,\n            msg.value,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossERC20Packed() external payable {\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            address(bytes20(msg.data[12:32])), // receiver\n            address(bytes20(msg.data[32:52])), // sendingAssetID\n            minAmount,\n            uint64(uint32(bytes4(msg.data[68:72]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[72:80]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[80:84])), // uint32 quoteTimestamp\n            msg.data[116:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[84:116])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossERC20Min(\n        bytes32 transactionId,\n        address sendingAssetId,\n        uint256 minAmount,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            receiver,\n            sendingAssetId,\n            minAmount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encodes calldata that can be used to call the native 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        uint256 maxCount,\n        bytes calldata message\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(quoteTimestamp),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Encodes calldata that can be used to call the ERC20 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(uint32(quoteTimestamp)),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the native 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossNativePacked(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 108,\n            \"invalid calldata (must have length > 108)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[32:36])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[36:44])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[44:48]));\n        acrossData.maxCount = uint256(bytes32(data[48:80]));\n        acrossData.message = data[80:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the ERC20 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossERC20Packed(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 144,\n            \"invalid calldata (must have length > 144)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.sendingAssetId = address(bytes20(data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[52:68])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[68:72])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[72:80])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[80:84]));\n        acrossData.maxCount = uint256(bytes32(data[84:116]));\n        acrossData.message = data[116:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Execute calldata and withdraw asset\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to address to withdraw to\n    /// @param _amount amount of asset to withdraw\n    function executeCallAndWithdraw(\n        address _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // execute calldata\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _callTo.call(_callData);\n\n        // check success of call\n        if (success) {\n            // call successful - withdraw the asset\n            LibAsset.transferAsset(_assetAddress, payable(_to), _amount);\n            emit CallExecutedAndFundsWithdrawn();\n        } else {\n            // call unsuccessful - revert\n            revert WithdrawFailed();\n        }\n    }\n}\n"
      },
      "call_graph": {
        "AcrossFacetPacked": {
          "startBridgeTokensViaAcrossNativePacked": [],
          "startBridgeTokensViaAcrossNativeMin": [],
          "startBridgeTokensViaAcrossERC20Packed": [],
          "startBridgeTokensViaAcrossERC20Min": [],
          "encode_startBridgeTokensViaAcrossNativePacked": [],
          "encode_startBridgeTokensViaAcrossERC20Packed": [],
          "decode_startBridgeTokensViaAcrossNativePacked": [],
          "decode_startBridgeTokensViaAcrossERC20Packed": []
        }
      },
      "flow_data": {
        "AcrossFacetPacked": {
          "startBridgeTokensViaAcrossNativePacked": {
            "name": "startBridgeTokensViaAcrossNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "calldataEndsAt",
                "type": "uint256",
                "value": "msg.data.length - REFERRER_OFFSET",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: calldataEndsAt = msg.data.length - REFERRER_OFFSET"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAcrossNativeMin": {
            "name": "startBridgeTokensViaAcrossNativeMin",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "int64",
                "name": "relayerFeePct"
              },
              {
                "type": "uint32",
                "name": "quoteTimestamp"
              },
              {
                "type": "bytes",
                "name": "message"
              },
              {
                "type": "uint256",
                "name": "maxCount"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaAcrossERC20Packed": {
            "name": "startBridgeTokensViaAcrossERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "calldataEndsAt",
                "type": "uint256",
                "value": "msg.data.length - REFERRER_OFFSET",
                "line": 12
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(msg.data[32:52]))",
                "line": 1
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[52:68])))",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "12": "State Change: calldataEndsAt = msg.data.length - REFERRER_OFFSET",
              "1": "State Change: sendingAssetId = address(bytes20(msg.data[32:52]))",
              "2": "State Change: minAmount = uint256(uint128(bytes16(msg.data[52:68])))"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAcrossERC20Min": {
            "name": "startBridgeTokensViaAcrossERC20Min",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "int64",
                "name": "relayerFeePct"
              },
              {
                "type": "uint32",
                "name": "quoteTimestamp"
              },
              {
                "type": "bytes",
                "name": "message"
              },
              {
                "type": "uint256",
                "name": "maxCount"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaAcrossNativePacked": {
            "name": "encode_startBridgeTokensViaAcrossNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 3
              }
            ],
            "line_mapping": {
              "3": "require(destinationChainId <= type(uint32)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "int64",
                "name": "relayerFeePct"
              },
              {
                "type": "uint32",
                "name": "quoteTimestamp"
              },
              {
                "type": "uint256",
                "name": "maxCount"
              },
              {
                "type": "bytes",
                "name": "message"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "encode_startBridgeTokensViaAcrossERC20Packed": {
            "name": "encode_startBridgeTokensViaAcrossERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 3
              },
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 8
              }
            ],
            "line_mapping": {
              "3": "require(destinationChainId <= type(uint32)",
              "8": "require(minAmount <= type(uint128)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "int64",
                "name": "relayerFeePct"
              },
              {
                "type": "uint32",
                "name": "quoteTimestamp"
              },
              {
                "type": "bytes",
                "name": "message"
              },
              {
                "type": "uint256",
                "name": "maxCount"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossNativePacked": {
            "name": "decode_startBridgeTokensViaAcrossNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "calldataEndsAt",
                "type": "uint256",
                "value": "data.length - REFERRER_OFFSET",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "data.length >= 108,\n            \"invalid calldata (must have length > 108",
                "line": 1
              }
            ],
            "line_mapping": {
              "7": "State Change: calldataEndsAt = data.length - REFERRER_OFFSET",
              "1": "require(data.length >= 108,\n            \"invalid calldata (must have length > 108)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory bridgeData"
              },
              {
                "type": "AcrossFacet.AcrossData memory acrossData"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossERC20Packed": {
            "name": "decode_startBridgeTokensViaAcrossERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "calldataEndsAt",
                "type": "uint256",
                "value": "data.length - REFERRER_OFFSET",
                "line": 7
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(data[32:52]))",
                "line": 11
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(data[52:68])))",
                "line": 12
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "data.length >= 144,\n            \"invalid calldata (must have length > 144",
                "line": 1
              }
            ],
            "line_mapping": {
              "7": "State Change: calldataEndsAt = data.length - REFERRER_OFFSET",
              "11": "State Change: sendingAssetId = address(bytes20(data[32:52]))",
              "12": "State Change: minAmount = uint256(uint128(bytes16(data[52:68])))",
              "1": "require(data.length >= 144,\n            \"invalid calldata (must have length > 144)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory bridgeData"
              },
              {
                "type": "AcrossFacet.AcrossData memory acrossData"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "AcrossFacetPacked": {
          "startBridgeTokensViaAcrossNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossNativeMin": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossERC20Min": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaAcrossNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 3,
                "type": "require"
              }
            ]
          },
          "encode_startBridgeTokensViaAcrossERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 3,
                "type": "require"
              },
              {
                "condition": "minAmount <= type(uint128",
                "line": 8,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "data.length >= 108,\n            \"invalid calldata (must have length > 108",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "data.length >= 144,\n            \"invalid calldata (must have length > 144",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.499675"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.516754"
      },
      "final_report": {
        "file_id": "AcrossFacetPacked.sol",
        "timestamp": "2025-03-11T07:05:50.516768",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AcrossFacetPacked": {
            "functions": 8,
            "state_variables": 3,
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AcrossFacetPacked.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.516777"
    },
    "AcrossFacetPackedV3.sol": {
      "file_id": "AcrossFacetPackedV3.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AcrossFacetPackedV3": {
            "name": "AcrossFacetPackedV3",
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ],
            "functions": {
              "startBridgeTokensViaAcrossV3NativePacked": {
                "name": "startBridgeTokensViaAcrossV3NativePacked",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// call Across spoke pool to bridge assets\n        spokePool.depositV3{ value: msg.value }(\n            address(bytes20(msg.data[32:52])), // depositor\n            address(bytes20(msg.data[12:32])), // recipient\n            wrappedNative, // inputToken\n            address(bytes20(msg.data[56:76])), // outputToken\n            msg.value, // inputAmount\n            uint256(bytes32(msg.data[76:108])), // outputAmount\n            uint64(uint32(bytes4(msg.data[52:56]))), // destinationChainId\n            address(bytes20(msg.data[108:128])), // exclusiveRelayer\n            uint32(bytes4(msg.data[128:132])), // quoteTimestamp\n            uint32(bytes4(msg.data[132:136])), // fillDeadline\n            uint32(bytes4(msg.data[136:140])), // exclusivityDeadline\n            msg.data[140:msg.data.length]\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAcrossV3NativeMin": {
                "name": "startBridgeTokensViaAcrossV3NativeMin",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "PackedParameters",
                    "name": "_parameters"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// call Across spoke pool to bridge assets\n        spokePool.depositV3{ value: msg.value }(\n            _parameters.depositor, // depositor\n            _parameters.receiver,\n            wrappedNative, // inputToken\n            _parameters.receivingAssetId, // outputToken\n            msg.value, // inputAmount\n            _parameters.outputAmount,\n            _parameters.destinationChainId,\n            _parameters.exclusiveRelayer,\n            _parameters.quoteTimestamp,\n            _parameters.fillDeadline,\n            _parameters.exclusivityDeadline,\n            _parameters.message\n        );\n\n        emit LiFiAcrossTransfer(bytes8(_parameters.transactionId));\n    }"
              },
              "startBridgeTokensViaAcrossV3ERC20Packed": {
                "name": "startBridgeTokensViaAcrossV3ERC20Packed",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "address sendingAssetId = address(bytes20(msg.data[52:72]));\n        uint256 inputAmount = uint256(uint128(bytes16(msg.data[72:88])));\n\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputAmount\n        );\n\n        spokePool.depositV3(\n            address(bytes20(msg.data[32:52])), // depositor\n            address(bytes20(msg.data[12:32])), // recipient\n            sendingAssetId, // inputToken\n            address(bytes20(msg.data[92:112])), // outputToken\n            inputAmount, // inputAmount\n            uint256(bytes32(msg.data[112:144])), // outputAmount\n            uint64(uint32(bytes4(msg.data[88:92]))), // destinationChainId\n            address(bytes20(msg.data[144:164])), // exclusiveRelayer\n            uint32(bytes4(msg.data[164:168])), // quoteTimestamp\n            uint32(bytes4(msg.data[168:172])), // fillDeadline\n            uint32(bytes4(msg.data[172:176])), // exclusivityDeadline\n            msg.data[176:msg.data.length]\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAcrossV3ERC20Min": {
                "name": "startBridgeTokensViaAcrossV3ERC20Min",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "PackedParameters",
                    "name": "_parameters"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "inputAmount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputAmount\n        );\n\n        // call Across SpokePool\n        spokePool.depositV3(\n            _parameters.depositor, // depositor\n            _parameters.receiver,\n            sendingAssetId, // inputToken\n            _parameters.receivingAssetId, // outputToken\n            inputAmount,\n            _parameters.outputAmount,\n            _parameters.destinationChainId,\n            _parameters.exclusiveRelayer,\n            _parameters.quoteTimestamp,\n            _parameters.fillDeadline,\n            _parameters.exclusivityDeadline,\n            _parameters.message\n        );\n\n        emit LiFiAcrossTransfer(bytes8(_parameters.transactionId));\n    }"
              },
              "encode_startBridgeTokensViaAcrossV3NativePacked": {
                "name": "encode_startBridgeTokensViaAcrossV3NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "PackedParameters",
                    "name": "_parameters"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            _parameters.destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPackedV3\n                    .startBridgeTokensViaAcrossV3NativePacked\n                    .selector,\n                bytes8(_parameters.transactionId),\n                bytes20(_parameters.receiver),\n                bytes20(_parameters.depositor),\n                bytes4(uint32(_parameters.destinationChainId)),\n                bytes20(_parameters.receivingAssetId),\n                bytes32(_parameters.outputAmount),\n                bytes20(_parameters.exclusiveRelayer),\n                bytes4(_parameters.quoteTimestamp),\n                bytes4(_parameters.fillDeadline),\n                bytes4(_parameters.exclusivityDeadline),\n                _parameters.message\n            );\n    }"
              },
              "encode_startBridgeTokensViaAcrossV3ERC20Packed": {
                "name": "encode_startBridgeTokensViaAcrossV3ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "PackedParameters",
                    "name": "_parameters"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "inputAmount"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            _parameters.destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            inputAmount <= type(uint128).max,\n            \"inputAmount value passed too big to fit in uint128\"\n        );\n\n        // Split the concatenation into parts to avoid \"stack too deep\" errors\n        bytes memory part1 = bytes.concat(\n            AcrossFacetPackedV3\n                .startBridgeTokensViaAcrossV3ERC20Packed\n                .selector,\n            bytes8(_parameters.transactionId),\n            bytes20(_parameters.receiver),\n            bytes20(_parameters.depositor),\n            bytes20(sendingAssetId)\n        );\n\n        bytes memory part2 = bytes.concat(\n            bytes16(uint128(inputAmount)),\n            bytes4(uint32(_parameters.destinationChainId)),\n            bytes20(_parameters.receivingAssetId),\n            bytes32(_parameters.outputAmount)\n        );\n\n        bytes memory part3 = bytes.concat(\n            bytes20(_parameters.exclusiveRelayer),\n            bytes4(_parameters.quoteTimestamp),\n            bytes4(_parameters.fillDeadline),\n            bytes4(_parameters.exclusivityDeadline)\n        );\n\n        // Combine all parts with the message\n        return bytes.concat(part1, part2, part3, _parameters.message);\n    }"
              },
              "decode_startBridgeTokensViaAcrossV3NativePacked": {
                "name": "decode_startBridgeTokensViaAcrossV3NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory bridgeData"
                  },
                  {
                    "type": "AcrossFacetV3.AcrossV3Data memory acrossData"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            data.length >= 140,\n            \"invalid calldata (must have length >= 140)\"\n        );\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[52:56])));\n\n        // extract acrossData\n        acrossData.refundAddress = address(bytes20(data[32:52])); // depositor\n        acrossData.receivingAssetId = address(bytes20(data[56:76]));\n        acrossData.outputAmount = uint256(bytes32(data[76:108]));\n        acrossData.exclusiveRelayer = address(bytes20(data[108:128]));\n        acrossData.quoteTimestamp = uint32(bytes4(data[128:132]));\n        acrossData.fillDeadline = uint32(bytes4(data[132:136]));\n        acrossData.exclusivityDeadline = uint32(bytes4(data[136:140]));\n        acrossData.message = data[140:];\n\n        return (bridgeData, acrossData);\n    }"
              },
              "decode_startBridgeTokensViaAcrossV3ERC20Packed": {
                "name": "decode_startBridgeTokensViaAcrossV3ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory bridgeData"
                  },
                  {
                    "type": "AcrossFacetV3.AcrossV3Data memory acrossData"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            data.length >= 176,\n            \"invalid calldata (must have length >= 176)\"\n        );\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        acrossData.refundAddress = address(bytes20(data[32:52])); // depositor\n        bridgeData.sendingAssetId = address(bytes20(data[52:72]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[72:88])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[88:92])));\n\n        acrossData.receivingAssetId = address(bytes20(data[92:112]));\n        acrossData.outputAmount = uint256(bytes32(data[112:144]));\n        acrossData.exclusiveRelayer = address(bytes20(data[144:164]));\n        acrossData.quoteTimestamp = uint32(bytes4(data[164:168]));\n        acrossData.fillDeadline = uint32(bytes4(data[168:172]));\n        acrossData.exclusivityDeadline = uint32(bytes4(data[172:176]));\n        acrossData.message = data[176:];\n\n        return (bridgeData, acrossData);\n    }"
              }
            },
            "state_variables": {
              "transactionId": {
                "name": "transactionId",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "receiver": {
                "name": "receiver",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "depositor": {
                "name": "depositor",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationChainId": {
                "name": "destinationChainId",
                "type": "uint64",
                "visibility": "internal",
                "initial_value": null
              },
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "outputAmount": {
                "name": "outputAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "exclusiveRelayer": {
                "name": "exclusiveRelayer",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "quoteTimestamp": {
                "name": "quoteTimestamp",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "fillDeadline": {
                "name": "fillDeadline",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "exclusivityDeadline": {
                "name": "exclusivityDeadline",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "message": {
                "name": "message",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(bytes20(msg.data[52:72]))"
              },
              "inputAmount": {
                "name": "inputAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[72:88])))"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AcrossFacetV3 } from \"./AcrossFacetV3.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n\n/// @title AcrossFacetPackedV3\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across in a gas-optimized way\n/// @custom:version 1.2.0\ncontract AcrossFacetPackedV3 is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    IAcrossSpokePool public immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address public immutable wrappedNative;\n\n    /// Events ///\n\n    event LiFiAcrossTransfer(bytes8 _transactionId);\n    event CallExecutedAndFundsWithdrawn();\n\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    // using this struct to bundle parameters is required since otherwise we run into stack-too-deep errors\n    // (Solidity can only handle a limited amount of parameters at any given time)\n    struct PackedParameters {\n        bytes32 transactionId;\n        address receiver;\n        address depositor;\n        uint64 destinationChainId;\n        address receivingAssetId;\n        uint256 outputAmount;\n        address exclusiveRelayer;\n        uint32 quoteTimestamp;\n        uint32 fillDeadline;\n        uint32 exclusivityDeadline;\n        bytes message;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract\n    /// @param _spokePool The contract address of the spoke pool on the source chain\n    /// @param _wrappedNative The address of the wrapped native token on the source chain\n    /// @param _owner The address of the contract owner\n    constructor(\n        IAcrossSpokePool _spokePool,\n        address _wrappedNative,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Across spoke pool Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the Across spoke pool\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give Across spoke pool approval to pull tokens from this facet\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(spokePool),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges native tokens via Across (packed implementation)\n    /// @dev Calldata mapping:\n    /// [0:4] - function selector\n    /// [4:12] - transactionId\n    /// [12:32] - receiver\n    /// [32:52] - depositor\n    /// [52:56] - destinationChainId\n    /// [56:76] - receivingAssetId\n    /// [76:108] - outputAmount\n    /// [108:128] - exclusiveRelayer\n    /// [128:132] - quoteTimestamp\n    /// [132:136] - fillDeadline\n    /// [136:140] - exclusivityDeadline\n    /// [140:] - message\n    function startBridgeTokensViaAcrossV3NativePacked() external payable {\n        // call Across spoke pool to bridge assets\n        spokePool.depositV3{ value: msg.value }(\n            address(bytes20(msg.data[32:52])), // depositor\n            address(bytes20(msg.data[12:32])), // recipient\n            wrappedNative, // inputToken\n            address(bytes20(msg.data[56:76])), // outputToken\n            msg.value, // inputAmount\n            uint256(bytes32(msg.data[76:108])), // outputAmount\n            uint64(uint32(bytes4(msg.data[52:56]))), // destinationChainId\n            address(bytes20(msg.data[108:128])), // exclusiveRelayer\n            uint32(bytes4(msg.data[128:132])), // quoteTimestamp\n            uint32(bytes4(msg.data[132:136])), // fillDeadline\n            uint32(bytes4(msg.data[136:140])), // exclusivityDeadline\n            msg.data[140:msg.data.length]\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges native tokens via Across (minimal implementation)\n    /// @param _parameters Contains all parameters required for native bridging with AcrossV3\n    function startBridgeTokensViaAcrossV3NativeMin(\n        PackedParameters calldata _parameters\n    ) external payable {\n        // call Across spoke pool to bridge assets\n        spokePool.depositV3{ value: msg.value }(\n            _parameters.depositor, // depositor\n            _parameters.receiver,\n            wrappedNative, // inputToken\n            _parameters.receivingAssetId, // outputToken\n            msg.value, // inputAmount\n            _parameters.outputAmount,\n            _parameters.destinationChainId,\n            _parameters.exclusiveRelayer,\n            _parameters.quoteTimestamp,\n            _parameters.fillDeadline,\n            _parameters.exclusivityDeadline,\n            _parameters.message\n        );\n\n        emit LiFiAcrossTransfer(bytes8(_parameters.transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (packed implementation)\n    /// @dev Calldata mapping:\n    /// [0:4] - function selector\n    /// [4:12] - transactionId\n    /// [12:32] - receiver\n    /// [32:52] - depositor\n    /// [52:72] - sendingAssetId\n    /// [72:88] - inputAmount\n    /// [88:92] - destinationChainId\n    /// [92:112] - receivingAssetId\n    /// [112:144] - outputAmount\n    /// [144:164] - exclusiveRelayer\n    /// [164:168] - quoteTimestamp\n    /// [168:172] - fillDeadline\n    /// [172:176] - exclusivityDeadline\n    /// [176:] - message\n    function startBridgeTokensViaAcrossV3ERC20Packed() external {\n        address sendingAssetId = address(bytes20(msg.data[52:72]));\n        uint256 inputAmount = uint256(uint128(bytes16(msg.data[72:88])));\n\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputAmount\n        );\n\n        spokePool.depositV3(\n            address(bytes20(msg.data[32:52])), // depositor\n            address(bytes20(msg.data[12:32])), // recipient\n            sendingAssetId, // inputToken\n            address(bytes20(msg.data[92:112])), // outputToken\n            inputAmount, // inputAmount\n            uint256(bytes32(msg.data[112:144])), // outputAmount\n            uint64(uint32(bytes4(msg.data[88:92]))), // destinationChainId\n            address(bytes20(msg.data[144:164])), // exclusiveRelayer\n            uint32(bytes4(msg.data[164:168])), // quoteTimestamp\n            uint32(bytes4(msg.data[168:172])), // fillDeadline\n            uint32(bytes4(msg.data[172:176])), // exclusivityDeadline\n            msg.data[176:msg.data.length]\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (minimal implementation)\n    /// @param _parameters Contains all base parameters required for bridging with AcrossV3\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param inputAmount The amount to be bridged (including fees)\n    function startBridgeTokensViaAcrossV3ERC20Min(\n        PackedParameters calldata _parameters,\n        address sendingAssetId,\n        uint256 inputAmount\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            inputAmount\n        );\n\n        // call Across SpokePool\n        spokePool.depositV3(\n            _parameters.depositor, // depositor\n            _parameters.receiver,\n            sendingAssetId, // inputToken\n            _parameters.receivingAssetId, // outputToken\n            inputAmount,\n            _parameters.outputAmount,\n            _parameters.destinationChainId,\n            _parameters.exclusiveRelayer,\n            _parameters.quoteTimestamp,\n            _parameters.fillDeadline,\n            _parameters.exclusivityDeadline,\n            _parameters.message\n        );\n\n        emit LiFiAcrossTransfer(bytes8(_parameters.transactionId));\n    }\n\n    /// @notice Encodes calldata that can be used to call the native 'packed' function\n    /// @param _parameters Contains all parameters required for native bridging with AcrossV3\n    function encode_startBridgeTokensViaAcrossV3NativePacked(\n        PackedParameters calldata _parameters\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            _parameters.destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPackedV3\n                    .startBridgeTokensViaAcrossV3NativePacked\n                    .selector,\n                bytes8(_parameters.transactionId),\n                bytes20(_parameters.receiver),\n                bytes20(_parameters.depositor),\n                bytes4(uint32(_parameters.destinationChainId)),\n                bytes20(_parameters.receivingAssetId),\n                bytes32(_parameters.outputAmount),\n                bytes20(_parameters.exclusiveRelayer),\n                bytes4(_parameters.quoteTimestamp),\n                bytes4(_parameters.fillDeadline),\n                bytes4(_parameters.exclusivityDeadline),\n                _parameters.message\n            );\n    }\n\n    /// @notice Encodes calldata that can be used to call the ERC20 'packed' function\n    /// @param _parameters Contains all base parameters required for bridging with AcrossV3\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param inputAmount The amount to be bridged (including fees)\n    function encode_startBridgeTokensViaAcrossV3ERC20Packed(\n        PackedParameters calldata _parameters,\n        address sendingAssetId,\n        uint256 inputAmount\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            _parameters.destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            inputAmount <= type(uint128).max,\n            \"inputAmount value passed too big to fit in uint128\"\n        );\n\n        // Split the concatenation into parts to avoid \"stack too deep\" errors\n        bytes memory part1 = bytes.concat(\n            AcrossFacetPackedV3\n                .startBridgeTokensViaAcrossV3ERC20Packed\n                .selector,\n            bytes8(_parameters.transactionId),\n            bytes20(_parameters.receiver),\n            bytes20(_parameters.depositor),\n            bytes20(sendingAssetId)\n        );\n\n        bytes memory part2 = bytes.concat(\n            bytes16(uint128(inputAmount)),\n            bytes4(uint32(_parameters.destinationChainId)),\n            bytes20(_parameters.receivingAssetId),\n            bytes32(_parameters.outputAmount)\n        );\n\n        bytes memory part3 = bytes.concat(\n            bytes20(_parameters.exclusiveRelayer),\n            bytes4(_parameters.quoteTimestamp),\n            bytes4(_parameters.fillDeadline),\n            bytes4(_parameters.exclusivityDeadline)\n        );\n\n        // Combine all parts with the message\n        return bytes.concat(part1, part2, part3, _parameters.message);\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the native 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossV3NativePacked(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacetV3.AcrossV3Data memory acrossData\n        )\n    {\n        require(\n            data.length >= 140,\n            \"invalid calldata (must have length >= 140)\"\n        );\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[52:56])));\n\n        // extract acrossData\n        acrossData.refundAddress = address(bytes20(data[32:52])); // depositor\n        acrossData.receivingAssetId = address(bytes20(data[56:76]));\n        acrossData.outputAmount = uint256(bytes32(data[76:108]));\n        acrossData.exclusiveRelayer = address(bytes20(data[108:128]));\n        acrossData.quoteTimestamp = uint32(bytes4(data[128:132]));\n        acrossData.fillDeadline = uint32(bytes4(data[132:136]));\n        acrossData.exclusivityDeadline = uint32(bytes4(data[136:140]));\n        acrossData.message = data[140:];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the ERC20 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossV3ERC20Packed(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacetV3.AcrossV3Data memory acrossData\n        )\n    {\n        require(\n            data.length >= 176,\n            \"invalid calldata (must have length >= 176)\"\n        );\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        acrossData.refundAddress = address(bytes20(data[32:52])); // depositor\n        bridgeData.sendingAssetId = address(bytes20(data[52:72]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[72:88])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[88:92])));\n\n        acrossData.receivingAssetId = address(bytes20(data[92:112]));\n        acrossData.outputAmount = uint256(bytes32(data[112:144]));\n        acrossData.exclusiveRelayer = address(bytes20(data[144:164]));\n        acrossData.quoteTimestamp = uint32(bytes4(data[164:168]));\n        acrossData.fillDeadline = uint32(bytes4(data[168:172]));\n        acrossData.exclusivityDeadline = uint32(bytes4(data[172:176]));\n        acrossData.message = data[176:];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Execute calldata and withdraw asset\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to address to withdraw to\n    /// @param _amount amount of asset to withdraw\n    function executeCallAndWithdraw(\n        address _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // execute calldata\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _callTo.call(_callData);\n\n        // check success of call\n        if (success) {\n            // call successful - withdraw the asset\n            LibAsset.transferAsset(_assetAddress, payable(_to), _amount);\n            emit CallExecutedAndFundsWithdrawn();\n        } else {\n            // call unsuccessful - revert\n            revert WithdrawFailed();\n        }\n    }\n}\n"
      },
      "call_graph": {
        "AcrossFacetPackedV3": {
          "startBridgeTokensViaAcrossV3NativePacked": [],
          "startBridgeTokensViaAcrossV3NativeMin": [],
          "startBridgeTokensViaAcrossV3ERC20Packed": [],
          "startBridgeTokensViaAcrossV3ERC20Min": [],
          "encode_startBridgeTokensViaAcrossV3NativePacked": [],
          "encode_startBridgeTokensViaAcrossV3ERC20Packed": [],
          "decode_startBridgeTokensViaAcrossV3NativePacked": [],
          "decode_startBridgeTokensViaAcrossV3ERC20Packed": []
        }
      },
      "flow_data": {
        "AcrossFacetPackedV3": {
          "startBridgeTokensViaAcrossV3NativePacked": {
            "name": "startBridgeTokensViaAcrossV3NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAcrossV3NativeMin": {
            "name": "startBridgeTokensViaAcrossV3NativeMin",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "PackedParameters",
                "name": "_parameters"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaAcrossV3ERC20Packed": {
            "name": "startBridgeTokensViaAcrossV3ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(msg.data[52:72]))",
                "line": 1
              },
              {
                "variable": "inputAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[72:88])))",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: sendingAssetId = address(bytes20(msg.data[52:72]))",
              "2": "State Change: inputAmount = uint256(uint128(bytes16(msg.data[72:88])))"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAcrossV3ERC20Min": {
            "name": "startBridgeTokensViaAcrossV3ERC20Min",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "PackedParameters",
                "name": "_parameters"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "inputAmount"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaAcrossV3NativePacked": {
            "name": "encode_startBridgeTokensViaAcrossV3NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_parameters.destinationChainId <= type(uint32",
                "line": 3
              }
            ],
            "line_mapping": {
              "3": "require(_parameters.destinationChainId <= type(uint32)"
            },
            "parameters": [
              {
                "type": "PackedParameters",
                "name": "_parameters"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "encode_startBridgeTokensViaAcrossV3ERC20Packed": {
            "name": "encode_startBridgeTokensViaAcrossV3ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_parameters.destinationChainId <= type(uint32",
                "line": 3
              },
              {
                "type": "require",
                "condition": "inputAmount <= type(uint128",
                "line": 8
              }
            ],
            "line_mapping": {
              "3": "require(_parameters.destinationChainId <= type(uint32)",
              "8": "require(inputAmount <= type(uint128)"
            },
            "parameters": [
              {
                "type": "PackedParameters",
                "name": "_parameters"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "inputAmount"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossV3NativePacked": {
            "name": "decode_startBridgeTokensViaAcrossV3NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "transactionId",
                "type": "bytes32",
                "value": "bytes32(bytes8(data[4:12]))",
                "line": 7
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(data[12:32]))",
                "line": 8
              },
              {
                "variable": "destinationChainId",
                "type": "uint64",
                "value": "uint64(uint32(bytes4(data[52:56])))",
                "line": 9
              },
              {
                "variable": "receivingAssetId",
                "type": "address",
                "value": "address(bytes20(data[56:76]))",
                "line": 13
              },
              {
                "variable": "outputAmount",
                "type": "uint256",
                "value": "uint256(bytes32(data[76:108]))",
                "line": 14
              },
              {
                "variable": "exclusiveRelayer",
                "type": "address",
                "value": "address(bytes20(data[108:128]))",
                "line": 15
              },
              {
                "variable": "quoteTimestamp",
                "type": "uint32",
                "value": "uint32(bytes4(data[128:132]))",
                "line": 16
              },
              {
                "variable": "fillDeadline",
                "type": "uint32",
                "value": "uint32(bytes4(data[132:136]))",
                "line": 17
              },
              {
                "variable": "exclusivityDeadline",
                "type": "uint32",
                "value": "uint32(bytes4(data[136:140]))",
                "line": 18
              },
              {
                "variable": "message",
                "type": "bytes",
                "value": "data[140:]",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "data.length >= 140,\n            \"invalid calldata (must have length >= 140",
                "line": 1
              }
            ],
            "line_mapping": {
              "7": "State Change: transactionId = bytes32(bytes8(data[4:12]))",
              "8": "State Change: receiver = address(bytes20(data[12:32]))",
              "9": "State Change: destinationChainId = uint64(uint32(bytes4(data[52:56])))",
              "13": "State Change: receivingAssetId = address(bytes20(data[56:76]))",
              "14": "State Change: outputAmount = uint256(bytes32(data[76:108]))",
              "15": "State Change: exclusiveRelayer = address(bytes20(data[108:128]))",
              "16": "State Change: quoteTimestamp = uint32(bytes4(data[128:132]))",
              "17": "State Change: fillDeadline = uint32(bytes4(data[132:136]))",
              "18": "State Change: exclusivityDeadline = uint32(bytes4(data[136:140]))",
              "19": "State Change: message = data[140:]",
              "1": "require(data.length >= 140,\n            \"invalid calldata (must have length >= 140)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory bridgeData"
              },
              {
                "type": "AcrossFacetV3.AcrossV3Data memory acrossData"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossV3ERC20Packed": {
            "name": "decode_startBridgeTokensViaAcrossV3ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "transactionId",
                "type": "bytes32",
                "value": "bytes32(bytes8(data[4:12]))",
                "line": 6
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(data[12:32]))",
                "line": 7
              },
              {
                "variable": "destinationChainId",
                "type": "uint64",
                "value": "uint64(uint32(bytes4(data[88:92])))",
                "line": 11
              },
              {
                "variable": "receivingAssetId",
                "type": "address",
                "value": "address(bytes20(data[92:112]))",
                "line": 13
              },
              {
                "variable": "outputAmount",
                "type": "uint256",
                "value": "uint256(bytes32(data[112:144]))",
                "line": 14
              },
              {
                "variable": "exclusiveRelayer",
                "type": "address",
                "value": "address(bytes20(data[144:164]))",
                "line": 15
              },
              {
                "variable": "quoteTimestamp",
                "type": "uint32",
                "value": "uint32(bytes4(data[164:168]))",
                "line": 16
              },
              {
                "variable": "fillDeadline",
                "type": "uint32",
                "value": "uint32(bytes4(data[168:172]))",
                "line": 17
              },
              {
                "variable": "exclusivityDeadline",
                "type": "uint32",
                "value": "uint32(bytes4(data[172:176]))",
                "line": 18
              },
              {
                "variable": "message",
                "type": "bytes",
                "value": "data[176:]",
                "line": 19
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(data[52:72]))",
                "line": 9
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "data.length >= 176,\n            \"invalid calldata (must have length >= 176",
                "line": 1
              }
            ],
            "line_mapping": {
              "6": "State Change: transactionId = bytes32(bytes8(data[4:12]))",
              "7": "State Change: receiver = address(bytes20(data[12:32]))",
              "11": "State Change: destinationChainId = uint64(uint32(bytes4(data[88:92])))",
              "13": "State Change: receivingAssetId = address(bytes20(data[92:112]))",
              "14": "State Change: outputAmount = uint256(bytes32(data[112:144]))",
              "15": "State Change: exclusiveRelayer = address(bytes20(data[144:164]))",
              "16": "State Change: quoteTimestamp = uint32(bytes4(data[164:168]))",
              "17": "State Change: fillDeadline = uint32(bytes4(data[168:172]))",
              "18": "State Change: exclusivityDeadline = uint32(bytes4(data[172:176]))",
              "19": "State Change: message = data[176:]",
              "9": "State Change: sendingAssetId = address(bytes20(data[52:72]))",
              "1": "require(data.length >= 176,\n            \"invalid calldata (must have length >= 176)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory bridgeData"
              },
              {
                "type": "AcrossFacetV3.AcrossV3Data memory acrossData"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "AcrossFacetPackedV3": {
          "startBridgeTokensViaAcrossV3NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossV3NativeMin": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossV3ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAcrossV3ERC20Min": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaAcrossV3NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_parameters.destinationChainId <= type(uint32",
                "line": 3,
                "type": "require"
              }
            ]
          },
          "encode_startBridgeTokensViaAcrossV3ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_parameters.destinationChainId <= type(uint32",
                "line": 3,
                "type": "require"
              },
              {
                "condition": "inputAmount <= type(uint128",
                "line": 8,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossV3NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "data.length >= 140,\n            \"invalid calldata (must have length >= 140",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaAcrossV3ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "data.length >= 176,\n            \"invalid calldata (must have length >= 176",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.509506"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.535796"
      },
      "final_report": {
        "file_id": "AcrossFacetPackedV3.sol",
        "timestamp": "2025-03-11T07:05:50.535821",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AcrossFacetPackedV3": {
            "functions": 8,
            "state_variables": 13,
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AcrossFacetPackedV3.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.535835"
    },
    "AcrossFacetV3.sol": {
      "file_id": "AcrossFacetV3.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AcrossFacetV3": {
            "name": "AcrossFacetV3",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "AcrossV3Data",
                    "name": "_acrossData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// validate destination call flag\n        if (_acrossData.message.length > 0 != _bridgeData.hasDestinationCall)\n            revert InformationMismatch();\n\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _acrossData.receiverAddress)\n        ) revert InformationMismatch();\n\n        // check if sendingAsset is native or ERC20\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // NATIVE\n            spokePool.depositV3{ value: _bridgeData.minAmount }(\n                _acrossData.refundAddress, // depositor (also acts as refund address in case release tx cannot be executed)\n                _acrossData.receiverAddress, // recipient (on dst)\n                wrappedNative, // inputToken\n                _acrossData.receivingAssetId, // outputToken\n                _bridgeData.minAmount, // inputAmount\n                _acrossData.outputAmount, // outputAmount\n                _bridgeData.destinationChainId,\n                _acrossData.exclusiveRelayer,\n                _acrossData.quoteTimestamp,\n                _acrossData.fillDeadline,\n                _acrossData.exclusivityDeadline,\n                _acrossData.message\n            );\n        } else {\n            // ERC20\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.depositV3(\n                _acrossData.refundAddress, // depositor (also acts as refund address in case release tx cannot be executed)\n                _acrossData.receiverAddress, // recipient (on dst)\n                _bridgeData.sendingAssetId, // inputToken\n                _acrossData.receivingAssetId, // outputToken\n                _bridgeData.minAmount, // inputAmount\n                _acrossData.outputAmount, // outputAmount\n                _bridgeData.destinationChainId,\n                _acrossData.exclusiveRelayer,\n                _acrossData.quoteTimestamp,\n                _acrossData.fillDeadline,\n                _acrossData.exclusivityDeadline,\n                _acrossData.message\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "receiverAddress": {
                "name": "receiverAddress",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "refundAddress": {
                "name": "refundAddress",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "outputAmount": {
                "name": "outputAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "outputAmountPercent": {
                "name": "outputAmountPercent",
                "type": "uint64",
                "visibility": "internal",
                "initial_value": null
              },
              "exclusiveRelayer": {
                "name": "exclusiveRelayer",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "quoteTimestamp": {
                "name": "quoteTimestamp",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "fillDeadline": {
                "name": "fillDeadline",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "exclusivityDeadline": {
                "name": "exclusivityDeadline",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "message": {
                "name": "message",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\n\n/// @title AcrossFacetV3\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across Protocol\n/// @custom:version 1.1.0\ncontract AcrossFacetV3 is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the spoke pool on the source chain.\n    IAcrossSpokePool public immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address public immutable wrappedNative;\n\n    /// Types ///\n\n    /// @param receiverAddress The address that will receive the token on dst chain (our Receiver contract or the user-defined receiver address)\n    /// @param refundAddress The address that will be used for potential bridge refunds\n    /// @param receivingAssetId The address of the token to be received at destination chain\n    /// @param outputAmount The amount to be received at destination chain (after fees)\n    /// @param outputAmountPercent The percentage of the output amount with 18 decimal precision (0.7550e18 = 75.50%, 0.99e18 = 99.00%)\n    /// @param exclusiveRelayer This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n    /// @param quoteTimestamp The timestamp of the Across quote that was used for this transaction\n    /// @param fillDeadline The destination chain timestamp until which the order can be filled\n    /// @param exclusivityDeadline The timestamp on the destination chain after which any relayer can fill the deposit\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    struct AcrossV3Data {\n        address receiverAddress;\n        address refundAddress;\n        address receivingAssetId;\n        uint256 outputAmount;\n        uint64 outputAmountPercent;\n        address exclusiveRelayer;\n        uint32 quoteTimestamp;\n        uint32 fillDeadline;\n        uint32 exclusivityDeadline;\n        bytes message;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _spokePool The contract address of the spoke pool on the source chain.\n    /// @param _wrappedNative The address of the wrapped native token on the source chain.\n    constructor(IAcrossSpokePool _spokePool, address _wrappedNative) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function startBridgeTokensViaAcrossV3(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossV3Data calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// @notice Performs a swap before bridging via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _acrossData data specific to Across\n    function swapAndStartBridgeTokensViaAcrossV3(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AcrossV3Data calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        // Create modified across data with calculated output amount\n        AcrossV3Data memory modifiedAcrossData = _acrossData;\n        modifiedAcrossData.outputAmount =\n            (_bridgeData.minAmount * _acrossData.outputAmountPercent) /\n            1e18;\n\n        _startBridge(_bridgeData, modifiedAcrossData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossV3Data memory _acrossData\n    ) internal {\n        // validate destination call flag\n        if (_acrossData.message.length > 0 != _bridgeData.hasDestinationCall)\n            revert InformationMismatch();\n\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _acrossData.receiverAddress)\n        ) revert InformationMismatch();\n\n        // check if sendingAsset is native or ERC20\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // NATIVE\n            spokePool.depositV3{ value: _bridgeData.minAmount }(\n                _acrossData.refundAddress, // depositor (also acts as refund address in case release tx cannot be executed)\n                _acrossData.receiverAddress, // recipient (on dst)\n                wrappedNative, // inputToken\n                _acrossData.receivingAssetId, // outputToken\n                _bridgeData.minAmount, // inputAmount\n                _acrossData.outputAmount, // outputAmount\n                _bridgeData.destinationChainId,\n                _acrossData.exclusiveRelayer,\n                _acrossData.quoteTimestamp,\n                _acrossData.fillDeadline,\n                _acrossData.exclusivityDeadline,\n                _acrossData.message\n            );\n        } else {\n            // ERC20\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.depositV3(\n                _acrossData.refundAddress, // depositor (also acts as refund address in case release tx cannot be executed)\n                _acrossData.receiverAddress, // recipient (on dst)\n                _bridgeData.sendingAssetId, // inputToken\n                _acrossData.receivingAssetId, // outputToken\n                _bridgeData.minAmount, // inputAmount\n                _acrossData.outputAmount, // outputAmount\n                _bridgeData.destinationChainId,\n                _acrossData.exclusiveRelayer,\n                _acrossData.quoteTimestamp,\n                _acrossData.fillDeadline,\n                _acrossData.exclusivityDeadline,\n                _acrossData.message\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "AcrossFacetV3": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "AcrossFacetV3": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "_acrossData.message.length > 0 != _bridgeData.hasDestinationCall",
                "line": 2
              },
              {
                "type": "if",
                "condition": "!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _acrossData.receiverAddress",
                "line": 6
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 12
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (_acrossData.message.length > 0 != _bridgeData.hasDestinationCall)",
              "6": "if (!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _acrossData.receiverAddress)",
              "12": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "AcrossV3Data",
                "name": "_acrossData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "AcrossFacetV3": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.501543"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.516482"
      },
      "final_report": {
        "file_id": "AcrossFacetV3.sol",
        "timestamp": "2025-03-11T07:05:50.516508",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AcrossFacetV3": {
            "functions": 1,
            "state_variables": 10,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AcrossFacetV3.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.516521"
    },
    "AllBridgeFacet.sol": {
      "file_id": "AllBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AllBridgeFacet": {
            "name": "AllBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "AllBridgeData",
                    "name": "_allBridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(allBridge),\n            _bridgeData.minAmount\n        );\n\n        if (_allBridgeData.payFeeWithSendingAsset) {\n            allBridge.swapAndBridge(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                _allBridgeData.fees\n            );\n        } else {\n            allBridge.swapAndBridge{ value: _allBridgeData.fees }(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                0\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "fees": {
                "name": "fees",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "recipient": {
                "name": "recipient",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationChainId": {
                "name": "destinationChainId",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "receiveToken": {
                "name": "receiveToken",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "nonce": {
                "name": "nonce",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "payFeeWithSendingAsset": {
                "name": "payFeeWithSendingAsset",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAllBridge } from \"../Interfaces/IAllBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Allbridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through AllBridge\n/// @custom:version 2.0.0\ncontract AllBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// @notice The contract address of the AllBridge router on the source chain.\n    IAllBridge private immutable allBridge;\n\n    /// @notice The struct for the AllBridge data.\n    /// @param fees The amount of token to pay the messenger and the bridge\n    /// @param recipient The address of the token receiver after bridging.\n    /// @param destinationChainId The destination chain id.\n    /// @param receiveToken The token to receive on the destination chain.\n    /// @param nonce A random nonce to associate with the tx.\n    /// @param messenger The messenger protocol enum\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AllBridgeData {\n        uint256 fees;\n        bytes32 recipient;\n        uint256 destinationChainId;\n        bytes32 receiveToken;\n        uint256 nonce;\n        IAllBridge.MessengerProtocol messenger;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// @notice Initializes the AllBridge contract\n    /// @param _allBridge The address of the AllBridge contract\n    constructor(IAllBridge _allBridge) {\n        allBridge = _allBridge;\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    function startBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _allBridgeData The AllBridge data struct\n    function swapAndStartBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _allBridgeData The allBridge data struct for AllBridge specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    ) internal {\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(allBridge),\n            _bridgeData.minAmount\n        );\n\n        if (_allBridgeData.payFeeWithSendingAsset) {\n            allBridge.swapAndBridge(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                _allBridgeData.fees\n            );\n        } else {\n            allBridge.swapAndBridge{ value: _allBridgeData.fees }(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                0\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "AllBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "AllBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "_allBridgeData.payFeeWithSendingAsset",
                "line": 7
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "7": "if (_allBridgeData.payFeeWithSendingAsset)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "AllBridgeData",
                "name": "_allBridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "AllBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.501817"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.516617"
      },
      "final_report": {
        "file_id": "AllBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.516633",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AllBridgeFacet": {
            "functions": 1,
            "state_variables": 6,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AllBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.516644"
    },
    "AmarokFacet.sol": {
      "file_id": "AmarokFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AmarokFacet": {
            "name": "AmarokFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "AmarokData",
                    "name": "_amarokData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _amarokData.callTo)\n        ) revert InformationMismatch();\n\n        // give max approval for token to Amarok bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(connextHandler),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        if (_amarokData.payFeeWithSendingAsset) {\n            connextHandler.xcall(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount - _amarokData.relayerFee,\n                _amarokData.slippageTol,\n                _amarokData.callData,\n                _amarokData.relayerFee\n            );\n        } else {\n            connextHandler.xcall{ value: _amarokData.relayerFee }(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount,\n                _amarokData.slippageTol,\n                _amarokData.callData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "validateDestinationCallFlag": {
                "name": "validateDestinationCallFlag",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "AmarokData",
                    "name": "_amarokData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (\n            (_amarokData.callData.length > 0) != _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }"
              }
            },
            "state_variables": {
              "callData": {
                "name": "callData",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "callTo": {
                "name": "callTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "relayerFee": {
                "name": "relayerFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "slippageTol": {
                "name": "slippageTol",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "delegate": {
                "name": "delegate",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "destChainDomainId": {
                "name": "destChainDomainId",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "payFeeWithSendingAsset": {
                "name": "payFeeWithSendingAsset",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Amarok Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Connext Amarok\n/// @custom:version 3.0.0\ncontract AmarokFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// @param callData The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param callTo The address of the contract on dest chain that will receive bridged funds and execute data\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param delegate Destination delegate address\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AmarokData {\n        bytes callData;\n        address callTo;\n        uint256 relayerFee;\n        uint256 slippageTol;\n        address delegate;\n        uint32 destChainDomainId;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    constructor(IConnextHandler _connextHandler) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Amarok\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _amarokData Data specific to bridge\n    function startBridgeTokensViaAmarok(\n        BridgeData calldata _bridgeData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// @notice Performs a swap before bridging via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _amarokData Data specific to Amarok\n    function swapAndStartBridgeTokensViaAmarok(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _amarokData.relayerFee\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _amarokData Data specific to Amarok\n    function _startBridge(\n        BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private {\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _amarokData.callTo)\n        ) revert InformationMismatch();\n\n        // give max approval for token to Amarok bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(connextHandler),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        if (_amarokData.payFeeWithSendingAsset) {\n            connextHandler.xcall(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount - _amarokData.relayerFee,\n                _amarokData.slippageTol,\n                _amarokData.callData,\n                _amarokData.relayerFee\n            );\n        } else {\n            connextHandler.xcall{ value: _amarokData.relayerFee }(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount,\n                _amarokData.slippageTol,\n                _amarokData.callData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private pure {\n        if (\n            (_amarokData.callData.length > 0) != _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
      },
      "call_graph": {
        "AmarokFacet": {
          "_startBridge": [],
          "validateDestinationCallFlag": []
        }
      },
      "flow_data": {
        "AmarokFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _amarokData.callTo",
                "line": 2
              },
              {
                "type": "if",
                "condition": "_amarokData.payFeeWithSendingAsset",
                "line": 15
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _amarokData.callTo)",
              "15": "if (_amarokData.payFeeWithSendingAsset)"
            },
            "parameters": [
              {
                "type": "BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "AmarokData",
                "name": "_amarokData"
              }
            ],
            "returns": []
          },
          "validateDestinationCallFlag": {
            "name": "validateDestinationCallFlag",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "(_amarokData.callData.length > 0",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if ((_amarokData.callData.length > 0)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "AmarokData",
                "name": "_amarokData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "AmarokFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "validateDestinationCallFlag": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.588004"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.592624"
      },
      "final_report": {
        "file_id": "AmarokFacet.sol",
        "timestamp": "2025-03-11T07:05:50.592648",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AmarokFacet": {
            "functions": 2,
            "state_variables": 7,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AmarokFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.592660"
    },
    "AmarokFacetPacked.sol": {
      "file_id": "AmarokFacetPacked.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "AmarokFacetPacked": {
            "name": "AmarokFacetPacked",
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ],
            "functions": {
              "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
                "name": "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n        uint256 relayerFee = uint64(uint32(bytes4(msg.data[76:92])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall(\n            uint32(bytes4(msg.data[68:72])), // _destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
                "name": "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall{ value: msg.value }(\n            uint32(bytes4(msg.data[68:72])), // destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset": {
                "name": "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint32",
                    "name": "destChainDomainId"
                  },
                  {
                    "type": "uint256",
                    "name": "slippageTol"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            slippageTol,\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }"
              },
              "startBridgeTokensViaAmarokERC20MinPayFeeWithNative": {
                "name": "startBridgeTokensViaAmarokERC20MinPayFeeWithNative",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint32",
                    "name": "destChainDomainId"
                  },
                  {
                    "type": "uint256",
                    "name": "slippageTol"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall{ value: msg.value }(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            slippageTol,\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }"
              },
              "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
                "name": "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint32",
                    "name": "destChainDomainId"
                  },
                  {
                    "type": "uint256",
                    "name": "slippageTol"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol)),\n                bytes16(uint128(relayerFee))\n            );\n    }"
              },
              "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
                "name": "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint32",
                    "name": "destChainDomainId"
                  },
                  {
                    "type": "uint256",
                    "name": "slippageTol"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol))\n            );\n    }"
              },
              "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
                "name": "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "AmarokFacet.AmarokData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 92,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint32(bytes4(_data[72:76]));\n        amarokData.relayerFee = uint256(uint128(bytes16(_data[76:92])));\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = true;\n\n        return (bridgeData, amarokData);\n    }"
              },
              "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
                "name": "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "AmarokFacet.AmarokData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 76,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint256(\n            uint128(uint32(bytes4(_data[72:76])))\n        );\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = false;\n\n        return (bridgeData, amarokData);\n    }"
              },
              "getChainIdForDomain": {
                "name": "getChainIdForDomain",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "uint32",
                    "name": "domainId"
                  }
                ],
                "returns": [
                  {
                    "type": "uint32 chainId"
                  }
                ],
                "modifiers": [],
                "code": "if (domainId == 6648936) return 1;\n        // ETH\n        else if (domainId == 1886350457) return 137;\n        // POL\n        else if (domainId == 6450786) return 56;\n        // BSC\n        else if (domainId == 1869640809) return 10;\n        // OPT\n        else if (domainId == 6778479) return 100;\n        // GNO/DAI\n        else if (domainId == 1634886255) return 42161;\n        // ARB\n        else if (domainId == 1818848877) return 59144; // LIN\n    }"
              }
            },
            "state_variables": {
              "numTokens": {
                "name": "numTokens",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokensToApprove.length"
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(bytes20(msg.data[32:52]))"
              },
              "minAmount": {
                "name": "minAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[52:68])))"
              },
              "receiver": {
                "name": "receiver",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(bytes20(msg.data[12:32]))"
              },
              "relayerFee": {
                "name": "relayerFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint64(uint32(bytes4(msg.data[76:92])))"
              },
              "destChainDomainId": {
                "name": "destChainDomainId",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": "uint32(bytes4(_data[68:72]))"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// // SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AmarokFacet } from \"lifi/Facets/AmarokFacet.sol\";\nimport { console2 } from \"forge-std/console2.sol\";\n\n/// @title AmarokFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Amarok in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AmarokFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// Events ///\n\n    event LiFiAmarokTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    /// @param _owner The contract owner to approve tokens.\n    constructor(\n        IConnextHandler _connextHandler,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Amarok bridge to spend the specified token\n    /// @param tokensToApprove The tokens to approve to approve to the Amarok bridge\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numTokens = tokensToApprove.length;\n\n        for (uint256 i; i < numTokens; i++) {\n            // Give Amarok approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(connextHandler),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset() external {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n        uint256 relayerFee = uint64(uint32(bytes4(msg.data[76:92])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall(\n            uint32(bytes4(msg.data[68:72])), // _destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithNative()\n        external\n        payable\n    {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall{ value: msg.value }(\n            uint32(bytes4(msg.data[68:72])), // destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            slippageTol,\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall{ value: msg.value }(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            slippageTol,\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol)),\n                bytes16(uint128(relayerFee))\n            );\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 92,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint32(bytes4(_data[72:76]));\n        amarokData.relayerFee = uint256(uint128(bytes16(_data[76:92])));\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = true;\n\n        return (bridgeData, amarokData);\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 76,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint256(\n            uint128(uint32(bytes4(_data[72:76])))\n        );\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = false;\n\n        return (bridgeData, amarokData);\n    }\n\n    function getChainIdForDomain(\n        uint32 domainId\n    ) public pure returns (uint32 chainId) {\n        if (domainId == 6648936) return 1;\n        // ETH\n        else if (domainId == 1886350457) return 137;\n        // POL\n        else if (domainId == 6450786) return 56;\n        // BSC\n        else if (domainId == 1869640809) return 10;\n        // OPT\n        else if (domainId == 6778479) return 100;\n        // GNO/DAI\n        else if (domainId == 1634886255) return 42161;\n        // ARB\n        else if (domainId == 1818848877) return 59144; // LIN\n    }\n}\n"
      },
      "call_graph": {
        "AmarokFacetPacked": {
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": [],
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": [],
          "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset": [],
          "startBridgeTokensViaAmarokERC20MinPayFeeWithNative": [],
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": [],
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": [],
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": [
            {
              "contract": "AmarokFacetPacked",
              "function": "getChainIdForDomain"
            }
          ],
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": [
            {
              "contract": "AmarokFacetPacked",
              "function": "getChainIdForDomain"
            }
          ],
          "getChainIdForDomain": []
        }
      },
      "flow_data": {
        "AmarokFacetPacked": {
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "name": "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(msg.data[32:52]))",
                "line": 2
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[52:68])))",
                "line": 3
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(msg.data[12:32]))",
                "line": 4
              },
              {
                "variable": "relayerFee",
                "type": "uint256",
                "value": "uint64(uint32(bytes4(msg.data[76:92])))",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: sendingAssetId = address(bytes20(msg.data[32:52]))",
              "3": "State Change: minAmount = uint256(uint128(bytes16(msg.data[52:68])))",
              "4": "State Change: receiver = address(bytes20(msg.data[12:32]))",
              "5": "State Change: relayerFee = uint64(uint32(bytes4(msg.data[76:92])))"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "name": "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(msg.data[32:52]))",
                "line": 2
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[52:68])))",
                "line": 3
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(msg.data[12:32]))",
                "line": 4
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: sendingAssetId = address(bytes20(msg.data[32:52]))",
              "3": "State Change: minAmount = uint256(uint128(bytes16(msg.data[52:68])))",
              "4": "State Change: receiver = address(bytes20(msg.data[12:32]))"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset": {
            "name": "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint32",
                "name": "destChainDomainId"
              },
              {
                "type": "uint256",
                "name": "slippageTol"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaAmarokERC20MinPayFeeWithNative": {
            "name": "startBridgeTokensViaAmarokERC20MinPayFeeWithNative",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint32",
                "name": "destChainDomainId"
              },
              {
                "type": "uint256",
                "name": "slippageTol"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "name": "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 1
              },
              {
                "type": "require",
                "condition": "slippageTol <= type(uint32",
                "line": 5
              },
              {
                "type": "require",
                "condition": "relayerFee <= type(uint128",
                "line": 9
              }
            ],
            "line_mapping": {
              "1": "require(minAmount <= type(uint128)",
              "5": "require(slippageTol <= type(uint32)",
              "9": "require(relayerFee <= type(uint128)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint32",
                "name": "destChainDomainId"
              },
              {
                "type": "uint256",
                "name": "slippageTol"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "name": "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 1
              },
              {
                "type": "require",
                "condition": "slippageTol <= type(uint32",
                "line": 5
              }
            ],
            "line_mapping": {
              "1": "require(minAmount <= type(uint128)",
              "5": "require(slippageTol <= type(uint32)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint32",
                "name": "destChainDomainId"
              },
              {
                "type": "uint256",
                "name": "slippageTol"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "name": "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(_data[32:52]))",
                "line": 14
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(_data[52:68])))",
                "line": 15
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(_data[12:32]))",
                "line": 12
              },
              {
                "variable": "relayerFee",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(_data[76:92])))",
                "line": 21
              },
              {
                "variable": "destChainDomainId",
                "type": "uint32",
                "value": "uint32(bytes4(_data[68:72]))",
                "line": 9
              },
              {
                "variable": "destChainDomainId",
                "type": "uint32",
                "value": "destChainDomainId",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 92,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "14": "State Change: sendingAssetId = address(bytes20(_data[32:52]))",
              "15": "State Change: minAmount = uint256(uint128(bytes16(_data[52:68])))",
              "12": "State Change: receiver = address(bytes20(_data[12:32]))",
              "21": "State Change: relayerFee = uint256(uint128(bytes16(_data[76:92])))",
              "9": "State Change: destChainDomainId = uint32(bytes4(_data[68:72]))",
              "19": "State Change: destChainDomainId = destChainDomainId",
              "1": "require(_data.length >= 92,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "AmarokFacet.AmarokData memory"
              }
            ]
          },
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "name": "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(_data[32:52]))",
                "line": 14
              },
              {
                "variable": "minAmount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(_data[52:68])))",
                "line": 15
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(bytes20(_data[12:32]))",
                "line": 12
              },
              {
                "variable": "destChainDomainId",
                "type": "uint32",
                "value": "uint32(bytes4(_data[68:72]))",
                "line": 9
              },
              {
                "variable": "destChainDomainId",
                "type": "uint32",
                "value": "destChainDomainId",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 76,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "14": "State Change: sendingAssetId = address(bytes20(_data[32:52]))",
              "15": "State Change: minAmount = uint256(uint128(bytes16(_data[52:68])))",
              "12": "State Change: receiver = address(bytes20(_data[12:32]))",
              "9": "State Change: destChainDomainId = uint32(bytes4(_data[68:72]))",
              "19": "State Change: destChainDomainId = destChainDomainId",
              "1": "require(_data.length >= 76,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "AmarokFacet.AmarokData memory"
              }
            ]
          },
          "getChainIdForDomain": {
            "name": "getChainIdForDomain",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "domainId == 6648936",
                "line": 1
              },
              {
                "type": "if",
                "condition": "domainId == 1886350457",
                "line": 3
              },
              {
                "type": "if",
                "condition": "domainId == 6450786",
                "line": 5
              },
              {
                "type": "if",
                "condition": "domainId == 1869640809",
                "line": 7
              },
              {
                "type": "if",
                "condition": "domainId == 6778479",
                "line": 9
              },
              {
                "type": "if",
                "condition": "domainId == 1634886255",
                "line": 11
              },
              {
                "type": "if",
                "condition": "domainId == 1818848877",
                "line": 13
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (domainId == 6648936)",
              "3": "if (domainId == 1886350457)",
              "5": "if (domainId == 6450786)",
              "7": "if (domainId == 1869640809)",
              "9": "if (domainId == 6778479)",
              "11": "if (domainId == 1634886255)",
              "13": "if (domainId == 1818848877)"
            },
            "parameters": [
              {
                "type": "uint32",
                "name": "domainId"
              }
            ],
            "returns": [
              {
                "type": "uint32 chainId"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "AmarokFacetPacked": {
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAmarokERC20MinPayFeeWithAsset": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaAmarokERC20MinPayFeeWithNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "minAmount <= type(uint128",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "slippageTol <= type(uint32",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "relayerFee <= type(uint128",
                "line": 9,
                "type": "require"
              }
            ]
          },
          "encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "minAmount <= type(uint128",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "slippageTol <= type(uint32",
                "line": 5,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset": {
            "calls": [
              {
                "contract": "AmarokFacetPacked",
                "function": "getChainIdForDomain",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 92,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "getChainIdForDomain": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative": {
            "calls": [
              {
                "contract": "AmarokFacetPacked",
                "function": "getChainIdForDomain",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 76,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.589368"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.593047"
      },
      "final_report": {
        "file_id": "AmarokFacetPacked.sol",
        "timestamp": "2025-03-11T07:05:50.593067",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "AmarokFacetPacked": {
            "functions": 9,
            "state_variables": 6,
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of AmarokFacetPacked.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.593080"
    },
    "ArbitrumBridgeFacet.sol": {
      "file_id": "ArbitrumBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ArbitrumBridgeFacet": {
            "name": "ArbitrumBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "ArbitrumData",
                    "name": "_arbitrumData"
                  },
                  {
                    "type": "uint256",
                    "name": "_cost"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            inbox.unsafeCreateRetryableTicket{\n                value: _bridgeData.minAmount + _cost\n            }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount, // l2CallValue\n                _arbitrumData.maxSubmissionCost,\n                _bridgeData.receiver, // excessFeeRefundAddress\n                _bridgeData.receiver, // callValueRefundAddress\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                gatewayRouter.getGateway(_bridgeData.sendingAssetId),\n                _bridgeData.minAmount\n            );\n            gatewayRouter.outboundTransfer{ value: _cost }(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                abi.encode(_arbitrumData.maxSubmissionCost, \"\")\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "maxSubmissionCost": {
                "name": "maxSubmissionCost",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "maxGas": {
                "name": "maxGas",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "maxGasPrice": {
                "name": "maxGasPrice",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "cost": {
                "name": "cost",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGatewayRouter } from \"../Interfaces/IGatewayRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidAmount } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Arbitrum Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Arbitrum Bridge\n/// @custom:version 1.0.0\ncontract ArbitrumBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The contract address of the gateway router on the source chain.\n    IGatewayRouter private immutable gatewayRouter;\n\n    /// @notice The contract address of the inbox on the source chain.\n    IGatewayRouter private immutable inbox;\n\n    /// Types ///\n\n    /// @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee.\n    /// @param maxGas Max gas deducted from user's L2 balance to cover L2 execution.\n    /// @param maxGasPrice price bid for L2 execution.\n    struct ArbitrumData {\n        uint256 maxSubmissionCost;\n        uint256 maxGas;\n        uint256 maxGasPrice;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _gatewayRouter The contract address of the gateway router on the source chain.\n    /// @param _inbox The contract address of the inbox on the source chain.\n    constructor(IGatewayRouter _gatewayRouter, IGatewayRouter _inbox) {\n        gatewayRouter = _gatewayRouter;\n        inbox = _inbox;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function startBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// @notice Performs a swap before bridging via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function swapAndStartBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            cost\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    /// @param _cost Additional amount of native asset for the fee\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData,\n        uint256 _cost\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            inbox.unsafeCreateRetryableTicket{\n                value: _bridgeData.minAmount + _cost\n            }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount, // l2CallValue\n                _arbitrumData.maxSubmissionCost,\n                _bridgeData.receiver, // excessFeeRefundAddress\n                _bridgeData.receiver, // callValueRefundAddress\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                gatewayRouter.getGateway(_bridgeData.sendingAssetId),\n                _bridgeData.minAmount\n            );\n            gatewayRouter.outboundTransfer{ value: _cost }(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                abi.encode(_arbitrumData.maxSubmissionCost, \"\")\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "ArbitrumBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "ArbitrumBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "ArbitrumData",
                "name": "_arbitrumData"
              },
              {
                "type": "uint256",
                "name": "_cost"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "ArbitrumBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.592767"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.602625"
      },
      "final_report": {
        "file_id": "ArbitrumBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.602647",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ArbitrumBridgeFacet": {
            "functions": 1,
            "state_variables": 4,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ArbitrumBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.602660"
    },
    "CBridgeFacet.sol": {
      "file_id": "CBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CBridgeFacet": {
            "name": "CBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "triggerRefund": {
                "name": "triggerRefund",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_callTo"
                  },
                  {
                    "type": "bytes",
                    "name": "_callData"
                  },
                  {
                    "type": "address",
                    "name": "_assetAddress"
                  },
                  {
                    "type": "address",
                    "name": "_to"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }"
              },
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "CBridgeData",
                    "name": "_cBridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            cBridge.sendNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(cBridge),\n                _bridgeData.minAmount\n            );\n            // solhint-disable check-send-result\n            cBridge.send(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "maxSlippage": {
                "name": "maxSlippage",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "nonce": {
                "name": "nonce",
                "type": "uint64",
                "visibility": "internal",
                "initial_value": null
              },
              "success": {
                "name": "success",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "sendTo": {
                "name": "sendTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\n\n/// @title CBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.0\ncontract CBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Types ///\n\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    ///              Can be timestamp in practice.\n    struct CBridgeData {\n        uint32 maxSlippage;\n        uint64 nonce;\n    }\n\n    /// Events ///\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(ICBridge _cBridge) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function startBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _cBridgeData data specific to CBridge\n    function swapAndStartBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            cBridge.sendNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(cBridge),\n                _bridgeData.minAmount\n            );\n            // solhint-disable check-send-result\n            cBridge.send(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "CBridgeFacet": {
          "triggerRefund": [],
          "_startBridge": []
        }
      },
      "flow_data": {
        "CBridgeFacet": {
          "triggerRefund": {
            "name": "triggerRefund",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "if",
                "condition": "address(cBridge",
                "line": 6
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 13
              }
            ],
            "state_changes": [
              {
                "variable": "sendTo",
                "type": "address",
                "value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to",
                "line": 18
              }
            ],
            "external_calls": [
              {
                "target": "_callTo",
                "type": "call",
                "arguments": "_callData",
                "line": 12
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "6": "if (address(cBridge)",
              "13": "if (!success)",
              "18": "State Change: sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to",
              "12": "External Call: _callTo.call(_callData)"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_callTo"
              },
              {
                "type": "bytes",
                "name": "_callData"
              },
              {
                "type": "address",
                "name": "_assetAddress"
              },
              {
                "type": "address",
                "name": "_to"
              },
              {
                "type": "uint256",
                "name": "_amount"
              }
            ],
            "returns": []
          },
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [
              {
                "target": "cBridge",
                "type": "send",
                "arguments": "_bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId",
                "line": 17
              }
            ],
            "value_transfers": [
              {
                "target": "cBridge",
                "type": "send",
                "line": 17
              }
            ],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "17": "External Call: cBridge.send(_bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "CBridgeData",
                "name": "_cBridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "CBridgeFacet": {
          "triggerRefund": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [
              {
                "from": "CBridgeFacet",
                "to": "cBridge",
                "via": "_startBridge",
                "line": 17
              }
            ],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.647600"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.651892"
      },
      "final_report": {
        "file_id": "CBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.651916",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CBridgeFacet": {
            "functions": 2,
            "state_variables": 4,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.651930"
    },
    "CBridgeFacetPacked.sol": {
      "file_id": "CBridgeFacetPacked.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CBridgeFacetPacked": {
            "name": "CBridgeFacetPacked",
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ],
            "functions": {
              "startBridgeTokensViaCBridgeNativePacked": {
                "name": "startBridgeTokensViaCBridgeNativePacked",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "cBridge.sendNative{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            msg.value, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[36:40]))), // nonce\n            uint32(bytes4(msg.data[40:44])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12])); // transactionId\n    }"
              },
              "startBridgeTokensViaCBridgeNativeMin": {
                "name": "startBridgeTokensViaCBridgeNativeMin",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint64",
                    "name": "nonce"
                  },
                  {
                    "type": "uint32",
                    "name": "maxSlippage"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "cBridge.sendNative{ value: msg.value }(\n            receiver,\n            msg.value,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }"
              },
              "startBridgeTokensViaCBridgeERC20Packed": {
                "name": "startBridgeTokensViaCBridgeERC20Packed",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "address sendingAssetId = address(bytes20(msg.data[36:56]));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            address(bytes20(msg.data[12:32])), // receiver\n            sendingAssetId, // sendingAssetId\n            amount, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[72:76]))), // nonce\n            uint32(bytes4(msg.data[76:80])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaCBridgeERC20Min": {
                "name": "startBridgeTokensViaCBridgeERC20Min",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "uint64",
                    "name": "nonce"
                  },
                  {
                    "type": "uint32",
                    "name": "maxSlippage"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }"
              },
              "encode_startBridgeTokensViaCBridgeNativePacked": {
                "name": "encode_startBridgeTokensViaCBridgeNativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint64",
                    "name": "nonce"
                  },
                  {
                    "type": "uint32",
                    "name": "maxSlippage"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }"
              },
              "decode_startBridgeTokensViaCBridgeNativePacked": {
                "name": "decode_startBridgeTokensViaCBridgeNativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "CBridgeFacet.CBridgeData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 44,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[36:40])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[40:44]));\n\n        return (bridgeData, cBridgeData);\n    }"
              },
              "encode_startBridgeTokensViaCBridgeERC20Packed": {
                "name": "encode_startBridgeTokensViaCBridgeERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint64",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint64",
                    "name": "nonce"
                  },
                  {
                    "type": "uint32",
                    "name": "maxSlippage"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }"
              },
              "decode_startBridgeTokensViaCBridgeERC20Packed": {
                "name": "decode_startBridgeTokensViaCBridgeERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "CBridgeFacet.CBridgeData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(_data.length >= 80, \"data passed is not the correct length\");\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[72:76])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[76:80]));\n\n        return (bridgeData, cBridgeData);\n    }"
              }
            },
            "state_variables": {
              "success": {
                "name": "success",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "sendTo": {
                "name": "sendTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to"
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(bytes20(msg.data[36:56]))"
              },
              "amount": {
                "name": "amount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[56:72])))"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { CBridgeFacet } from \"./CBridgeFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title CBridge Facet Packed\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.3\ncontract CBridgeFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Events ///\n\n    event LiFiCBridgeTransfer(bytes8 _transactionId);\n\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(\n        ICBridge _cBridge,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the CBridge Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the CBridge Router\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(cBridge),\n                type(uint256).max\n            );\n        }\n    }\n\n    // This is needed to receive native asset if a refund asset is a native asset\n    receive() external payable {}\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// @notice Bridges Native tokens via cBridge (packed)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeNativePacked() external payable {\n        cBridge.sendNative{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            msg.value, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[36:40]))), // nonce\n            uint32(bytes4(msg.data[40:44])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12])); // transactionId\n    }\n\n    /// @notice Bridges native tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external payable {\n        cBridge.sendNative{ value: msg.value }(\n            receiver,\n            msg.value,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeERC20Packed() external {\n        address sendingAssetId = address(bytes20(msg.data[36:56]));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            address(bytes20(msg.data[12:32])), // receiver\n            sendingAssetId, // sendingAssetId\n            amount, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[72:76]))), // nonce\n            uint32(bytes4(msg.data[76:80])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param amount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeERC20Min(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 amount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// Encoder/Decoders ///\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaCBridgeNativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(\n            _data.length >= 44,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[36:40])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[40:44]));\n\n        return (bridgeData, cBridgeData);\n    }\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeERC20Packed\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    function decode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(_data.length >= 80, \"data passed is not the correct length\");\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[72:76])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[76:80]));\n\n        return (bridgeData, cBridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "CBridgeFacetPacked": {
          "startBridgeTokensViaCBridgeNativePacked": [],
          "startBridgeTokensViaCBridgeNativeMin": [],
          "startBridgeTokensViaCBridgeERC20Packed": [],
          "startBridgeTokensViaCBridgeERC20Min": [],
          "encode_startBridgeTokensViaCBridgeNativePacked": [],
          "decode_startBridgeTokensViaCBridgeNativePacked": [],
          "encode_startBridgeTokensViaCBridgeERC20Packed": [],
          "decode_startBridgeTokensViaCBridgeERC20Packed": []
        }
      },
      "flow_data": {
        "CBridgeFacetPacked": {
          "startBridgeTokensViaCBridgeNativePacked": {
            "name": "startBridgeTokensViaCBridgeNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaCBridgeNativeMin": {
            "name": "startBridgeTokensViaCBridgeNativeMin",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "uint64",
                "name": "nonce"
              },
              {
                "type": "uint32",
                "name": "maxSlippage"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaCBridgeERC20Packed": {
            "name": "startBridgeTokensViaCBridgeERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(msg.data[36:56]))",
                "line": 1
              },
              {
                "variable": "amount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[56:72])))",
                "line": 2
              }
            ],
            "external_calls": [
              {
                "target": "cBridge",
                "type": "send",
                "arguments": "address(bytes20(msg.data[12:32]",
                "line": 13
              }
            ],
            "value_transfers": [
              {
                "target": "cBridge",
                "type": "send",
                "line": 13
              }
            ],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: sendingAssetId = address(bytes20(msg.data[36:56]))",
              "2": "State Change: amount = uint256(uint128(bytes16(msg.data[56:72])))",
              "13": "External Call: cBridge.send(address(bytes20(msg.data[12:32])"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaCBridgeERC20Min": {
            "name": "startBridgeTokensViaCBridgeERC20Min",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [
              {
                "target": "cBridge",
                "type": "send",
                "arguments": "receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage",
                "line": 10
              }
            ],
            "value_transfers": [
              {
                "target": "cBridge",
                "type": "send",
                "line": 10
              }
            ],
            "condition_checks": [],
            "line_mapping": {
              "10": "External Call: cBridge.send(receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "uint64",
                "name": "nonce"
              },
              {
                "type": "uint32",
                "name": "maxSlippage"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaCBridgeNativePacked": {
            "name": "encode_startBridgeTokensViaCBridgeNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "nonce <= type(uint32",
                "line": 5
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(nonce <= type(uint32)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "uint64",
                "name": "nonce"
              },
              {
                "type": "uint32",
                "name": "maxSlippage"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaCBridgeNativePacked": {
            "name": "decode_startBridgeTokensViaCBridgeNativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 44,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "1": "require(_data.length >= 44,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "CBridgeFacet.CBridgeData memory"
              }
            ]
          },
          "encode_startBridgeTokensViaCBridgeERC20Packed": {
            "name": "encode_startBridgeTokensViaCBridgeERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 5
              },
              {
                "type": "require",
                "condition": "nonce <= type(uint32",
                "line": 9
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(minAmount <= type(uint128)",
              "9": "require(nonce <= type(uint32)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint64",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint64",
                "name": "nonce"
              },
              {
                "type": "uint32",
                "name": "maxSlippage"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaCBridgeERC20Packed": {
            "name": "decode_startBridgeTokensViaCBridgeERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "address(bytes20(_data[36:56]))",
                "line": 9
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 80, \"data passed is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "9": "State Change: sendingAssetId = address(bytes20(_data[36:56]))",
              "1": "require(_data.length >= 80, \"data passed is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "CBridgeFacet.CBridgeData memory"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "CBridgeFacetPacked": {
          "startBridgeTokensViaCBridgeNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaCBridgeNativeMin": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaCBridgeERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [
              {
                "from": "CBridgeFacetPacked",
                "to": "cBridge",
                "via": "startBridgeTokensViaCBridgeERC20Packed",
                "line": 13
              }
            ],
            "path_conditions": []
          },
          "startBridgeTokensViaCBridgeERC20Min": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [
              {
                "from": "CBridgeFacetPacked",
                "to": "cBridge",
                "via": "startBridgeTokensViaCBridgeERC20Min",
                "line": 10
              }
            ],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaCBridgeNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "nonce <= type(uint32",
                "line": 5,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaCBridgeNativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 44,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "encode_startBridgeTokensViaCBridgeERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "minAmount <= type(uint128",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "nonce <= type(uint32",
                "line": 9,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaCBridgeERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 80, \"data passed is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.602305"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.606216"
      },
      "final_report": {
        "file_id": "CBridgeFacetPacked.sol",
        "timestamp": "2025-03-11T07:05:50.606241",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CBridgeFacetPacked": {
            "functions": 8,
            "state_variables": 4,
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CBridgeFacetPacked.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.606255"
    },
    "CalldataVerificationFacet.sol": {
      "file_id": "CalldataVerificationFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CalldataVerificationFacet": {
            "name": "CalldataVerificationFacet",
            "inheritance": [],
            "functions": {
              "extractBridgeData": {
                "name": "extractBridgeData",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "ILiFi.BridgeData memory bridgeData"
                  }
                ],
                "modifiers": [],
                "code": "bridgeData = _extractBridgeData(data);\n    }"
              },
              "extractSwapData": {
                "name": "extractSwapData",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "LibSwap.SwapData[] memory swapData"
                  }
                ],
                "modifiers": [],
                "code": "swapData = _extractSwapData(data);\n    }"
              },
              "extractData": {
                "name": "extractData",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "ILiFi.BridgeData memory bridgeData"
                  },
                  {
                    "type": "LibSwap.SwapData[] memory swapData"
                  }
                ],
                "modifiers": [],
                "code": "bridgeData = _extractBridgeData(data);\n        if (bridgeData.hasSourceSwaps) {\n            swapData = _extractSwapData(data);\n        }\n    }"
              },
              "extractMainParameters": {
                "name": "extractMainParameters",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "string memory bridge"
                  },
                  {
                    "type": "address sendingAssetId"
                  },
                  {
                    "type": "address receiver"
                  },
                  {
                    "type": "uint256 amount"
                  },
                  {
                    "type": "uint256 destinationChainId"
                  },
                  {
                    "type": "bool hasSourceSwaps"
                  },
                  {
                    "type": "bool hasDestinationCall"
                  }
                ],
                "modifiers": [],
                "code": "ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        if (bridgeData.hasSourceSwaps) {\n            LibSwap.SwapData[] memory swapData = _extractSwapData(data);\n            sendingAssetId = swapData[0].sendingAssetId;\n            amount = swapData[0].fromAmount;\n        } else {\n            sendingAssetId = bridgeData.sendingAssetId;\n            amount = bridgeData.minAmount;\n        }\n\n        return (\n            bridgeData.bridge,\n            sendingAssetId,\n            bridgeData.receiver,\n            amount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        );\n    }"
              },
              "extractNonEVMAddress": {
                "name": "extractNonEVMAddress",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32 nonEVMAddress"
                  }
                ],
                "modifiers": [],
                "code": "bytes memory callData;\n\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            callData = abi.decode(data[4:], (bytes));\n        } else {\n            callData = data;\n        }\n\n        // Non-EVM address is always the first parameter of bridge specific data\n        if (_extractBridgeData(data).hasSourceSwaps) {\n            assembly {\n                let offset := mload(add(callData, 0x64)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        } else {\n            assembly {\n                let offset := mload(add(callData, 0x44)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        }\n    }"
              },
              "extractGenericSwapParameters": {
                "name": "extractGenericSwapParameters",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "address sendingAssetId"
                  },
                  {
                    "type": "uint256 amount"
                  },
                  {
                    "type": "address receiver"
                  },
                  {
                    "type": "address receivingAssetId"
                  },
                  {
                    "type": "uint256 receivingAmount"
                  }
                ],
                "modifiers": [],
                "code": "// valid callData for a genericSwap call should have at least 484 bytes:\n        // Function selector: 4 bytes\n        // _transactionId: 32 bytes\n        // _integrator: 64 bytes\n        // _referrer: 64 bytes\n        // _receiver: 32 bytes\n        // _minAmountOut: 32 bytes\n        // _swapData: 256 bytes\n        if (data.length <= 484) {\n            revert InvalidCallData();\n        }\n\n        LibSwap.SwapData[] memory swapData;\n        bytes memory callData;\n        bytes4 functionSelector = bytes4(data[:4]);\n\n        // check if this is a call via StandardizedCallFacet\n        if (\n            functionSelector == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // extract nested function selector and calldata\n            // will always start at position 68\n            functionSelector = bytes4(data[68:72]);\n            callData = data[68:];\n            // callData = abi.decode(data[4:], (bytes)); // this one is also valid, even though the calldata differs slightly (add. padding)\n        } else {\n            callData = data;\n        }\n\n        if (\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector\n        ) {\n            // single swap\n            swapData = new LibSwap.SwapData[](1);\n\n            // extract parameters from calldata\n            (, , , receiver, receivingAmount, swapData[0]) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (bytes32, string, string, address, uint256, LibSwap.SwapData)\n            );\n        } else {\n            // multi swap or GenericSwap V1 call\n            (, , , receiver, receivingAmount, swapData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (bytes32, string, string, address, uint256, LibSwap.SwapData[])\n            );\n        }\n\n        // extract missing return parameters from swapData\n        sendingAssetId = swapData[0].sendingAssetId;\n        amount = swapData[0].fromAmount;\n        receivingAssetId = swapData[swapData.length - 1].receivingAssetId;\n    }"
              },
              "validateCalldata": {
                "name": "validateCalldata",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  },
                  {
                    "type": "string",
                    "name": "bridge"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "bool",
                    "name": "hasSourceSwaps"
                  },
                  {
                    "type": "bool",
                    "name": "hasDestinationCall"
                  }
                ],
                "returns": [
                  {
                    "type": "bool isValid"
                  }
                ],
                "modifiers": [],
                "code": "ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        bytes32 bridgeNameHash = keccak256(abi.encodePacked(bridge));\n        return\n            // Check bridge\n            (bridgeNameHash == keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                bridgeNameHash) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall;\n    }"
              },
              "validateDestinationCalldata": {
                "name": "validateDestinationCalldata",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  },
                  {
                    "type": "bytes",
                    "name": "callTo"
                  },
                  {
                    "type": "bytes",
                    "name": "dstCalldata"
                  }
                ],
                "returns": [
                  {
                    "type": "bool isValid"
                  }
                ],
                "modifiers": [],
                "code": "bytes memory callData = data;\n\n        // Handle standardizedCall\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            callData = abi.decode(data[4:], (bytes));\n        }\n\n        bytes4 selector = abi.decode(callData, (bytes4));\n\n        // ---------------------------------------\n        // Case: Amarok\n        if (selector == AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n        if (\n            selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n\n        // ---------------------------------------\n        // Case: Stargate\n        if (selector == StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        if (\n            selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n\n        // ---------------------------------------\n        // Case: StargateV2\n\n        if (\n            selector == StargateFacetV2.startBridgeTokensViaStargate.selector\n        ) {\n            (, StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (ILiFi.BridgeData, StargateFacetV2.StargateData)\n                );\n\n            return\n                keccak256(dstCalldata) ==\n                keccak256(stargateDataV2.sendParams.composeMsg) &&\n                _compareBytesToBytes32CallTo(\n                    callTo,\n                    stargateDataV2.sendParams.to\n                );\n        }\n        if (\n            selector ==\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (\n                        ILiFi.BridgeData,\n                        LibSwap.SwapData[],\n                        StargateFacetV2.StargateData\n                    )\n                );\n\n            return\n                keccak256(dstCalldata) ==\n                keccak256(stargateDataV2.sendParams.composeMsg) &&\n                _compareBytesToBytes32CallTo(\n                    callTo,\n                    stargateDataV2.sendParams.to\n                );\n        }\n\n        // ---------------------------------------\n        // Case: Celer\n        if (\n            selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n        if (\n            selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256((celerIMData.callTo));\n        }\n        // Case: AcrossV3\n        if (selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n        if (\n            selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n\n        // ---------------------------------------\n        // Case: AcrossV3\n        if (selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n        if (\n            selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n\n        // All other cases\n        return false;\n    }"
              },
              "_extractBridgeData": {
                "name": "_extractBridgeData",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "ILiFi.BridgeData memory bridgeData"
                  }
                ],
                "modifiers": [],
                "code": "if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // StandardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            bridgeData = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            );\n            return bridgeData;\n        }\n        // normal call\n        bridgeData = abi.decode(data[4:], (ILiFi.BridgeData));\n    }"
              },
              "_extractSwapData": {
                "name": "_extractSwapData",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [
                  {
                    "type": "LibSwap.SwapData[] memory swapData"
                  }
                ],
                "modifiers": [],
                "code": "if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            (, swapData) = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[])\n            );\n            return swapData;\n        }\n        // normal call\n        (, swapData) = abi.decode(\n            data[4:],\n            (ILiFi.BridgeData, LibSwap.SwapData[])\n        );\n    }"
              },
              "_compareBytesToBytes32CallTo": {
                "name": "_compareBytesToBytes32CallTo",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callTo"
                  },
                  {
                    "type": "bytes32",
                    "name": "callToBytes32"
                  }
                ],
                "returns": [
                  {
                    "type": "bool"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            callTo.length >= 20,\n            \"Invalid callTo length; expected at least 20 bytes\"\n        );\n\n        // Convert bytes to address type from callTo\n        address callToAddress;\n        assembly {\n            callToAddress := mload(add(callTo, 32))\n        }\n\n        // Convert callToBytes32 to address type and compare them\n        address callToAddressFromBytes32 = address(\n            uint160(uint256(callToBytes32))\n        );\n\n        return callToAddress == callToAddressFromBytes32;\n    }"
              }
            },
            "state_variables": {
              "functionSelector": {
                "name": "functionSelector",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": "bytes4(data[:4])"
              },
              "bridgeNameHash": {
                "name": "bridgeNameHash",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "keccak256(abi.encodePacked(bridge))"
              },
              "selector": {
                "name": "selector",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": "abi.decode(callData, (bytes4))"
              },
              "false": {
                "name": "false",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "bridgeData": {
                "name": "bridgeData",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "swapData": {
                "name": "swapData",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "callToAddress": {
                "name": "callToAddress",
                "type": "return",
                "visibility": "internal",
                "initial_value": "= callToAddressFromBytes32"
              },
              "callToAddressFromBytes32": {
                "name": "callToAddressFromBytes32",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(\n            uint160(uint256(callToBytes32))\n        )"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { AmarokFacet } from \"./AmarokFacet.sol\";\nimport { AcrossFacetV3 } from \"./AcrossFacetV3.sol\";\nimport { StargateFacetV2 } from \"./StargateFacetV2.sol\";\nimport { StargateFacet } from \"./StargateFacet.sol\";\nimport { AcrossFacetV3 } from \"./AcrossFacetV3.sol\";\nimport { CelerIMFacetBase, CelerIM } from \"lifi/Helpers/CelerIMFacetBase.sol\";\nimport { StandardizedCallFacet } from \"lifi/Facets/StandardizedCallFacet.sol\";\nimport { LibBytes } from \"../Libraries/LibBytes.sol\";\nimport { GenericSwapFacetV3 } from \"lifi/Facets/GenericSwapFacetV3.sol\";\nimport { InvalidCallData } from \"../Errors/GenericErrors.sol\";\n\n/// @title CalldataVerificationFacet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for verifying calldata\n/// @custom:version 1.2.0\ncontract CalldataVerificationFacet {\n    using LibBytes for bytes;\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function extractBridgeData(\n        bytes calldata data\n    ) external pure returns (ILiFi.BridgeData memory bridgeData) {\n        bridgeData = _extractBridgeData(data);\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function extractSwapData(\n        bytes calldata data\n    ) external pure returns (LibSwap.SwapData[] memory swapData) {\n        swapData = _extractSwapData(data);\n    }\n\n    /// @notice Extracts the bridge data and swap data from the calldata\n    /// @param data The calldata to extract the bridge data and swap data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    /// @return swapData The swap data extracted from the calldata\n    function extractData(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            ILiFi.BridgeData memory bridgeData,\n            LibSwap.SwapData[] memory swapData\n        )\n    {\n        bridgeData = _extractBridgeData(data);\n        if (bridgeData.hasSourceSwaps) {\n            swapData = _extractSwapData(data);\n        }\n    }\n\n    /// @notice Extracts the main parameters from the calldata\n    /// @param data The calldata to extract the main parameters from\n    /// @return bridge The bridge extracted from the calldata\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return amount The min amountfrom the calldata\n    /// @return destinationChainId The destination chain id extracted from the calldata\n    /// @return hasSourceSwaps Whether the calldata has source swaps\n    /// @return hasDestinationCall Whether the calldata has a destination call\n    function extractMainParameters(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            string memory bridge,\n            address sendingAssetId,\n            address receiver,\n            uint256 amount,\n            uint256 destinationChainId,\n            bool hasSourceSwaps,\n            bool hasDestinationCall\n        )\n    {\n        ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        if (bridgeData.hasSourceSwaps) {\n            LibSwap.SwapData[] memory swapData = _extractSwapData(data);\n            sendingAssetId = swapData[0].sendingAssetId;\n            amount = swapData[0].fromAmount;\n        } else {\n            sendingAssetId = bridgeData.sendingAssetId;\n            amount = bridgeData.minAmount;\n        }\n\n        return (\n            bridgeData.bridge,\n            sendingAssetId,\n            bridgeData.receiver,\n            amount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        );\n    }\n\n    /// @notice Extracts the non-EVM address from the calldata\n    /// @param data The calldata to extract the non-EVM address from\n    /// @return nonEVMAddress The non-EVM address extracted from the calldata\n    function extractNonEVMAddress(\n        bytes calldata data\n    ) external pure returns (bytes32 nonEVMAddress) {\n        bytes memory callData;\n\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            callData = abi.decode(data[4:], (bytes));\n        } else {\n            callData = data;\n        }\n\n        // Non-EVM address is always the first parameter of bridge specific data\n        if (_extractBridgeData(data).hasSourceSwaps) {\n            assembly {\n                let offset := mload(add(callData, 0x64)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        } else {\n            assembly {\n                let offset := mload(add(callData, 0x44)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        }\n    }\n\n    /// @notice Extracts the generic swap parameters from the calldata\n    /// @param data The calldata to extract the generic swap parameters from\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return amount The amount extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return receivingAssetId The receiving asset id extracted from the calldata\n    /// @return receivingAmount The receiving amount extracted from the calldata\n    function extractGenericSwapParameters(\n        bytes calldata data\n    )\n        public\n        pure\n        returns (\n            address sendingAssetId,\n            uint256 amount,\n            address receiver,\n            address receivingAssetId,\n            uint256 receivingAmount\n        )\n    {\n        // valid callData for a genericSwap call should have at least 484 bytes:\n        // Function selector: 4 bytes\n        // _transactionId: 32 bytes\n        // _integrator: 64 bytes\n        // _referrer: 64 bytes\n        // _receiver: 32 bytes\n        // _minAmountOut: 32 bytes\n        // _swapData: 256 bytes\n        if (data.length <= 484) {\n            revert InvalidCallData();\n        }\n\n        LibSwap.SwapData[] memory swapData;\n        bytes memory callData;\n        bytes4 functionSelector = bytes4(data[:4]);\n\n        // check if this is a call via StandardizedCallFacet\n        if (\n            functionSelector == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // extract nested function selector and calldata\n            // will always start at position 68\n            functionSelector = bytes4(data[68:72]);\n            callData = data[68:];\n            // callData = abi.decode(data[4:], (bytes)); // this one is also valid, even though the calldata differs slightly (add. padding)\n        } else {\n            callData = data;\n        }\n\n        if (\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector\n        ) {\n            // single swap\n            swapData = new LibSwap.SwapData[](1);\n\n            // extract parameters from calldata\n            (, , , receiver, receivingAmount, swapData[0]) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (bytes32, string, string, address, uint256, LibSwap.SwapData)\n            );\n        } else {\n            // multi swap or GenericSwap V1 call\n            (, , , receiver, receivingAmount, swapData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (bytes32, string, string, address, uint256, LibSwap.SwapData[])\n            );\n        }\n\n        // extract missing return parameters from swapData\n        sendingAssetId = swapData[0].sendingAssetId;\n        amount = swapData[0].fromAmount;\n        receivingAssetId = swapData[swapData.length - 1].receivingAssetId;\n    }\n\n    /// @notice Validates the calldata\n    /// @param data The calldata to validate\n    /// @param bridge The bridge to validate or empty string to ignore\n    /// @param sendingAssetId The sending asset id to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param receiver The receiver to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param amount The amount to validate or type(uint256).max to ignore\n    /// @param destinationChainId The destination chain id to validate\n    ///        or type(uint256).max to ignore\n    /// @param hasSourceSwaps Whether the calldata has source swaps\n    /// @param hasDestinationCall Whether the calldata has a destination call\n    /// @return isValid Returns true if the calldata is valid\n    function validateCalldata(\n        bytes calldata data,\n        string calldata bridge,\n        address sendingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 destinationChainId,\n        bool hasSourceSwaps,\n        bool hasDestinationCall\n    ) external pure returns (bool isValid) {\n        ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        bytes32 bridgeNameHash = keccak256(abi.encodePacked(bridge));\n        return\n            // Check bridge\n            (bridgeNameHash == keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                bridgeNameHash) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall;\n    }\n\n    /// @notice Validates the destination calldata\n    /// @param data The calldata to validate\n    /// @param callTo The callTo address to validate\n    /// @param dstCalldata The destination calldata to validate\n    /// @return isValid Returns true if the calldata is valid\n    function validateDestinationCalldata(\n        bytes calldata data,\n        bytes calldata callTo,\n        bytes calldata dstCalldata\n    ) external pure returns (bool isValid) {\n        bytes memory callData = data;\n\n        // Handle standardizedCall\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            callData = abi.decode(data[4:], (bytes));\n        }\n\n        bytes4 selector = abi.decode(callData, (bytes4));\n\n        // ---------------------------------------\n        // Case: Amarok\n        if (selector == AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n        if (\n            selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n\n        // ---------------------------------------\n        // Case: Stargate\n        if (selector == StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        if (\n            selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n\n        // ---------------------------------------\n        // Case: StargateV2\n\n        if (\n            selector == StargateFacetV2.startBridgeTokensViaStargate.selector\n        ) {\n            (, StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (ILiFi.BridgeData, StargateFacetV2.StargateData)\n                );\n\n            return\n                keccak256(dstCalldata) ==\n                keccak256(stargateDataV2.sendParams.composeMsg) &&\n                _compareBytesToBytes32CallTo(\n                    callTo,\n                    stargateDataV2.sendParams.to\n                );\n        }\n        if (\n            selector ==\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (\n                        ILiFi.BridgeData,\n                        LibSwap.SwapData[],\n                        StargateFacetV2.StargateData\n                    )\n                );\n\n            return\n                keccak256(dstCalldata) ==\n                keccak256(stargateDataV2.sendParams.composeMsg) &&\n                _compareBytesToBytes32CallTo(\n                    callTo,\n                    stargateDataV2.sendParams.to\n                );\n        }\n\n        // ---------------------------------------\n        // Case: Celer\n        if (\n            selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n        if (\n            selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256((celerIMData.callTo));\n        }\n        // Case: AcrossV3\n        if (selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n        if (\n            selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n\n        // ---------------------------------------\n        // Case: AcrossV3\n        if (selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n        if (\n            selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(acrossV3Data.message) &&\n                keccak256(callTo) ==\n                keccak256(abi.encode(acrossV3Data.receiverAddress));\n        }\n\n        // All other cases\n        return false;\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function _extractBridgeData(\n        bytes calldata data\n    ) internal pure returns (ILiFi.BridgeData memory bridgeData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // StandardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            bridgeData = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            );\n            return bridgeData;\n        }\n        // normal call\n        bridgeData = abi.decode(data[4:], (ILiFi.BridgeData));\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function _extractSwapData(\n        bytes calldata data\n    ) internal pure returns (LibSwap.SwapData[] memory swapData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            (, swapData) = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[])\n            );\n            return swapData;\n        }\n        // normal call\n        (, swapData) = abi.decode(\n            data[4:],\n            (ILiFi.BridgeData, LibSwap.SwapData[])\n        );\n    }\n\n    function _compareBytesToBytes32CallTo(\n        bytes memory callTo,\n        bytes32 callToBytes32\n    ) private pure returns (bool) {\n        require(\n            callTo.length >= 20,\n            \"Invalid callTo length; expected at least 20 bytes\"\n        );\n\n        // Convert bytes to address type from callTo\n        address callToAddress;\n        assembly {\n            callToAddress := mload(add(callTo, 32))\n        }\n\n        // Convert callToBytes32 to address type and compare them\n        address callToAddressFromBytes32 = address(\n            uint160(uint256(callToBytes32))\n        );\n\n        return callToAddress == callToAddressFromBytes32;\n    }\n}\n"
      },
      "call_graph": {
        "CalldataVerificationFacet": {
          "extractBridgeData": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractBridgeData"
            }
          ],
          "extractSwapData": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractSwapData"
            }
          ],
          "extractData": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractBridgeData"
            },
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractSwapData"
            }
          ],
          "extractMainParameters": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractBridgeData"
            },
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractSwapData"
            }
          ],
          "extractNonEVMAddress": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractBridgeData"
            }
          ],
          "extractGenericSwapParameters": [],
          "validateCalldata": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_extractBridgeData"
            }
          ],
          "validateDestinationCalldata": [
            {
              "contract": "CalldataVerificationFacet",
              "function": "_compareBytesToBytes32CallTo"
            }
          ],
          "_extractBridgeData": [],
          "_extractSwapData": [],
          "_compareBytesToBytes32CallTo": []
        }
      },
      "flow_data": {
        "CalldataVerificationFacet": {
          "extractBridgeData": {
            "name": "extractBridgeData",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "_extractBridgeData(data)",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: bridgeData = _extractBridgeData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "ILiFi.BridgeData memory bridgeData"
              }
            ]
          },
          "extractSwapData": {
            "name": "extractSwapData",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "swapData",
                "type": "return",
                "value": "_extractSwapData(data)",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: swapData = _extractSwapData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "LibSwap.SwapData[] memory swapData"
              }
            ]
          },
          "extractData": {
            "name": "extractData",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "bridgeData.hasSourceSwaps",
                "line": 2
              }
            ],
            "state_changes": [
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "_extractBridgeData(data)",
                "line": 1
              },
              {
                "variable": "swapData",
                "type": "return",
                "value": "_extractSwapData(data)",
                "line": 3
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (bridgeData.hasSourceSwaps)",
              "1": "State Change: bridgeData = _extractBridgeData(data)",
              "3": "State Change: swapData = _extractSwapData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "ILiFi.BridgeData memory bridgeData"
              },
              {
                "type": "LibSwap.SwapData[] memory swapData"
              }
            ]
          },
          "extractMainParameters": {
            "name": "extractMainParameters",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "bridgeData.hasSourceSwaps",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "_extractBridgeData(data)",
                "line": 1
              },
              {
                "variable": "swapData",
                "type": "return",
                "value": "_extractSwapData(data)",
                "line": 4
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (bridgeData.hasSourceSwaps)",
              "1": "State Change: bridgeData = _extractBridgeData(data)",
              "4": "State Change: swapData = _extractSwapData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "string memory bridge"
              },
              {
                "type": "address sendingAssetId"
              },
              {
                "type": "address receiver"
              },
              {
                "type": "uint256 amount"
              },
              {
                "type": "uint256 destinationChainId"
              },
              {
                "type": "bool hasSourceSwaps"
              },
              {
                "type": "bool hasDestinationCall"
              }
            ]
          },
          "extractNonEVMAddress": {
            "name": "extractNonEVMAddress",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "bytes4(data[:4]",
                "line": 3
              },
              {
                "type": "if",
                "condition": "_extractBridgeData(data",
                "line": 13
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (bytes4(data[:4])",
              "13": "if (_extractBridgeData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "bytes32 nonEVMAddress"
              }
            ]
          },
          "extractGenericSwapParameters": {
            "name": "extractGenericSwapParameters",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "data.length <= 484",
                "line": 9
              },
              {
                "type": "if",
                "condition": "functionSelector == StandardizedCallFacet.standardizedCall.selector",
                "line": 18
              },
              {
                "type": "if",
                "condition": "functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector",
                "line": 30
              }
            ],
            "state_changes": [
              {
                "variable": "functionSelector",
                "type": "bytes4",
                "value": "bytes4(data[:4])",
                "line": 15
              },
              {
                "variable": "functionSelector",
                "type": "bytes4",
                "value": "= StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // extract nested function selector and calldata\n            // will always start at position 68\n            functionSelector = bytes4(data[68:72])",
                "line": 19
              },
              {
                "variable": "functionSelector",
                "type": "bytes4",
                "value": "=\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector\n        ) {\n            // single swap\n            swapData = new LibSwap.SwapData[](1)",
                "line": 31
              },
              {
                "variable": "swapData",
                "type": "return",
                "value": "new LibSwap.SwapData[](1)",
                "line": 39
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "9": "if (data.length <= 484)",
              "18": "if (functionSelector == StandardizedCallFacet.standardizedCall.selector)",
              "30": "if (functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector)",
              "15": "State Change: functionSelector = bytes4(data[:4])",
              "19": "State Change: functionSelector = = StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // extract nested function selector and calldata\n            // will always start at position 68\n            functionSelector = bytes4(data[68:72])",
              "31": "State Change: functionSelector = =\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToERC20.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3ERC20ToNative.selector ||\n            functionSelector ==\n            GenericSwapFacetV3.swapTokensSingleV3NativeToERC20.selector\n        ) {\n            // single swap\n            swapData = new LibSwap.SwapData[](1)",
              "39": "State Change: swapData = new LibSwap.SwapData[](1)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "address sendingAssetId"
              },
              {
                "type": "uint256 amount"
              },
              {
                "type": "address receiver"
              },
              {
                "type": "address receivingAssetId"
              },
              {
                "type": "uint256 receivingAmount"
              }
            ]
          },
          "validateCalldata": {
            "name": "validateCalldata",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "bridgeNameHash",
                "type": "bytes32",
                "value": "keccak256(abi.encodePacked(bridge))",
                "line": 3
              },
              {
                "variable": "bridgeNameHash",
                "type": "bytes32",
                "value": "= keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                bridgeNameHash) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall",
                "line": 6
              },
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "_extractBridgeData(data)",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "State Change: bridgeNameHash = keccak256(abi.encodePacked(bridge))",
              "6": "State Change: bridgeNameHash = = keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                bridgeNameHash) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall",
              "1": "State Change: bridgeData = _extractBridgeData(data)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              },
              {
                "type": "string",
                "name": "bridge"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "bool",
                "name": "hasSourceSwaps"
              },
              {
                "type": "bool",
                "name": "hasDestinationCall"
              }
            ],
            "returns": [
              {
                "type": "bool isValid"
              }
            ]
          },
          "validateDestinationCalldata": {
            "name": "validateDestinationCalldata",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "bytes4(data[:4]",
                "line": 4
              },
              {
                "type": "if",
                "condition": "selector == AmarokFacet.startBridgeTokensViaAmarok.selector",
                "line": 14
              },
              {
                "type": "if",
                "condition": "selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector",
                "line": 24
              },
              {
                "type": "if",
                "condition": "selector == StargateFacet.startBridgeTokensViaStargate.selector",
                "line": 38
              },
              {
                "type": "if",
                "condition": "selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector",
                "line": 47
              },
              {
                "type": "if",
                "condition": "selector == StargateFacetV2.startBridgeTokensViaStargate.selector",
                "line": 67
              },
              {
                "type": "if",
                "condition": "selector ==\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector",
                "line": 84
              },
              {
                "type": "if",
                "condition": "selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector",
                "line": 109
              },
              {
                "type": "if",
                "condition": "selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector",
                "line": 120
              },
              {
                "type": "if",
                "condition": "selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector",
                "line": 133
              },
              {
                "type": "if",
                "condition": "selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector",
                "line": 144
              },
              {
                "type": "if",
                "condition": "selector == AcrossFacetV3.startBridgeTokensViaAcrossV3.selector",
                "line": 164
              },
              {
                "type": "if",
                "condition": "selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector",
                "line": 175
              }
            ],
            "state_changes": [
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "abi.decode(callData, (bytes4))",
                "line": 10
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            )",
                "line": 14
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            )",
                "line": 25
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            )",
                "line": 38
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "=\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            )",
                "line": 48
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= StargateFacetV2.startBridgeTokensViaStargate.selector\n        ) {\n            (, StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (ILiFi.BridgeData, StargateFacetV2.StargateData)\n                )",
                "line": 68
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "=\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (\n                        ILiFi.BridgeData,\n                        LibSwap.SwapData[],\n                        StargateFacetV2.StargateData\n                    )\n                )",
                "line": 85
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            )",
                "line": 110
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "=\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            )",
                "line": 121
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            )",
                "line": 133
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "=\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            )",
                "line": 145
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "= AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            )",
                "line": 164
              },
              {
                "variable": "selector",
                "type": "bytes4",
                "value": "=\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            )",
                "line": 176
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (bytes4(data[:4])",
              "14": "State Change: selector = = AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            )",
              "24": "if (selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector)",
              "38": "State Change: selector = = StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            )",
              "47": "if (selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector)",
              "67": "if (selector == StargateFacetV2.startBridgeTokensViaStargate.selector)",
              "84": "if (selector ==\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector)",
              "109": "if (selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector)",
              "120": "if (selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector)",
              "133": "State Change: selector = = AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            )",
              "144": "if (selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector)",
              "164": "State Change: selector = = AcrossFacetV3.startBridgeTokensViaAcrossV3.selector) {\n            (, AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AcrossFacetV3.AcrossV3Data)\n            )",
              "175": "if (selector ==\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector)",
              "10": "State Change: selector = abi.decode(callData, (bytes4))",
              "25": "State Change: selector = = AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            )",
              "48": "State Change: selector = =\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            )",
              "68": "State Change: selector = = StargateFacetV2.startBridgeTokensViaStargate.selector\n        ) {\n            (, StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (ILiFi.BridgeData, StargateFacetV2.StargateData)\n                )",
              "85": "State Change: selector = =\n            StargateFacetV2.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacetV2.StargateData memory stargateDataV2) = abi\n                .decode(\n                    callData.slice(4, callData.length - 4),\n                    (\n                        ILiFi.BridgeData,\n                        LibSwap.SwapData[],\n                        StargateFacetV2.StargateData\n                    )\n                )",
              "110": "State Change: selector = = CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            )",
              "121": "State Change: selector = =\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            )",
              "145": "State Change: selector = =\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            )",
              "176": "State Change: selector = =\n            AcrossFacetV3.swapAndStartBridgeTokensViaAcrossV3.selector\n        ) {\n            (, , AcrossFacetV3.AcrossV3Data memory acrossV3Data) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    AcrossFacetV3.AcrossV3Data\n                )\n            )"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              },
              {
                "type": "bytes",
                "name": "callTo"
              },
              {
                "type": "bytes",
                "name": "dstCalldata"
              }
            ],
            "returns": [
              {
                "type": "bool isValid"
              }
            ]
          },
          "_extractBridgeData": {
            "name": "_extractBridgeData",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "bytes4(data[:4]",
                "line": 1
              }
            ],
            "state_changes": [
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                "line": 6
              },
              {
                "variable": "bridgeData",
                "type": "return",
                "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                "line": 13
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (bytes4(data[:4])",
              "6": "State Change: bridgeData = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
              "13": "State Change: bridgeData = abi.decode(data[4:], (ILiFi.BridgeData))"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "ILiFi.BridgeData memory bridgeData"
              }
            ]
          },
          "_extractSwapData": {
            "name": "_extractSwapData",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "bytes4(data[:4]",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (bytes4(data[:4])"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": [
              {
                "type": "LibSwap.SwapData[] memory swapData"
              }
            ]
          },
          "_compareBytesToBytes32CallTo": {
            "name": "_compareBytesToBytes32CallTo",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "callToAddress",
                "type": "return",
                "value": "= callToAddressFromBytes32",
                "line": 17
              },
              {
                "variable": "callToAddressFromBytes32",
                "type": "address",
                "value": "address(\n            uint160(uint256(callToBytes32))\n        )",
                "line": 13
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "callTo.length >= 20,\n            \"Invalid callTo length; expected at least 20 bytes\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "17": "State Change: callToAddress = = callToAddressFromBytes32",
              "13": "State Change: callToAddressFromBytes32 = address(\n            uint160(uint256(callToBytes32))\n        )",
              "1": "require(callTo.length >= 20,\n            \"Invalid callTo length; expected at least 20 bytes\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "callTo"
              },
              {
                "type": "bytes32",
                "name": "callToBytes32"
              }
            ],
            "returns": [
              {
                "type": "bool"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "CalldataVerificationFacet": {
          "extractBridgeData": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractBridgeData",
                "state_changes": [
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                    "line": 6
                  },
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_extractBridgeData": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "extractSwapData": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractSwapData",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_extractSwapData": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "extractData": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractBridgeData",
                "state_changes": [
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                    "line": 6
                  },
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractSwapData",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "extractMainParameters": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractBridgeData",
                "state_changes": [
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                    "line": 6
                  },
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractSwapData",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "extractNonEVMAddress": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractBridgeData",
                "state_changes": [
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                    "line": 6
                  },
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "extractGenericSwapParameters": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "validateCalldata": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_extractBridgeData",
                "state_changes": [
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            )",
                    "line": 6
                  },
                  {
                    "variable": "bridgeData",
                    "type": "return",
                    "value": "abi.decode(data[4:], (ILiFi.BridgeData))",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "validateDestinationCalldata": {
            "calls": [
              {
                "contract": "CalldataVerificationFacet",
                "function": "_compareBytesToBytes32CallTo",
                "state_changes": [
                  {
                    "variable": "callToAddress",
                    "type": "return",
                    "value": "= callToAddressFromBytes32",
                    "line": 17
                  },
                  {
                    "variable": "callToAddressFromBytes32",
                    "type": "address",
                    "value": "address(\n            uint160(uint256(callToBytes32))\n        )",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_compareBytesToBytes32CallTo": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "callTo.length >= 20,\n            \"Invalid callTo length; expected at least 20 bytes\"",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.648372"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.654439"
      },
      "final_report": {
        "file_id": "CalldataVerificationFacet.sol",
        "timestamp": "2025-03-11T07:05:50.654463",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CalldataVerificationFacet": {
            "functions": 11,
            "state_variables": 8,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CalldataVerificationFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.654476"
    },
    "CelerCircleBridgeFacet.sol": {
      "file_id": "CelerCircleBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CelerCircleBridgeFacet": {
            "name": "CelerCircleBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "BridgeData",
                    "name": "_bridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "require(\n            _bridgeData.destinationChainId <= type(uint64).max,\n            \"_bridgeData.destinationChainId passed is too big to fit in uint64\"\n        );\n\n        // give max approval for token to CelerCircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(circleBridgeProxy),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        circleBridgeProxy.depositForBurn(\n            _bridgeData.minAmount,\n            uint64(_bridgeData.destinationChainId),\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICircleBridgeProxy } from \"../Interfaces/ICircleBridgeProxy.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title CelerCircleBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CelerCircleBridge\n/// @custom:version 1.0.1\ncontract CelerCircleBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The address of the CircleBridgeProxy on the current chain.\n    ICircleBridgeProxy private immutable circleBridgeProxy;\n\n    /// @notice The USDC address on the current chain.\n    address private immutable usdc;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _circleBridgeProxy The address of the CircleBridgeProxy on the current chain.\n    /// @param _usdc The address of USDC on the current chain.\n    constructor(ICircleBridgeProxy _circleBridgeProxy, address _usdc) {\n        circleBridgeProxy = _circleBridgeProxy;\n        usdc = _usdc;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CelerCircleBridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaCelerCircleBridge(\n        BridgeData calldata _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        LibAsset.depositAsset(usdc, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaCelerCircleBridge(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    function _startBridge(BridgeData memory _bridgeData) private {\n        require(\n            _bridgeData.destinationChainId <= type(uint64).max,\n            \"_bridgeData.destinationChainId passed is too big to fit in uint64\"\n        );\n\n        // give max approval for token to CelerCircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(circleBridgeProxy),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        circleBridgeProxy.depositForBurn(\n            _bridgeData.minAmount,\n            uint64(_bridgeData.destinationChainId),\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "CelerCircleBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "CelerCircleBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_bridgeData.destinationChainId <= type(uint64",
                "line": 1
              }
            ],
            "line_mapping": {
              "1": "require(_bridgeData.destinationChainId <= type(uint64)"
            },
            "parameters": [
              {
                "type": "BridgeData",
                "name": "_bridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "CelerCircleBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_bridgeData.destinationChainId <= type(uint64",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.650198"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.656437"
      },
      "final_report": {
        "file_id": "CelerCircleBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.656461",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CelerCircleBridgeFacet": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CelerCircleBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.656474"
    },
    "CelerIMFacetMutable.sol": {
      "file_id": "CelerIMFacetMutable.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CelerIMFacetMutable": {
            "name": "CelerIMFacetMutable",
            "inheritance": [
              "CelerIMFacetBase"
            ],
            "functions": {},
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { CelerIMFacetBase, IMessageBus, MsgDataTypes, IERC20, CelerIM } from \"../Helpers/CelerIMFacetBase.sol\";\n\n/// @title CelerIMFacetMutable\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice This contract is exclusively used for mutable diamond contracts\n/// @custom:version 2.0.0\ncontract CelerIMFacetMutable is CelerIMFacetBase {\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) CelerIMFacetBase(_messageBus, _relayerOwner, _diamondAddress, _cfUSDC) {}\n}\n"
      },
      "call_graph": {
        "CelerIMFacetMutable": {}
      },
      "flow_data": {
        "CelerIMFacetMutable": {}
      },
      "flow_paths": {
        "CelerIMFacetMutable": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.603535"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.606347"
      },
      "final_report": {
        "file_id": "CelerIMFacetMutable.sol",
        "timestamp": "2025-03-11T07:05:50.606362",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CelerIMFacetMutable": {
            "functions": 0,
            "state_variables": 0,
            "inheritance": [
              "CelerIMFacetBase"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CelerIMFacetMutable.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.606372"
    },
    "DeBridgeDlnFacet.sol": {
      "file_id": "DeBridgeDlnFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "DeBridgeDlnFacet": {
            "name": "DeBridgeDlnFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "initDeBridgeDln": {
                "name": "initDeBridgeDln",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ChainIdConfig[]",
                    "name": "chainIdConfigs"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (chainIdConfigs.length == 0) revert InvalidConfig();\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.deBridgeChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .deBridgeChainId;\n        }\n\n        sm.initialized = true;\n        emit DeBridgeInitialized(chainIdConfigs);\n    }"
              },
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "DeBridgeDlnData",
                    "name": "_deBridgeData"
                  },
                  {
                    "type": "uint256",
                    "name": "_fee"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "IDlnSource.OrderCreation memory orderCreation = IDlnSource\n            .OrderCreation({\n                giveTokenAddress: _bridgeData.sendingAssetId,\n                giveAmount: _bridgeData.minAmount,\n                takeTokenAddress: _deBridgeData.receivingAssetId,\n                takeAmount: _deBridgeData.minAmountOut,\n                takeChainId: getDeBridgeChainId(\n                    _bridgeData.destinationChainId\n                ),\n                receiverDst: _deBridgeData.receiver,\n                givePatchAuthoritySrc: msg.sender,\n                orderAuthorityAddressDst: _deBridgeData.orderAuthorityDst,\n                allowedTakerDst: \"\",\n                externalCall: \"\",\n                allowedCancelBeneficiarySrc: abi.encodePacked(msg.sender)\n            });\n\n        bytes32 orderId;\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Give the DLN Source approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(dlnSource),\n                _bridgeData.minAmount\n            );\n\n            orderId = dlnSource.createOrder{ value: _fee }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            );\n        } else {\n            orderCreation.giveAmount = orderCreation.giveAmount - _fee;\n            orderId = dlnSource.createOrder{ value: _bridgeData.minAmount }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            );\n        }\n\n        emit DlnOrderCreated(orderId);\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _deBridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "setDeBridgeChainId": {
                "name": "setDeBridgeChainId",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "_chainId"
                  },
                  {
                    "type": "uint256",
                    "name": "_deBridgeChainId"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.deBridgeChainId[_chainId] = _deBridgeChainId;\n        emit DeBridgeChainIdSet(_chainId, _deBridgeChainId);\n    }"
              },
              "getDeBridgeChainId": {
                "name": "getDeBridgeChainId",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "_chainId"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "Storage storage sm = getStorage();\n        uint256 chainId = sm.deBridgeChainId[_chainId];\n        if (chainId == 0) revert UnknownDeBridgeChain();\n        return chainId;\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "receiver": {
                "name": "receiver",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "orderAuthorityDst": {
                "name": "orderAuthorityDst",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "minAmountOut": {
                "name": "minAmountOut",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "initialized": {
                "name": "initialized",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "chainId": {
                "name": "chainId",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "deBridgeChainId": {
                "name": "deBridgeChainId",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "fee": {
                "name": "fee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "dlnSource.globalFixedNativeFee()"
              },
              "assetId": {
                "name": "assetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_bridgeData.sendingAssetId"
              },
              "orderId": {
                "name": "orderId",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { IDlnSource } from \"../Interfaces/IDlnSource.sol\";\nimport { NotInitialized } from \"../Errors/GenericErrors.sol\";\n\n/// @title DeBridgeDLN Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through DeBridge DLN\n/// @custom:version 1.0.0\ncontract DeBridgeDlnFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.debridgedln\");\n    uint32 internal constant REFERRAL_CODE = 30729;\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n    IDlnSource public immutable dlnSource;\n\n    /// Types ///\n\n    /// @param receivingAssetId The address of the asset to receive\n    /// @param receiver The address of the receiver\n    /// @param minAmountOut The minimum amount to receive on the destination chain\n    struct DeBridgeDlnData {\n        bytes receivingAssetId;\n        bytes receiver;\n        bytes orderAuthorityDst;\n        uint256 minAmountOut;\n    }\n\n    struct Storage {\n        mapping(uint256 => uint256) deBridgeChainId;\n        bool initialized;\n    }\n\n    struct ChainIdConfig {\n        uint256 chainId;\n        uint256 deBridgeChainId;\n    }\n\n    /// Errors ///\n\n    error UnknownDeBridgeChain();\n    error EmptyNonEVMAddress();\n    error InvalidConfig();\n\n    /// Events ///\n\n    event DeBridgeInitialized(ChainIdConfig[] chainIdConfigs);\n\n    event DlnOrderCreated(bytes32 indexed orderId);\n\n    event DeBridgeChainIdSet(uint256 indexed chainId, uint256 deBridgeChainId);\n\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed destinationChainId,\n        bytes receiver\n    );\n\n    /// Modifiers ///\n\n    modifier onlyValidReceiverAddress(DeBridgeDlnData calldata _deBridgeData) {\n        // Ensure nonEVMAddress is not empty\n        if (_deBridgeData.receiver.length == 0) {\n            revert EmptyNonEVMAddress();\n        }\n        _;\n    }\n\n    /// Constructor ///\n\n    /// @notice Constructor for the contract.\n    /// @param _dlnSource The address of the DLN order creation contract\n    constructor(IDlnSource _dlnSource) {\n        dlnSource = _dlnSource;\n    }\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the DeBridgeDln Facet\n    /// @param chainIdConfigs Chain Id configuration data\n    function initDeBridgeDln(\n        ChainIdConfig[] calldata chainIdConfigs\n    ) external {\n        if (chainIdConfigs.length == 0) revert InvalidConfig();\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.deBridgeChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .deBridgeChainId;\n        }\n\n        sm.initialized = true;\n        emit DeBridgeInitialized(chainIdConfigs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _deBridgeData Data specific to DeBridgeDLN\n    function startBridgeTokensViaDeBridgeDln(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeDlnData calldata _deBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        onlyValidReceiverAddress(_deBridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(\n            _bridgeData,\n            _deBridgeData,\n            dlnSource.globalFixedNativeFee()\n        );\n    }\n\n    /// @notice Performs a swap before bridging via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _deBridgeData Data specific to DeBridgeDLN\n    function swapAndStartBridgeTokensViaDeBridgeDln(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        DeBridgeDlnData calldata _deBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyValidReceiverAddress(_deBridgeData)\n    {\n        uint256 fee = dlnSource.globalFixedNativeFee();\n        address assetId = _bridgeData.sendingAssetId;\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            LibAsset.isNativeAsset(assetId) ? 0 : fee\n        );\n        _startBridge(_bridgeData, _deBridgeData, fee);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _deBridgeData Data specific to DeBridgeDLN\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeDlnData calldata _deBridgeData,\n        uint256 _fee\n    ) internal {\n        IDlnSource.OrderCreation memory orderCreation = IDlnSource\n            .OrderCreation({\n                giveTokenAddress: _bridgeData.sendingAssetId,\n                giveAmount: _bridgeData.minAmount,\n                takeTokenAddress: _deBridgeData.receivingAssetId,\n                takeAmount: _deBridgeData.minAmountOut,\n                takeChainId: getDeBridgeChainId(\n                    _bridgeData.destinationChainId\n                ),\n                receiverDst: _deBridgeData.receiver,\n                givePatchAuthoritySrc: msg.sender,\n                orderAuthorityAddressDst: _deBridgeData.orderAuthorityDst,\n                allowedTakerDst: \"\",\n                externalCall: \"\",\n                allowedCancelBeneficiarySrc: abi.encodePacked(msg.sender)\n            });\n\n        bytes32 orderId;\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Give the DLN Source approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(dlnSource),\n                _bridgeData.minAmount\n            );\n\n            orderId = dlnSource.createOrder{ value: _fee }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            );\n        } else {\n            orderCreation.giveAmount = orderCreation.giveAmount - _fee;\n            orderId = dlnSource.createOrder{ value: _bridgeData.minAmount }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            );\n        }\n\n        emit DlnOrderCreated(orderId);\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _deBridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// Mappings management ///\n\n    /// @notice Sets the DeBridge chain ID for a given chain ID\n    /// @param _chainId uint256 of the chain ID\n    /// @param _deBridgeChainId uint256 of the DeBridge chain ID\n    /// @dev This is used to map a chain ID to its DeBridge chain ID\n    function setDeBridgeChainId(\n        uint256 _chainId,\n        uint256 _deBridgeChainId\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.deBridgeChainId[_chainId] = _deBridgeChainId;\n        emit DeBridgeChainIdSet(_chainId, _deBridgeChainId);\n    }\n\n    /// @notice Gets the DeBridge chain ID for a given chain ID\n    /// @param _chainId uint256 of the chain ID\n    /// @return uint256 of the DeBridge chain ID\n    function getDeBridgeChainId(\n        uint256 _chainId\n    ) public view returns (uint256) {\n        Storage storage sm = getStorage();\n        uint256 chainId = sm.deBridgeChainId[_chainId];\n        if (chainId == 0) revert UnknownDeBridgeChain();\n        return chainId;\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "DeBridgeDlnFacet": {
          "initDeBridgeDln": [
            {
              "contract": "DeBridgeDlnFacet",
              "function": "getStorage"
            }
          ],
          "_startBridge": [
            {
              "contract": "DeBridgeDlnFacet",
              "function": "getDeBridgeChainId"
            }
          ],
          "setDeBridgeChainId": [
            {
              "contract": "DeBridgeDlnFacet",
              "function": "getStorage"
            }
          ],
          "getDeBridgeChainId": [
            {
              "contract": "DeBridgeDlnFacet",
              "function": "getStorage"
            }
          ],
          "getStorage": []
        }
      },
      "flow_data": {
        "DeBridgeDlnFacet": {
          "initDeBridgeDln": {
            "name": "initDeBridgeDln",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "chainIdConfigs.length == 0",
                "line": 1
              },
              {
                "type": "for",
                "condition": "uint256 i = 0; i < chainIdConfigs.length; i++",
                "line": 6
              }
            ],
            "state_changes": [
              {
                "variable": "initialized",
                "type": "bool",
                "value": "true",
                "line": 11
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (chainIdConfigs.length == 0)",
              "6": "for (uint256 i = 0; i < chainIdConfigs.length; i++)",
              "11": "State Change: initialized = true"
            },
            "parameters": [
              {
                "type": "ChainIdConfig[]",
                "name": "chainIdConfigs"
              }
            ],
            "returns": []
          },
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "!LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 19
              },
              {
                "type": "if",
                "condition": "_bridgeData.receiver == NON_EVM_ADDRESS",
                "line": 45
              }
            ],
            "state_changes": [
              {
                "variable": "receiver",
                "type": "bytes",
                "value": "= NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _deBridgeData.receiver\n            )",
                "line": 45
              },
              {
                "variable": "orderId",
                "type": "bytes32",
                "value": "dlnSource.createOrder{ value: _fee }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            )",
                "line": 27
              },
              {
                "variable": "orderId",
                "type": "bytes32",
                "value": "dlnSource.createOrder{ value: _bridgeData.minAmount }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            )",
                "line": 35
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "19": "if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "45": "State Change: receiver = = NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _deBridgeData.receiver\n            )",
              "27": "State Change: orderId = dlnSource.createOrder{ value: _fee }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            )",
              "35": "State Change: orderId = dlnSource.createOrder{ value: _bridgeData.minAmount }(\n                orderCreation,\n                \"\",\n                REFERRAL_CODE,\n                \"\"\n            )"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "DeBridgeDlnData",
                "name": "_deBridgeData"
              },
              {
                "type": "uint256",
                "name": "_fee"
              }
            ],
            "returns": []
          },
          "setDeBridgeChainId": {
            "name": "setDeBridgeChainId",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "!sm.initialized",
                "line": 4
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (!sm.initialized)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "_chainId"
              },
              {
                "type": "uint256",
                "name": "_deBridgeChainId"
              }
            ],
            "returns": []
          },
          "getDeBridgeChainId": {
            "name": "getDeBridgeChainId",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "chainId == 0",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "chainId",
                "type": "return",
                "value": "sm.deBridgeChainId[_chainId]",
                "line": 2
              },
              {
                "variable": "chainId",
                "type": "return",
                "value": "= 0) revert UnknownDeBridgeChain()",
                "line": 3
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "State Change: chainId = = 0) revert UnknownDeBridgeChain()",
              "2": "State Change: chainId = sm.deBridgeChainId[_chainId]"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "_chainId"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "DeBridgeDlnFacet": {
          "initDeBridgeDln": {
            "calls": [
              {
                "contract": "DeBridgeDlnFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_startBridge": {
            "calls": [
              {
                "contract": "DeBridgeDlnFacet",
                "function": "getDeBridgeChainId",
                "state_changes": [
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "sm.deBridgeChainId[_chainId]",
                    "line": 2
                  },
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "= 0) revert UnknownDeBridgeChain()",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getDeBridgeChainId": {
            "calls": [
              {
                "contract": "DeBridgeDlnFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "setDeBridgeChainId": {
            "calls": [
              {
                "contract": "DeBridgeDlnFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.655309"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.672753"
      },
      "final_report": {
        "file_id": "DeBridgeDlnFacet.sol",
        "timestamp": "2025-03-11T07:05:50.672779",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "DeBridgeDlnFacet": {
            "functions": 5,
            "state_variables": 11,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of DeBridgeDlnFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.672793"
    },
    "DexManagerFacet.sol": {
      "file_id": "DexManagerFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "DexManagerFacet": {
            "name": "DexManagerFacet",
            "inheritance": [],
            "functions": {
              "addDex": {
                "name": "addDex",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_dex"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        LibAllowList.addAllowedContract(_dex);\n\n        emit DexAdded(_dex);\n    }"
              },
              "batchAddDex": {
                "name": "batchAddDex",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address[]",
                    "name": "_dexs"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n\n        for (uint256 i = 0; i < length; ) {\n            address dex = _dexs[i];\n            if (dex == address(this)) {\n                revert CannotAuthoriseSelf();\n            }\n            if (LibAllowList.contractIsAllowed(dex)) continue;\n            LibAllowList.addAllowedContract(dex);\n            emit DexAdded(dex);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "removeDex": {
                "name": "removeDex",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_dex"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        LibAllowList.removeAllowedContract(_dex);\n        emit DexRemoved(_dex);\n    }"
              },
              "batchRemoveDex": {
                "name": "batchRemoveDex",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address[]",
                    "name": "_dexs"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n        for (uint256 i = 0; i < length; ) {\n            LibAllowList.removeAllowedContract(_dexs[i]);\n            emit DexRemoved(_dexs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "setFunctionApprovalBySignature": {
                "name": "setFunctionApprovalBySignature",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_signature"
                  },
                  {
                    "type": "bool",
                    "name": "_approval"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        if (_approval) {\n            LibAllowList.addAllowedSelector(_signature);\n        } else {\n            LibAllowList.removeAllowedSelector(_signature);\n        }\n\n        emit FunctionSignatureApprovalChanged(_signature, _approval);\n    }"
              },
              "batchSetFunctionApprovalBySignature": {
                "name": "batchSetFunctionApprovalBySignature",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4[]",
                    "name": "_signatures"
                  },
                  {
                    "type": "bool",
                    "name": "_approval"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _signatures.length;\n        for (uint256 i = 0; i < length; ) {\n            bytes4 _signature = _signatures[i];\n            if (_approval) {\n                LibAllowList.addAllowedSelector(_signature);\n            } else {\n                LibAllowList.removeAllowedSelector(_signature);\n            }\n            emit FunctionSignatureApprovalChanged(_signature, _approval);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "isFunctionApproved": {
                "name": "isFunctionApproved",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_signature"
                  }
                ],
                "returns": [
                  {
                    "type": "bool approved"
                  }
                ],
                "modifiers": [],
                "code": "return LibAllowList.selectorIsAllowed(_signature);\n    }"
              },
              "approvedDexs": {
                "name": "approvedDexs",
                "visibility": "external",
                "parameters": [],
                "returns": [
                  {
                    "type": "address[] memory addresses"
                  }
                ],
                "modifiers": [],
                "code": "return LibAllowList.getAllowedContracts();\n    }"
              }
            },
            "state_variables": {
              "length": {
                "name": "length",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_signatures.length"
              },
              "dex": {
                "name": "dex",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_dexs[i]"
              },
              "_signature": {
                "name": "_signature",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": "_signatures[i]"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Dex Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Facet contract for managing approved DEXs to be used in swaps.\n/// @custom:version 1.0.1\ncontract DexManagerFacet {\n    /// Events ///\n\n    event DexAdded(address indexed dexAddress);\n    event DexRemoved(address indexed dexAddress);\n    event FunctionSignatureApprovalChanged(\n        bytes4 indexed functionSignature,\n        bool indexed approved\n    );\n\n    /// External Methods ///\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        LibAllowList.addAllowedContract(_dex);\n\n        emit DexAdded(_dex);\n    }\n\n    /// @notice Batch register the address of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n\n        for (uint256 i = 0; i < length; ) {\n            address dex = _dexs[i];\n            if (dex == address(this)) {\n                revert CannotAuthoriseSelf();\n            }\n            if (LibAllowList.contractIsAllowed(dex)) continue;\n            LibAllowList.addAllowedContract(dex);\n            emit DexAdded(dex);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        LibAllowList.removeAllowedContract(_dex);\n        emit DexRemoved(_dex);\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n        for (uint256 i = 0; i < length; ) {\n            LibAllowList.removeAllowedContract(_dexs[i]);\n            emit DexRemoved(_dexs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Adds/removes a specific function signature to/from the allowlist\n    /// @param _signature the function signature to allow/disallow\n    /// @param _approval whether the function signature should be allowed\n    function setFunctionApprovalBySignature(\n        bytes4 _signature,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        if (_approval) {\n            LibAllowList.addAllowedSelector(_signature);\n        } else {\n            LibAllowList.removeAllowedSelector(_signature);\n        }\n\n        emit FunctionSignatureApprovalChanged(_signature, _approval);\n    }\n\n    /// @notice Batch Adds/removes a specific function signature to/from the allowlist\n    /// @param _signatures the function signatures to allow/disallow\n    /// @param _approval whether the function signatures should be allowed\n    function batchSetFunctionApprovalBySignature(\n        bytes4[] calldata _signatures,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _signatures.length;\n        for (uint256 i = 0; i < length; ) {\n            bytes4 _signature = _signatures[i];\n            if (_approval) {\n                LibAllowList.addAllowedSelector(_signature);\n            } else {\n                LibAllowList.removeAllowedSelector(_signature);\n            }\n            emit FunctionSignatureApprovalChanged(_signature, _approval);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns whether a function signature is approved\n    /// @param _signature the function signature to query\n    /// @return approved Approved or not\n    function isFunctionApproved(\n        bytes4 _signature\n    ) public view returns (bool approved) {\n        return LibAllowList.selectorIsAllowed(_signature);\n    }\n\n    /// @notice Returns a list of all approved DEX addresses.\n    /// @return addresses List of approved DEX addresses\n    function approvedDexs()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        return LibAllowList.getAllowedContracts();\n    }\n}\n"
      },
      "call_graph": {
        "DexManagerFacet": {
          "addDex": [],
          "batchAddDex": [],
          "removeDex": [],
          "batchRemoveDex": [],
          "setFunctionApprovalBySignature": [],
          "batchSetFunctionApprovalBySignature": [],
          "isFunctionApproved": [],
          "approvedDexs": []
        }
      },
      "flow_data": {
        "DexManagerFacet": {
          "addDex": {
            "name": "addDex",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_dex"
              }
            ],
            "returns": []
          },
          "batchAddDex": {
            "name": "batchAddDex",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "for",
                "condition": "uint256 i = 0; i < length;",
                "line": 6
              },
              {
                "type": "if",
                "condition": "dex == address(this",
                "line": 8
              },
              {
                "type": "if",
                "condition": "LibAllowList.contractIsAllowed(dex",
                "line": 11
              }
            ],
            "state_changes": [
              {
                "variable": "length",
                "type": "uint256",
                "value": "_dexs.length",
                "line": 4
              },
              {
                "variable": "dex",
                "type": "address",
                "value": "_dexs[i]",
                "line": 7
              },
              {
                "variable": "dex",
                "type": "address",
                "value": "= address(this)) {\n                revert CannotAuthoriseSelf()",
                "line": 8
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "6": "for (uint256 i = 0; i < length;)",
              "8": "State Change: dex = = address(this)) {\n                revert CannotAuthoriseSelf()",
              "11": "if (LibAllowList.contractIsAllowed(dex)",
              "4": "State Change: length = _dexs.length",
              "7": "State Change: dex = _dexs[i]"
            },
            "parameters": [
              {
                "type": "address[]",
                "name": "_dexs"
              }
            ],
            "returns": []
          },
          "removeDex": {
            "name": "removeDex",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_dex"
              }
            ],
            "returns": []
          },
          "batchRemoveDex": {
            "name": "batchRemoveDex",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "for",
                "condition": "uint256 i = 0; i < length;",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "length",
                "type": "uint256",
                "value": "_dexs.length",
                "line": 4
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "5": "for (uint256 i = 0; i < length;)",
              "4": "State Change: length = _dexs.length"
            },
            "parameters": [
              {
                "type": "address[]",
                "name": "_dexs"
              }
            ],
            "returns": []
          },
          "setFunctionApprovalBySignature": {
            "name": "setFunctionApprovalBySignature",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "if",
                "condition": "_approval",
                "line": 5
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "5": "if (_approval)"
            },
            "parameters": [
              {
                "type": "bytes4",
                "name": "_signature"
              },
              {
                "type": "bool",
                "name": "_approval"
              }
            ],
            "returns": []
          },
          "batchSetFunctionApprovalBySignature": {
            "name": "batchSetFunctionApprovalBySignature",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "for",
                "condition": "uint256 i = 0; i < length;",
                "line": 5
              },
              {
                "type": "if",
                "condition": "_approval",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "length",
                "type": "uint256",
                "value": "_signatures.length",
                "line": 4
              },
              {
                "variable": "_signature",
                "type": "bytes4",
                "value": "_signatures[i]",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "5": "for (uint256 i = 0; i < length;)",
              "7": "if (_approval)",
              "4": "State Change: length = _signatures.length",
              "6": "State Change: _signature = _signatures[i]"
            },
            "parameters": [
              {
                "type": "bytes4[]",
                "name": "_signatures"
              },
              {
                "type": "bool",
                "name": "_approval"
              }
            ],
            "returns": []
          },
          "isFunctionApproved": {
            "name": "isFunctionApproved",
            "visibility": "public",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes4",
                "name": "_signature"
              }
            ],
            "returns": [
              {
                "type": "bool approved"
              }
            ]
          },
          "approvedDexs": {
            "name": "approvedDexs",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": [
              {
                "type": "address[] memory addresses"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "DexManagerFacet": {
          "addDex": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "batchAddDex": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "removeDex": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "batchRemoveDex": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "setFunctionApprovalBySignature": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "batchSetFunctionApprovalBySignature": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "isFunctionApproved": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "approvedDexs": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.670207"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.673931"
      },
      "final_report": {
        "file_id": "DexManagerFacet.sol",
        "timestamp": "2025-03-11T07:05:50.673951",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "DexManagerFacet": {
            "functions": 8,
            "state_variables": 3,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of DexManagerFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.673963"
    },
    "DiamondCutFacet.sol": {
      "file_id": "DiamondCutFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "DiamondCutFacet": {
            "name": "DiamondCutFacet",
            "inheritance": [
              "IDiamondCut"
            ],
            "functions": {
              "diamondCut": {
                "name": "diamondCut",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "LibDiamond.FacetCut[]",
                    "name": "_diamondCut"
                  },
                  {
                    "type": "address",
                    "name": "_init"
                  },
                  {
                    "type": "bytes",
                    "name": "_calldata"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Diamond Cut Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for upgrading Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        LibDiamond.FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
      },
      "call_graph": {
        "DiamondCutFacet": {
          "diamondCut": [
            {
              "contract": "DiamondCutFacet",
              "function": "diamondCut"
            }
          ]
        }
      },
      "flow_data": {
        "DiamondCutFacet": {
          "diamondCut": {
            "name": "diamondCut",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "LibDiamond.FacetCut[]",
                "name": "_diamondCut"
              },
              {
                "type": "address",
                "name": "_init"
              },
              {
                "type": "bytes",
                "name": "_calldata"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "DiamondCutFacet": {
          "diamondCut": {
            "calls": [
              {
                "contract": "DiamondCutFacet",
                "function": "diamondCut",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [
              {
                "contract": "DiamondCutFacet",
                "function": "diamondCut"
              }
            ],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.677203"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.679871"
      },
      "final_report": {
        "file_id": "DiamondCutFacet.sol",
        "timestamp": "2025-03-11T07:05:50.679895",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "DiamondCutFacet": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "IDiamondCut"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of DiamondCutFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.679907"
    },
    "DiamondLoupeFacet.sol": {
      "file_id": "DiamondLoupeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "DiamondLoupeFacet": {
            "name": "DiamondLoupeFacet",
            "inheritance": [
              "IDiamondLoupe",
              "IERC165"
            ],
            "functions": {
              "facets": {
                "name": "facets",
                "visibility": "external",
                "parameters": [],
                "returns": [
                  {
                    "type": "Facet[] memory facets_"
                  }
                ],
                "modifiers": [],
                "code": "LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i = 0; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "facetFunctionSelectors": {
                "name": "facetFunctionSelectors",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_facet"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes4[] memory facetFunctionSelectors_"
                  }
                ],
                "modifiers": [],
                "code": "LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }"
              },
              "facetAddresses": {
                "name": "facetAddresses",
                "visibility": "external",
                "parameters": [],
                "returns": [
                  {
                    "type": "address[] memory facetAddresses_"
                  }
                ],
                "modifiers": [],
                "code": "LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }"
              },
              "facetAddress": {
                "name": "facetAddress",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_functionSelector"
                  }
                ],
                "returns": [
                  {
                    "type": "address facetAddress_"
                  }
                ],
                "modifiers": [],
                "code": "LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }"
              },
              "supportsInterface": {
                "name": "supportsInterface",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes4",
                    "name": "_interfaceId"
                  }
                ],
                "returns": [
                  {
                    "type": "bool"
                  }
                ],
                "modifiers": [],
                "code": "LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }"
              }
            },
            "state_variables": {
              "numFacets": {
                "name": "numFacets",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "ds.facetAddresses.length"
              },
              "facetAddress_": {
                "name": "facetAddress_",
                "type": "address",
                "visibility": "internal",
                "initial_value": "ds.facetAddresses[i]"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../Interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../Interfaces/IERC165.sol\";\n\n/// @title Diamond Loupe Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for inspecting Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i = 0; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    )\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
      },
      "call_graph": {
        "DiamondLoupeFacet": {
          "facets": [],
          "facetFunctionSelectors": [],
          "facetAddresses": [],
          "facetAddress": [],
          "supportsInterface": []
        }
      },
      "flow_data": {
        "DiamondLoupeFacet": {
          "facets": {
            "name": "facets",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < numFacets;",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "numFacets",
                "type": "uint256",
                "value": "ds.facetAddresses.length",
                "line": 2
              },
              {
                "variable": "facetAddress_",
                "type": "address",
                "value": "ds.facetAddresses[i]",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "for (uint256 i = 0; i < numFacets;)",
              "2": "State Change: numFacets = ds.facetAddresses.length",
              "5": "State Change: facetAddress_ = ds.facetAddresses[i]"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Facet[] memory facets_"
              }
            ]
          },
          "facetFunctionSelectors": {
            "name": "facetFunctionSelectors",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "_facet"
              }
            ],
            "returns": [
              {
                "type": "bytes4[] memory facetFunctionSelectors_"
              }
            ]
          },
          "facetAddresses": {
            "name": "facetAddresses",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": [
              {
                "type": "address[] memory facetAddresses_"
              }
            ]
          },
          "facetAddress": {
            "name": "facetAddress",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "facetAddress_",
                "type": "address",
                "value": "ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress"
            },
            "parameters": [
              {
                "type": "bytes4",
                "name": "_functionSelector"
              }
            ],
            "returns": [
              {
                "type": "address facetAddress_"
              }
            ]
          },
          "supportsInterface": {
            "name": "supportsInterface",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes4",
                "name": "_interfaceId"
              }
            ],
            "returns": [
              {
                "type": "bool"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "DiamondLoupeFacet": {
          "facets": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "facetFunctionSelectors": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "facetAddresses": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "facetAddress": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "supportsInterface": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.701525"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.729704"
      },
      "final_report": {
        "file_id": "DiamondLoupeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.729728",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "DiamondLoupeFacet": {
            "functions": 5,
            "state_variables": 2,
            "inheritance": [
              "IDiamondLoupe",
              "IERC165"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of DiamondLoupeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.729741"
    },
    "EmergencyPauseFacet.sol": {
      "file_id": "EmergencyPauseFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "EmergencyPauseFacet": {
            "name": "EmergencyPauseFacet",
            "inheritance": [],
            "functions": {
              "unpauseDiamond": {
                "name": "unpauseDiamond",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address[]",
                    "name": "_blacklist"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// make sure this function can only be called by the owner\n        LibDiamond.enforceIsContractOwner();\n\n        // get all facets from storage\n        Storage storage s = getStorage();\n\n        // iterate through all facets and reinstate the facet with its function selectors\n        for (uint256 i; i < s.facets.length; ) {\n            LibDiamond.replaceFunctions(\n                s.facets[i].facetAddress,\n                s.facets[i].functionSelectors\n            );\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        // go through blacklist and overwrite all function selectors with zero address\n        // It would be easier to not reinstate these facets in the first place but\n        //  a) that would leave their function selectors associated with address of EmergencyPauseFacet (=> throws 'DiamondIsPaused() error when called)\n        //  b) it consumes a lot of gas to check every facet address if it's part of the blacklist\n        bytes4[] memory currentSelectors;\n        for (uint256 i; i < _blacklist.length; ) {\n            currentSelectors = LibDiamondLoupe.facetFunctionSelectors(\n                _blacklist[i]\n            );\n\n            // make sure that the DiamondCutFacet cannot be removed as this would make the diamond immutable\n            if (currentSelectors[0] == DiamondCutFacet.diamondCut.selector)\n                continue;\n\n            // build FacetCut parameter\n            LibDiamond.FacetCut[] memory facetCut = new LibDiamond.FacetCut[](\n                1\n            );\n            facetCut[0] = LibDiamond.FacetCut({\n                facetAddress: address(0), // needs to be address(0) for removals\n                action: LibDiamond.FacetCutAction.Remove,\n                functionSelectors: currentSelectors\n            });\n\n            // remove facet and its selectors from diamond\n            LibDiamond.diamondCut(facetCut, address(0), \"\");\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        // free storage\n        delete s.facets;\n\n        emit EmergencyUnpaused(msg.sender);\n    }"
              },
              "_getAllFacetFunctionSelectorsToBeRemoved": {
                "name": "_getAllFacetFunctionSelectorsToBeRemoved",
                "visibility": "internal",
                "parameters": [],
                "returns": [
                  {
                    "type": "IDiamondLoupe.Facet[] memory toBeRemoved"
                  }
                ],
                "modifiers": [],
                "code": "// get a list of all registered facet addresses\n        IDiamondLoupe.Facet[] memory allFacets = LibDiamondLoupe.facets();\n\n        // initiate return variable with allFacets length - 1 (since we will not remove the EmergencyPauseFacet)\n        toBeRemoved = new IDiamondLoupe.Facet[](allFacets.length - 1);\n\n        // iterate through facets, copy every facet but EmergencyPauseFacet\n        uint256 toBeRemovedCounter;\n        for (uint256 i; i < allFacets.length; ) {\n            // if its not the EmergencyPauseFacet, copy to the return value variable\n            if (allFacets[i].facetAddress != _emergencyPauseFacetAddress) {\n                toBeRemoved[toBeRemovedCounter].facetAddress = allFacets[i]\n                    .facetAddress;\n                toBeRemoved[toBeRemovedCounter].functionSelectors = allFacets[\n                    i\n                ].functionSelectors;\n\n                // gas-efficient way to increase counter\n                unchecked {\n                    ++toBeRemovedCounter;\n                }\n            }\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              },
              "receive": {
                "name": "receive",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "}"
              }
            },
            "state_variables": {
              "facets": {
                "name": "facets",
                "type": "memory",
                "visibility": "internal",
                "initial_value": "_getAllFacetFunctionSelectorsToBeRemoved()"
              },
              "toBeRemovedCounter": {
                "name": "toBeRemovedCounter",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibDiamondLoupe } from \"../Libraries/LibDiamondLoupe.sol\";\nimport { UnAuthorized, InvalidCallData, DiamondIsPaused } from \"../Errors/GenericErrors.sol\";\nimport { IDiamondLoupe } from \"lifi/Interfaces/IDiamondLoupe.sol\";\nimport { DiamondCutFacet } from \"lifi/Facets/DiamondCutFacet.sol\";\n\n/// @title EmergencyPauseFacet (Admin only)\n/// @author LI.FI (https://li.fi)\n/// @notice Allows a LI.FI-owned and -controlled, non-multisig \"PauserWallet\" to remove a facet or pause the diamond in case of emergency\n/// @custom:version 1.0.1\n/// @dev Admin-Facet for emergency purposes only\ncontract EmergencyPauseFacet {\n    /// Events ///\n    event EmergencyFacetRemoved(\n        address indexed facetAddress,\n        address indexed msgSender\n    );\n    event EmergencyPaused(address indexed msgSender);\n    event EmergencyUnpaused(address indexed msgSender);\n\n    /// Errors ///\n    error FacetIsNotRegistered();\n    error NoFacetToPause();\n\n    /// Storage ///\n    address public immutable pauserWallet;\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.emergencyPauseFacet\");\n    address internal immutable _emergencyPauseFacetAddress;\n\n    struct Storage {\n        IDiamondLoupe.Facet[] facets;\n    }\n\n    /// Modifiers ///\n    modifier OnlyPauserWalletOrOwner() {\n        if (\n            msg.sender != pauserWallet &&\n            msg.sender != LibDiamond.contractOwner()\n        ) revert UnAuthorized();\n        _;\n    }\n\n    /// Constructor ///\n    /// @param _pauserWallet The address of the wallet that can execute emergency facet removal actions\n    constructor(address _pauserWallet) {\n        pauserWallet = _pauserWallet;\n        _emergencyPauseFacetAddress = address(this);\n    }\n\n    /// External Methods ///\n\n    /// @notice Removes the given facet from the diamond\n    /// @param _facetAddress The address of the facet that should be removed\n    /// @dev can only be executed by pauserWallet (non-multisig for fast response time) or by the diamond owner\n    function removeFacet(\n        address _facetAddress\n    ) external OnlyPauserWalletOrOwner {\n        // make sure that the EmergencyPauseFacet itself cannot be removed through this function\n        if (_facetAddress == _emergencyPauseFacetAddress)\n            revert InvalidCallData();\n\n        // get function selectors for this facet\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        bytes4[] memory functionSelectors = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors;\n\n        // do not continue if no registered function selectors were found\n        if (functionSelectors.length == 0) revert FacetIsNotRegistered();\n\n        // make sure that DiamondCutFacet cannot be removed\n        if (functionSelectors[0] == DiamondCutFacet.diamondCut.selector)\n            revert InvalidCallData();\n\n        // remove facet\n        LibDiamond.removeFunctions(address(0), functionSelectors);\n\n        emit EmergencyFacetRemoved(_facetAddress, msg.sender);\n    }\n\n    /// @notice Effectively pauses the diamond contract by overwriting the facetAddress-to-function-selector mappings in storage for all facets\n    ///         and redirecting all function selectors to the EmergencyPauseFacet (this will remain as the only registered facet) so that\n    ///         a meaningful error message will be returned when third parties try to call the diamond\n    /// @dev can only be executed by pauserWallet (non-multisig for fast response time) or by the diamond owner\n    /// @dev This function could potentially run out of gas if too many facets/function selectors are involved. We mitigate this issue by having a test on\n    /// @dev forked mainnet (which has most facets) that checks if the diamond can be paused\n    function pauseDiamond() external OnlyPauserWalletOrOwner {\n        Storage storage s = getStorage();\n\n        // get a list of all facets that need to be removed (=all facets except EmergencyPauseFacet)\n        IDiamondLoupe.Facet[]\n            memory facets = _getAllFacetFunctionSelectorsToBeRemoved();\n\n        // prevent invalid contract state\n        if (facets.length == 0) revert NoFacetToPause();\n\n        // go through all facets\n        for (uint256 i; i < facets.length; ) {\n            // redirect all function selectors to this facet (i.e. to its fallback function with the DiamondIsPaused() error message)\n            LibDiamond.replaceFunctions(\n                _emergencyPauseFacetAddress,\n                facets[i].functionSelectors\n            );\n\n            // write facet information to storage (so it can be easily reactivated later on)\n            s.facets.push(facets[i]);\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit EmergencyPaused(msg.sender);\n    }\n\n    /// @notice Unpauses the diamond contract by re-adding all facetAddress-to-function-selector mappings to storage\n    /// @dev can only be executed by diamond owner (multisig)\n    /// @param _blacklist The address(es) of facet(s) that should not be reactivated\n    function unpauseDiamond(address[] calldata _blacklist) external {\n        // make sure this function can only be called by the owner\n        LibDiamond.enforceIsContractOwner();\n\n        // get all facets from storage\n        Storage storage s = getStorage();\n\n        // iterate through all facets and reinstate the facet with its function selectors\n        for (uint256 i; i < s.facets.length; ) {\n            LibDiamond.replaceFunctions(\n                s.facets[i].facetAddress,\n                s.facets[i].functionSelectors\n            );\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        // go through blacklist and overwrite all function selectors with zero address\n        // It would be easier to not reinstate these facets in the first place but\n        //  a) that would leave their function selectors associated with address of EmergencyPauseFacet (=> throws 'DiamondIsPaused() error when called)\n        //  b) it consumes a lot of gas to check every facet address if it's part of the blacklist\n        bytes4[] memory currentSelectors;\n        for (uint256 i; i < _blacklist.length; ) {\n            currentSelectors = LibDiamondLoupe.facetFunctionSelectors(\n                _blacklist[i]\n            );\n\n            // make sure that the DiamondCutFacet cannot be removed as this would make the diamond immutable\n            if (currentSelectors[0] == DiamondCutFacet.diamondCut.selector)\n                continue;\n\n            // build FacetCut parameter\n            LibDiamond.FacetCut[] memory facetCut = new LibDiamond.FacetCut[](\n                1\n            );\n            facetCut[0] = LibDiamond.FacetCut({\n                facetAddress: address(0), // needs to be address(0) for removals\n                action: LibDiamond.FacetCutAction.Remove,\n                functionSelectors: currentSelectors\n            });\n\n            // remove facet and its selectors from diamond\n            LibDiamond.diamondCut(facetCut, address(0), \"\");\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n\n        // free storage\n        delete s.facets;\n\n        emit EmergencyUnpaused(msg.sender);\n    }\n\n    /// INTERNAL HELPER FUNCTIONS\n\n    function _getAllFacetFunctionSelectorsToBeRemoved()\n        internal\n        view\n        returns (IDiamondLoupe.Facet[] memory toBeRemoved)\n    {\n        // get a list of all registered facet addresses\n        IDiamondLoupe.Facet[] memory allFacets = LibDiamondLoupe.facets();\n\n        // initiate return variable with allFacets length - 1 (since we will not remove the EmergencyPauseFacet)\n        toBeRemoved = new IDiamondLoupe.Facet[](allFacets.length - 1);\n\n        // iterate through facets, copy every facet but EmergencyPauseFacet\n        uint256 toBeRemovedCounter;\n        for (uint256 i; i < allFacets.length; ) {\n            // if its not the EmergencyPauseFacet, copy to the return value variable\n            if (allFacets[i].facetAddress != _emergencyPauseFacetAddress) {\n                toBeRemoved[toBeRemovedCounter].facetAddress = allFacets[i]\n                    .facetAddress;\n                toBeRemoved[toBeRemovedCounter].functionSelectors = allFacets[\n                    i\n                ].functionSelectors;\n\n                // gas-efficient way to increase counter\n                unchecked {\n                    ++toBeRemovedCounter;\n                }\n            }\n\n            // gas-efficient way to increase loop counter\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n\n    // this function will be called when the diamond is paused to return a meaningful error message instead of \"FunctionDoesNotExist\"\n    fallback() external payable {\n        revert DiamondIsPaused();\n    }\n\n    // only added to silence compiler warnings that arose after adding the fallback function\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "EmergencyPauseFacet": {
          "unpauseDiamond": [
            {
              "contract": "EmergencyPauseFacet",
              "function": "getStorage"
            }
          ],
          "_getAllFacetFunctionSelectorsToBeRemoved": [],
          "getStorage": [],
          "receive": []
        }
      },
      "flow_data": {
        "EmergencyPauseFacet": {
          "unpauseDiamond": {
            "name": "unpauseDiamond",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i; i < s.facets.length;",
                "line": 8
              },
              {
                "type": "for",
                "condition": "uint256 i; i < _blacklist.length;",
                "line": 25
              },
              {
                "type": "if",
                "condition": "currentSelectors[0] == DiamondCutFacet.diamondCut.selector",
                "line": 31
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "8": "for (uint256 i; i < s.facets.length;)",
              "25": "for (uint256 i; i < _blacklist.length;)",
              "31": "if (currentSelectors[0] == DiamondCutFacet.diamondCut.selector)"
            },
            "parameters": [
              {
                "type": "address[]",
                "name": "_blacklist"
              }
            ],
            "returns": []
          },
          "_getAllFacetFunctionSelectorsToBeRemoved": {
            "name": "_getAllFacetFunctionSelectorsToBeRemoved",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i; i < allFacets.length;",
                "line": 9
              },
              {
                "type": "if",
                "condition": "allFacets[i].facetAddress != _emergencyPauseFacetAddress",
                "line": 11
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "9": "for (uint256 i; i < allFacets.length;)",
              "11": "if (allFacets[i].facetAddress != _emergencyPauseFacetAddress)"
            },
            "parameters": [],
            "returns": [
              {
                "type": "IDiamondLoupe.Facet[] memory toBeRemoved"
              }
            ]
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          },
          "receive": {
            "name": "receive",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "EmergencyPauseFacet": {
          "unpauseDiamond": {
            "calls": [
              {
                "contract": "EmergencyPauseFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getAllFacetFunctionSelectorsToBeRemoved": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "receive": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.733681"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.738653"
      },
      "final_report": {
        "file_id": "EmergencyPauseFacet.sol",
        "timestamp": "2025-03-11T07:05:50.738678",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "EmergencyPauseFacet": {
            "functions": 4,
            "state_variables": 3,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of EmergencyPauseFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.738691"
    },
    "GasZipFacet.sol": {
      "file_id": "GasZipFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "GasZipFacet": {
            "name": "GasZipFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "IGasZip.GasZipData",
                    "name": "_gasZipData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// make sure receiver address has a value to prevent potential loss of funds\n        if (_gasZipData.receiverAddress == bytes32(0))\n            revert InvalidCallData();\n\n        // validate that receiverAddress matches with bridgeData in case of EVM target chain\n        if (\n            _bridgeData.receiver != NON_EVM_ADDRESS &&\n            _gasZipData.receiverAddress !=\n            bytes32(uint256(uint160(_bridgeData.receiver)))\n        ) revert InvalidCallData();\n\n        // validate bridgeData\n        // make sure destinationChainId is of a different network\n        if (_bridgeData.destinationChainId == block.chainid)\n            revert CannotBridgeToSameNetwork();\n\n        // We are depositing to a new contract that supports deposits for EVM chains + Solana (therefore 'receiver' address is bytes32)\n        gasZipRouter.deposit{ value: _bridgeData.minAmount }(\n            _gasZipData.destinationChains,\n            _gasZipData.receiverAddress\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "getDestinationChainsValue": {
                "name": "getDestinationChainsValue",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint8[]",
                    "name": "_chainIds"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 destinationChains"
                  }
                ],
                "modifiers": [],
                "code": "uint256 length = _chainIds.length;\n\n        if (length > MAX_CHAINID_LENGTH_ALLOWED) revert TooManyChainIds();\n\n        for (uint256 i; i < length; ++i) {\n            // Shift destinationChains left by 8 bits and add the next chainID\n            destinationChains =\n                (destinationChains << 8) |\n                uint256(_chainIds[i]);\n        }\n    }"
              }
            },
            "state_variables": {
              "length": {
                "name": "length",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_chainIds.length"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGasZip } from \"../Interfaces/IGasZip.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { InvalidCallData, CannotBridgeToSameNetwork, InvalidAmount } from \"lifi/Errors/GenericErrors.sol\";\n\n/// @title GasZipFacet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality to swap ERC20 tokens to native and deposit them to the gas.zip protocol (https://www.gas.zip/)\n/// @custom:version 2.0.2\ncontract GasZipFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    using SafeTransferLib for address;\n\n    error OnlyNativeAllowed();\n    error TooManyChainIds();\n\n    /// State ///\n    address public constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n    IGasZip public immutable gasZipRouter;\n    uint256 internal constant MAX_CHAINID_LENGTH_ALLOWED = 32;\n\n    /// Constructor ///\n    constructor(address _gasZipRouter) {\n        gasZipRouter = IGasZip(_gasZipRouter);\n    }\n\n    /// @notice Bridges tokens using the gas.zip protocol\n    /// @dev this function only supports native flow. For ERC20 flows this facet should be used as a protocol step instead\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _gasZipData contains information which chains and address gas should be sent to\n    function startBridgeTokensViaGasZip(\n        ILiFi.BridgeData memory _bridgeData,\n        IGasZip.GasZipData calldata _gasZipData\n    )\n        external\n        payable\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        // this function / path shall only be used for native assets\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId))\n            revert OnlyNativeAllowed();\n\n        // make sure that msg.value matches the to-be-deposited amount\n        if (msg.value != _bridgeData.minAmount) revert InvalidAmount();\n\n        // deposit native to Gas.zip\n        _startBridge(_bridgeData, _gasZipData);\n    }\n\n    /// @notice Performs one or multiple actions (e.g. fee collection, swapping) that must end with the native token before depositing to the gas.zip protocol\n    /// @param _bridgeData The core information needed for depositing\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _gasZipData contains information which chains and address gas should be sent to\n    function swapAndStartBridgeTokensViaGasZip(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        IGasZip.GasZipData calldata _gasZipData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        // make sure that the output of the last swap step is native\n        if (\n            !LibAsset.isNativeAsset(\n                _swapData[_swapData.length - 1].receivingAssetId\n            )\n        ) revert InvalidCallData();\n\n        // deposit and swap ERC20 tokens to native\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        // deposit native to Gas.zip\n        _startBridge(_bridgeData, _gasZipData);\n    }\n\n    /// @dev Contains the business logic for depositing to GasZip protocol\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _gasZipData contains information which chains and address gas should be sent to\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        IGasZip.GasZipData calldata _gasZipData\n    ) internal {\n        // make sure receiver address has a value to prevent potential loss of funds\n        if (_gasZipData.receiverAddress == bytes32(0))\n            revert InvalidCallData();\n\n        // validate that receiverAddress matches with bridgeData in case of EVM target chain\n        if (\n            _bridgeData.receiver != NON_EVM_ADDRESS &&\n            _gasZipData.receiverAddress !=\n            bytes32(uint256(uint160(_bridgeData.receiver)))\n        ) revert InvalidCallData();\n\n        // validate bridgeData\n        // make sure destinationChainId is of a different network\n        if (_bridgeData.destinationChainId == block.chainid)\n            revert CannotBridgeToSameNetwork();\n\n        // We are depositing to a new contract that supports deposits for EVM chains + Solana (therefore 'receiver' address is bytes32)\n        gasZipRouter.deposit{ value: _bridgeData.minAmount }(\n            _gasZipData.destinationChains,\n            _gasZipData.receiverAddress\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev Returns a value that signals to Gas.zip to which chains gas should be sent in equal parts\n    /// @param _chainIds a list of Gas.zip-specific chainIds (not the original chainIds), see https://dev.gas.zip/gas/chain-support/outbound\n    function getDestinationChainsValue(\n        uint8[] calldata _chainIds\n    ) external pure returns (uint256 destinationChains) {\n        uint256 length = _chainIds.length;\n\n        if (length > MAX_CHAINID_LENGTH_ALLOWED) revert TooManyChainIds();\n\n        for (uint256 i; i < length; ++i) {\n            // Shift destinationChains left by 8 bits and add the next chainID\n            destinationChains =\n                (destinationChains << 8) |\n                uint256(_chainIds[i]);\n        }\n    }\n}\n"
      },
      "call_graph": {
        "GasZipFacet": {
          "_startBridge": [],
          "getDestinationChainsValue": []
        }
      },
      "flow_data": {
        "GasZipFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "_gasZipData.receiverAddress == bytes32(0",
                "line": 2
              },
              {
                "type": "if",
                "condition": "_bridgeData.receiver != NON_EVM_ADDRESS &&\n            _gasZipData.receiverAddress !=\n            bytes32(uint256(uint160(_bridgeData.receiver",
                "line": 6
              },
              {
                "type": "if",
                "condition": "_bridgeData.destinationChainId == block.chainid",
                "line": 14
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (_gasZipData.receiverAddress == bytes32(0)",
              "6": "if (_bridgeData.receiver != NON_EVM_ADDRESS &&\n            _gasZipData.receiverAddress !=\n            bytes32(uint256(uint160(_bridgeData.receiver)",
              "14": "if (_bridgeData.destinationChainId == block.chainid)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "IGasZip.GasZipData",
                "name": "_gasZipData"
              }
            ],
            "returns": []
          },
          "getDestinationChainsValue": {
            "name": "getDestinationChainsValue",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "length > MAX_CHAINID_LENGTH_ALLOWED",
                "line": 3
              },
              {
                "type": "for",
                "condition": "uint256 i; i < length; ++i",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "length",
                "type": "uint256",
                "value": "_chainIds.length",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (length > MAX_CHAINID_LENGTH_ALLOWED)",
              "5": "for (uint256 i; i < length; ++i)",
              "1": "State Change: length = _chainIds.length"
            },
            "parameters": [
              {
                "type": "uint8[]",
                "name": "_chainIds"
              }
            ],
            "returns": [
              {
                "type": "uint256 destinationChains"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "GasZipFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getDestinationChainsValue": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.699114"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.719290"
      },
      "final_report": {
        "file_id": "GasZipFacet.sol",
        "timestamp": "2025-03-11T07:05:50.719316",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "GasZipFacet": {
            "functions": 2,
            "state_variables": 1,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GasZipFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.719329"
    },
    "GenericSwapFacet.sol": {
      "file_id": "GenericSwapFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "GenericSwapFacet": {
            "name": "GenericSwapFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {},
            "state_variables": {
              "postSwapBalance": {
                "name": "postSwapBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_depositAndSwap(\n            _transactionId,\n            _minAmount,\n            _swapData,\n            _receiver\n        )"
              },
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swapData[_swapData.length - 1]\n            .receivingAssetId"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver } from \"../Errors/GenericErrors.sol\";\n\n/// @title GenericSwapFacet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for swapping through ANY APPROVED DEX\n/// @dev Uses calldata to execute APPROVED arbitrary methods on DEXs\n/// @custom:version 1.0.0\ncontract GenericSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// External Methods ///\n\n    /// @notice Performs multiple swaps in one transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensGeneric(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swapData\n    ) external payable nonReentrant refundExcessNative(_receiver) {\n        if (LibUtil.isZeroAddress(_receiver)) {\n            revert InvalidReceiver();\n        }\n\n        uint256 postSwapBalance = _depositAndSwap(\n            _transactionId,\n            _minAmount,\n            _swapData,\n            _receiver\n        );\n        address receivingAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        LibAsset.transferAsset(receivingAssetId, _receiver, postSwapBalance);\n\n        emit LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            receivingAssetId,\n            _swapData[0].fromAmount,\n            postSwapBalance\n        );\n    }\n}\n"
      },
      "call_graph": {
        "GenericSwapFacet": {}
      },
      "flow_data": {
        "GenericSwapFacet": {}
      },
      "flow_paths": {
        "GenericSwapFacet": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.698515"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.702362"
      },
      "final_report": {
        "file_id": "GenericSwapFacet.sol",
        "timestamp": "2025-03-11T07:05:50.702387",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "GenericSwapFacet": {
            "functions": 0,
            "state_variables": 2,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GenericSwapFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.702401"
    },
    "GenericSwapFacetV3.sol": {
      "file_id": "GenericSwapFacetV3.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "GenericSwapFacetV3": {
            "name": "GenericSwapFacetV3",
            "inheritance": [
              "ILiFi"
            ],
            "functions": {
              "swapTokensSingleV3ERC20ToERC20": {
                "name": "swapTokensSingleV3ERC20ToERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "_depositAndSwapERC20Single(_swapData, _receiver);\n\n        address receivingAssetId = _swapData.receivingAssetId;\n        address sendingAssetId = _swapData.sendingAssetId;\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }"
              },
              "swapTokensSingleV3ERC20ToNative": {
                "name": "swapTokensSingleV3ERC20ToNative",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "_depositAndSwapERC20Single(_swapData, _receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = address(this).balance;\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n\n        // emit events (both required for tracking)\n        address sendingAssetId = _swapData.sendingAssetId;\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived\n        );\n    }"
              },
              "swapTokensSingleV3NativeToERC20": {
                "name": "swapTokensSingleV3NativeToERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address callTo = _swapData.callTo;\n        // ensure that contract (callTo) and function selector are whitelisted\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(_swapData.callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call{ value: msg.value }(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageNative(_receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        address receivingAssetId = _swapData.receivingAssetId;\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            callTo,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }"
              },
              "swapTokensMultipleV3ERC20ToNative": {
                "name": "swapTokensMultipleV3ERC20ToNative",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "_depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferNativeTokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }"
              },
              "swapTokensMultipleV3ERC20ToERC20": {
                "name": "swapTokensMultipleV3ERC20ToERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "_depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }"
              },
              "swapTokensMultipleV3NativeToERC20": {
                "name": "swapTokensMultipleV3NativeToERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "_executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }"
              },
              "_depositMultipleERC20Tokens": {
                "name": "_depositMultipleERC20Tokens",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        LibSwap.SwapData calldata currentSwap;\n\n        // go through all swaps and deposit tokens, where required\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            if (currentSwap.requiresDeposit) {\n                // we will not check msg.value as tx will fail anyway if not enough value available\n                // thus we only deposit ERC20 tokens here\n                ERC20(currentSwap.sendingAssetId).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    currentSwap.fromAmount\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "_depositAndSwapERC20Single": {
                "name": "_depositAndSwapERC20Single",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "ERC20 sendingAsset = ERC20(_swapData.sendingAssetId);\n        uint256 fromAmount = _swapData.fromAmount;\n        // deposit funds\n        sendingAsset.safeTransferFrom(msg.sender, address(this), fromAmount);\n\n        // ensure that contract (callTo) and function selector are whitelisted\n        address callTo = _swapData.callTo;\n        address approveTo = _swapData.approveTo;\n        bytes calldata callData = _swapData.callData;\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // ensure that approveTo address is also whitelisted if it differs from callTo\n        if (approveTo != callTo && !LibAllowList.contractIsAllowed(approveTo))\n            revert ContractCallNotAllowed();\n\n        // check if the current allowance is sufficient\n        uint256 currentAllowance = sendingAsset.allowance(\n            address(this),\n            approveTo\n        );\n\n        // check if existing allowance is sufficient\n        if (currentAllowance < fromAmount) {\n            // check if is non-zero, set to 0 if not\n            if (currentAllowance != 0) sendingAsset.safeApprove(approveTo, 0);\n            // set allowance to uint max to avoid future approvals\n            sendingAsset.safeApprove(approveTo, type(uint256).max);\n        }\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call(callData);\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageERC20(sendingAsset, _receiver);\n    }"
              },
              "_executeSwaps": {
                "name": "_executeSwaps",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        ERC20 sendingAsset;\n        address sendingAssetId;\n        address receivingAssetId;\n        LibSwap.SwapData calldata currentSwap;\n        bool success;\n        bytes memory returnData;\n        uint256 currentAllowance;\n\n        // go through all swaps\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            sendingAssetId = currentSwap.sendingAssetId;\n            sendingAsset = ERC20(currentSwap.sendingAssetId);\n            receivingAssetId = currentSwap.receivingAssetId;\n\n            // check if callTo address is whitelisted\n            if (\n                !LibAllowList.contractIsAllowed(currentSwap.callTo) ||\n                !LibAllowList.selectorIsAllowed(\n                    bytes4(currentSwap.callData[:4])\n                )\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            // if approveTo address is different to callTo, check if it's whitelisted, too\n            if (\n                currentSwap.approveTo != currentSwap.callTo &&\n                !LibAllowList.contractIsAllowed(currentSwap.approveTo)\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            if (LibAsset.isNativeAsset(sendingAssetId)) {\n                // Native\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call{\n                    value: currentSwap.fromAmount\n                }(currentSwap.callData);\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageNative(_receiver);\n            } else {\n                // ERC20\n                // check if the current allowance is sufficient\n                currentAllowance = sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                );\n                if (currentAllowance < currentSwap.fromAmount) {\n                    sendingAsset.safeApprove(currentSwap.approveTo, 0);\n                    sendingAsset.safeApprove(\n                        currentSwap.approveTo,\n                        type(uint256).max\n                    );\n                }\n\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call(\n                    currentSwap.callData\n                );\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageERC20(sendingAsset, _receiver);\n            }\n\n            // emit AssetSwapped event\n            // @dev: this event might in some cases emit inaccurate information. e.g. if a token is swapped and this contract already held a balance of the receivingAsset\n            //       then the event will show swapOutputAmount + existingBalance as toAmount. We accept this potential inaccuracy in return for gas savings and may update this\n            //       at a later stage when the described use case becomes more common\n            emit LibSwap.AssetSwapped(\n                _transactionId,\n                currentSwap.callTo,\n                sendingAssetId,\n                receivingAssetId,\n                currentSwap.fromAmount,\n                LibAsset.isNativeAsset(receivingAssetId)\n                    ? address(this).balance\n                    : ERC20(receivingAssetId).balanceOf(address(this)),\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "_transferERC20TokensAndEmitEvent": {
                "name": "_transferERC20TokensAndEmitEvent",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// determine the end result of the swap\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        uint256 amountReceived = ERC20(finalAssetId).balanceOf(address(this));\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer to receiver\n        ERC20(finalAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            finalAssetId,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }"
              },
              "_transferNativeTokensAndEmitEvent": {
                "name": "_transferNativeTokensAndEmitEvent",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "string",
                    "name": "_integrator"
                  },
                  {
                    "type": "string",
                    "name": "_referrer"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmountOut"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 amountReceived = address(this).balance;\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) {\n            revert NativeAssetTransferFailed();\n        }\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            NATIVE_ADDRESS,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }"
              },
              "_returnPositiveSlippageERC20": {
                "name": "_returnPositiveSlippageERC20",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ERC20",
                    "name": "sendingAsset"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// if a balance exists in sendingAsset, it must be positive slippage\n        if (address(sendingAsset) != NATIVE_ADDRESS) {\n            uint256 sendingAssetBalance = sendingAsset.balanceOf(\n                address(this)\n            );\n\n            if (sendingAssetBalance > 0) {\n                sendingAsset.safeTransfer(receiver, sendingAssetBalance);\n            }\n        }\n    }"
              },
              "_returnPositiveSlippageNative": {
                "name": "_returnPositiveSlippageNative",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "address",
                    "name": "receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// if a native balance exists in sendingAsset, it must be positive slippage\n        uint256 nativeBalance = address(this).balance;\n\n        if (nativeBalance > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: nativeBalance }(\"\");\n            if (!success) revert NativeAssetTransferFailed();\n        }\n    }"
              }
            },
            "state_variables": {
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "amountReceived": {
                "name": "amountReceived",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "address(this).balance"
              },
              "fromAmount": {
                "name": "fromAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_swapData.fromAmount"
              },
              "callTo": {
                "name": "callTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swapData.callTo"
              },
              "numOfSwaps": {
                "name": "numOfSwaps",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_swapData.length"
              },
              "sendingAsset": {
                "name": "sendingAsset",
                "type": "ERC20",
                "visibility": "internal",
                "initial_value": null
              },
              "approveTo": {
                "name": "approveTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swapData.approveTo"
              },
              "currentAllowance": {
                "name": "currentAllowance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "success": {
                "name": "success",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "finalAssetId": {
                "name": "finalAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swapData[_swapData.length - 1]\n            .receivingAssetId"
              },
              "sendingAssetBalance": {
                "name": "sendingAssetBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "sendingAsset.balanceOf(\n                address(this)\n            )"
              },
              "nativeBalance": {
                "name": "nativeBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "address(this).balance"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ContractCallNotAllowed, CumulativeSlippageTooHigh, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\n/// @title GenericSwapFacetV3\n/// @author LI.FI (https://li.fi)\n/// @notice Provides gas-optimized functionality for fee collection and for swapping through any APPROVED DEX\n/// @dev Can only execute calldata for APPROVED function selectors\n/// @custom:version 1.0.1\ncontract GenericSwapFacetV3 is ILiFi {\n    using SafeTransferLib for ERC20;\n\n    /// Storage\n    address public immutable NATIVE_ADDRESS;\n\n    /// Constructor\n    /// @param _nativeAddress the address of the native token for this network\n    constructor(address _nativeAddress) {\n        NATIVE_ADDRESS = _nativeAddress;\n    }\n\n    /// External Methods ///\n\n    // SINGLE SWAPS\n\n    /// @notice Performs a single swap from an ERC20 token to another ERC20 token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3ERC20ToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external {\n        _depositAndSwapERC20Single(_swapData, _receiver);\n\n        address receivingAssetId = _swapData.receivingAssetId;\n        address sendingAssetId = _swapData.sendingAssetId;\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    /// @notice Performs a single swap from an ERC20 token to the network's native token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3ERC20ToNative(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external {\n        _depositAndSwapERC20Single(_swapData, _receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = address(this).balance;\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n\n        // emit events (both required for tracking)\n        address sendingAssetId = _swapData.sendingAssetId;\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    /// @notice Performs a single swap from the network's native token to ERC20 token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3NativeToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external payable {\n        address callTo = _swapData.callTo;\n        // ensure that contract (callTo) and function selector are whitelisted\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(_swapData.callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call{ value: msg.value }(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageNative(_receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        address receivingAssetId = _swapData.receivingAssetId;\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            callTo,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    // MULTIPLE SWAPS\n\n    /// @notice Performs multiple swaps in one transaction, starting with ERC20 and ending with native\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3ERC20ToNative(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external {\n        _depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferNativeTokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// @notice Performs multiple swaps in one transaction, starting with ERC20 and ending with ERC20\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3ERC20ToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external {\n        _depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// @notice Performs multiple swaps in one transaction, starting with native and ending with ERC20\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3NativeToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external payable {\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// Private helper methods ///\n    function _depositMultipleERC20Tokens(\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        // initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        LibSwap.SwapData calldata currentSwap;\n\n        // go through all swaps and deposit tokens, where required\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            if (currentSwap.requiresDeposit) {\n                // we will not check msg.value as tx will fail anyway if not enough value available\n                // thus we only deposit ERC20 tokens here\n                ERC20(currentSwap.sendingAssetId).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    currentSwap.fromAmount\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _depositAndSwapERC20Single(\n        LibSwap.SwapData calldata _swapData,\n        address _receiver\n    ) private {\n        ERC20 sendingAsset = ERC20(_swapData.sendingAssetId);\n        uint256 fromAmount = _swapData.fromAmount;\n        // deposit funds\n        sendingAsset.safeTransferFrom(msg.sender, address(this), fromAmount);\n\n        // ensure that contract (callTo) and function selector are whitelisted\n        address callTo = _swapData.callTo;\n        address approveTo = _swapData.approveTo;\n        bytes calldata callData = _swapData.callData;\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // ensure that approveTo address is also whitelisted if it differs from callTo\n        if (approveTo != callTo && !LibAllowList.contractIsAllowed(approveTo))\n            revert ContractCallNotAllowed();\n\n        // check if the current allowance is sufficient\n        uint256 currentAllowance = sendingAsset.allowance(\n            address(this),\n            approveTo\n        );\n\n        // check if existing allowance is sufficient\n        if (currentAllowance < fromAmount) {\n            // check if is non-zero, set to 0 if not\n            if (currentAllowance != 0) sendingAsset.safeApprove(approveTo, 0);\n            // set allowance to uint max to avoid future approvals\n            sendingAsset.safeApprove(approveTo, type(uint256).max);\n        }\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call(callData);\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageERC20(sendingAsset, _receiver);\n    }\n\n    // @dev: this function will not work with swapData that has multiple swaps with the same sendingAssetId\n    //       as the _returnPositiveSlippage... functionality will refund all remaining tokens after the first swap\n    //       We accept this fact since the use case is not common yet. As an alternative you can always use the\n    //       \"swapTokensGeneric\" function of the original GenericSwapFacet\n    function _executeSwaps(\n        LibSwap.SwapData[] calldata _swapData,\n        bytes32 _transactionId,\n        address _receiver\n    ) private {\n        // initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        ERC20 sendingAsset;\n        address sendingAssetId;\n        address receivingAssetId;\n        LibSwap.SwapData calldata currentSwap;\n        bool success;\n        bytes memory returnData;\n        uint256 currentAllowance;\n\n        // go through all swaps\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            sendingAssetId = currentSwap.sendingAssetId;\n            sendingAsset = ERC20(currentSwap.sendingAssetId);\n            receivingAssetId = currentSwap.receivingAssetId;\n\n            // check if callTo address is whitelisted\n            if (\n                !LibAllowList.contractIsAllowed(currentSwap.callTo) ||\n                !LibAllowList.selectorIsAllowed(\n                    bytes4(currentSwap.callData[:4])\n                )\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            // if approveTo address is different to callTo, check if it's whitelisted, too\n            if (\n                currentSwap.approveTo != currentSwap.callTo &&\n                !LibAllowList.contractIsAllowed(currentSwap.approveTo)\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            if (LibAsset.isNativeAsset(sendingAssetId)) {\n                // Native\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call{\n                    value: currentSwap.fromAmount\n                }(currentSwap.callData);\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageNative(_receiver);\n            } else {\n                // ERC20\n                // check if the current allowance is sufficient\n                currentAllowance = sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                );\n                if (currentAllowance < currentSwap.fromAmount) {\n                    sendingAsset.safeApprove(currentSwap.approveTo, 0);\n                    sendingAsset.safeApprove(\n                        currentSwap.approveTo,\n                        type(uint256).max\n                    );\n                }\n\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call(\n                    currentSwap.callData\n                );\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageERC20(sendingAsset, _receiver);\n            }\n\n            // emit AssetSwapped event\n            // @dev: this event might in some cases emit inaccurate information. e.g. if a token is swapped and this contract already held a balance of the receivingAsset\n            //       then the event will show swapOutputAmount + existingBalance as toAmount. We accept this potential inaccuracy in return for gas savings and may update this\n            //       at a later stage when the described use case becomes more common\n            emit LibSwap.AssetSwapped(\n                _transactionId,\n                currentSwap.callTo,\n                sendingAssetId,\n                receivingAssetId,\n                currentSwap.fromAmount,\n                LibAsset.isNativeAsset(receivingAssetId)\n                    ? address(this).balance\n                    : ERC20(receivingAssetId).balanceOf(address(this)),\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _transferERC20TokensAndEmitEvent(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        // determine the end result of the swap\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        uint256 amountReceived = ERC20(finalAssetId).balanceOf(address(this));\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer to receiver\n        ERC20(finalAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            finalAssetId,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }\n\n    function _transferNativeTokensAndEmitEvent(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        uint256 amountReceived = address(this).balance;\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) {\n            revert NativeAssetTransferFailed();\n        }\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            NATIVE_ADDRESS,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }\n\n    // returns any unused 'sendingAsset' tokens (=> positive slippage) to the receiver address\n    function _returnPositiveSlippageERC20(\n        ERC20 sendingAsset,\n        address receiver\n    ) private {\n        // if a balance exists in sendingAsset, it must be positive slippage\n        if (address(sendingAsset) != NATIVE_ADDRESS) {\n            uint256 sendingAssetBalance = sendingAsset.balanceOf(\n                address(this)\n            );\n\n            if (sendingAssetBalance > 0) {\n                sendingAsset.safeTransfer(receiver, sendingAssetBalance);\n            }\n        }\n    }\n\n    // returns any unused native tokens (=> positive slippage) to the receiver address\n    function _returnPositiveSlippageNative(address receiver) private {\n        // if a native balance exists in sendingAsset, it must be positive slippage\n        uint256 nativeBalance = address(this).balance;\n\n        if (nativeBalance > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: nativeBalance }(\"\");\n            if (!success) revert NativeAssetTransferFailed();\n        }\n    }\n}\n"
      },
      "call_graph": {
        "GenericSwapFacetV3": {
          "swapTokensSingleV3ERC20ToERC20": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_depositAndSwapERC20Single"
            }
          ],
          "swapTokensSingleV3ERC20ToNative": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_depositAndSwapERC20Single"
            }
          ],
          "swapTokensSingleV3NativeToERC20": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_returnPositiveSlippageNative"
            }
          ],
          "swapTokensMultipleV3ERC20ToNative": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_depositMultipleERC20Tokens"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_executeSwaps"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_transferNativeTokensAndEmitEvent"
            }
          ],
          "swapTokensMultipleV3ERC20ToERC20": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_depositMultipleERC20Tokens"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_executeSwaps"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_transferERC20TokensAndEmitEvent"
            }
          ],
          "swapTokensMultipleV3NativeToERC20": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_executeSwaps"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_transferERC20TokensAndEmitEvent"
            }
          ],
          "_depositMultipleERC20Tokens": [],
          "_depositAndSwapERC20Single": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_returnPositiveSlippageERC20"
            }
          ],
          "_executeSwaps": [
            {
              "contract": "GenericSwapFacetV3",
              "function": "_returnPositiveSlippageERC20"
            },
            {
              "contract": "GenericSwapFacetV3",
              "function": "_returnPositiveSlippageNative"
            }
          ],
          "_transferERC20TokensAndEmitEvent": [],
          "_transferNativeTokensAndEmitEvent": [],
          "_returnPositiveSlippageERC20": [],
          "_returnPositiveSlippageNative": []
        }
      },
      "flow_data": {
        "GenericSwapFacetV3": {
          "swapTokensSingleV3ERC20ToERC20": {
            "name": "swapTokensSingleV3ERC20ToERC20",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountReceived < _minAmountOut",
                "line": 12
              }
            ],
            "state_changes": [
              {
                "variable": "receivingAssetId",
                "type": "address",
                "value": "_swapData.receivingAssetId",
                "line": 3
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "_swapData.sendingAssetId",
                "line": 4
              },
              {
                "variable": "amountReceived",
                "type": "uint256",
                "value": "ERC20(receivingAssetId).balanceOf(\n            address(this)\n        )",
                "line": 7
              },
              {
                "variable": "fromAmount",
                "type": "uint256",
                "value": "_swapData.fromAmount",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "12": "if (amountReceived < _minAmountOut)",
              "3": "State Change: receivingAssetId = _swapData.receivingAssetId",
              "4": "State Change: sendingAssetId = _swapData.sendingAssetId",
              "7": "State Change: amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        )",
              "19": "State Change: fromAmount = _swapData.fromAmount"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "swapTokensSingleV3ERC20ToNative": {
            "name": "swapTokensSingleV3ERC20ToNative",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountReceived < _minAmountOut",
                "line": 7
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 13
              }
            ],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "_swapData.sendingAssetId",
                "line": 16
              },
              {
                "variable": "amountReceived",
                "type": "uint256",
                "value": "address(this).balance",
                "line": 4
              },
              {
                "variable": "fromAmount",
                "type": "uint256",
                "value": "_swapData.fromAmount",
                "line": 17
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "7": "if (amountReceived < _minAmountOut)",
              "13": "if (!success)",
              "16": "State Change: sendingAssetId = _swapData.sendingAssetId",
              "4": "State Change: amountReceived = address(this).balance",
              "17": "State Change: fromAmount = _swapData.fromAmount"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "swapTokensSingleV3NativeToERC20": {
            "name": "swapTokensSingleV3NativeToERC20",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "!(LibAllowList.contractIsAllowed(callTo",
                "line": 3
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 13
              },
              {
                "type": "if",
                "condition": "amountReceived < _minAmountOut",
                "line": 26
              }
            ],
            "state_changes": [
              {
                "variable": "receivingAssetId",
                "type": "address",
                "value": "_swapData.receivingAssetId",
                "line": 20
              },
              {
                "variable": "amountReceived",
                "type": "uint256",
                "value": "ERC20(receivingAssetId).balanceOf(\n            address(this)\n        )",
                "line": 21
              },
              {
                "variable": "fromAmount",
                "type": "uint256",
                "value": "_swapData.fromAmount",
                "line": 33
              },
              {
                "variable": "callTo",
                "type": "address",
                "value": "_swapData.callTo",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (!(LibAllowList.contractIsAllowed(callTo)",
              "13": "if (!success)",
              "26": "if (amountReceived < _minAmountOut)",
              "20": "State Change: receivingAssetId = _swapData.receivingAssetId",
              "21": "State Change: amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        )",
              "33": "State Change: fromAmount = _swapData.fromAmount",
              "1": "State Change: callTo = _swapData.callTo"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "swapTokensMultipleV3ERC20ToNative": {
            "name": "swapTokensMultipleV3ERC20ToNative",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "swapTokensMultipleV3ERC20ToERC20": {
            "name": "swapTokensMultipleV3ERC20ToERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "swapTokensMultipleV3NativeToERC20": {
            "name": "swapTokensMultipleV3NativeToERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "_depositMultipleERC20Tokens": {
            "name": "_depositMultipleERC20Tokens",
            "visibility": "private",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < numOfSwaps;",
                "line": 6
              },
              {
                "type": "if",
                "condition": "currentSwap.requiresDeposit",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "numOfSwaps",
                "type": "uint256",
                "value": "_swapData.length",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "6": "for (uint256 i = 0; i < numOfSwaps;)",
              "8": "if (currentSwap.requiresDeposit)",
              "2": "State Change: numOfSwaps = _swapData.length"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "_depositAndSwapERC20Single": {
            "name": "_depositAndSwapERC20Single",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "!(LibAllowList.contractIsAllowed(callTo",
                "line": 10
              },
              {
                "type": "if",
                "condition": "approveTo != callTo && !LibAllowList.contractIsAllowed(approveTo",
                "line": 16
              },
              {
                "type": "if",
                "condition": "currentAllowance < fromAmount",
                "line": 26
              },
              {
                "type": "if",
                "condition": "currentAllowance != 0",
                "line": 28
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 36
              }
            ],
            "state_changes": [
              {
                "variable": "fromAmount",
                "type": "uint256",
                "value": "_swapData.fromAmount",
                "line": 2
              },
              {
                "variable": "callTo",
                "type": "address",
                "value": "_swapData.callTo",
                "line": 7
              },
              {
                "variable": "sendingAsset",
                "type": "ERC20",
                "value": "ERC20(_swapData.sendingAssetId)",
                "line": 1
              },
              {
                "variable": "approveTo",
                "type": "address",
                "value": "_swapData.approveTo",
                "line": 8
              },
              {
                "variable": "currentAllowance",
                "type": "uint256",
                "value": "sendingAsset.allowance(\n            address(this),\n            approveTo\n        )",
                "line": 20
              }
            ],
            "external_calls": [
              {
                "target": "callTo",
                "type": "call",
                "arguments": "callData",
                "line": 35
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "10": "if (!(LibAllowList.contractIsAllowed(callTo)",
              "16": "if (approveTo != callTo && !LibAllowList.contractIsAllowed(approveTo)",
              "26": "if (currentAllowance < fromAmount)",
              "28": "if (currentAllowance != 0)",
              "36": "if (!success)",
              "2": "State Change: fromAmount = _swapData.fromAmount",
              "7": "State Change: callTo = _swapData.callTo",
              "1": "State Change: sendingAsset = ERC20(_swapData.sendingAssetId)",
              "8": "State Change: approveTo = _swapData.approveTo",
              "20": "State Change: currentAllowance = sendingAsset.allowance(\n            address(this),\n            approveTo\n        )",
              "35": "External Call: callTo.call(callData)"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "_receiver"
              }
            ],
            "returns": []
          },
          "_executeSwaps": {
            "name": "_executeSwaps",
            "visibility": "private",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < numOfSwaps;",
                "line": 12
              },
              {
                "type": "if",
                "condition": "!LibAllowList.contractIsAllowed(currentSwap.callTo",
                "line": 19
              },
              {
                "type": "if",
                "condition": "currentSwap.approveTo != currentSwap.callTo &&\n                !LibAllowList.contractIsAllowed(currentSwap.approveTo",
                "line": 29
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(sendingAssetId",
                "line": 36
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 42
              },
              {
                "type": "if",
                "condition": "sendingAssetId != receivingAssetId",
                "line": 48
              },
              {
                "type": "if",
                "condition": "currentAllowance < currentSwap.fromAmount",
                "line": 57
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 69
              },
              {
                "type": "if",
                "condition": "sendingAssetId != receivingAssetId",
                "line": 75
              }
            ],
            "state_changes": [
              {
                "variable": "receivingAssetId",
                "type": "address",
                "value": "currentSwap.receivingAssetId",
                "line": 16
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "currentSwap.sendingAssetId",
                "line": 14
              },
              {
                "variable": "numOfSwaps",
                "type": "uint256",
                "value": "_swapData.length",
                "line": 2
              },
              {
                "variable": "sendingAsset",
                "type": "ERC20",
                "value": "ERC20(currentSwap.sendingAssetId)",
                "line": 15
              },
              {
                "variable": "currentAllowance",
                "type": "uint256",
                "value": "sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                )",
                "line": 53
              }
            ],
            "external_calls": [
              {
                "target": "currentSwap",
                "type": "call",
                "arguments": "currentSwap.callData",
                "line": 66
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "12": "for (uint256 i = 0; i < numOfSwaps;)",
              "19": "if (!LibAllowList.contractIsAllowed(currentSwap.callTo)",
              "29": "if (currentSwap.approveTo != currentSwap.callTo &&\n                !LibAllowList.contractIsAllowed(currentSwap.approveTo)",
              "36": "if (LibAsset.isNativeAsset(sendingAssetId)",
              "42": "if (!success)",
              "48": "if (sendingAssetId != receivingAssetId)",
              "57": "if (currentAllowance < currentSwap.fromAmount)",
              "69": "if (!success)",
              "75": "if (sendingAssetId != receivingAssetId)",
              "16": "State Change: receivingAssetId = currentSwap.receivingAssetId",
              "14": "State Change: sendingAssetId = currentSwap.sendingAssetId",
              "2": "State Change: numOfSwaps = _swapData.length",
              "15": "State Change: sendingAsset = ERC20(currentSwap.sendingAssetId)",
              "53": "State Change: currentAllowance = sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                )",
              "66": "External Call: currentSwap.call(currentSwap.callData)"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "address",
                "name": "_receiver"
              }
            ],
            "returns": []
          },
          "_transferERC20TokensAndEmitEvent": {
            "name": "_transferERC20TokensAndEmitEvent",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountReceived < _minAmountOut",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "amountReceived",
                "type": "uint256",
                "value": "ERC20(finalAssetId).balanceOf(address(this))",
                "line": 4
              },
              {
                "variable": "finalAssetId",
                "type": "address",
                "value": "_swapData[_swapData.length - 1]\n            .receivingAssetId",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "7": "if (amountReceived < _minAmountOut)",
              "4": "State Change: amountReceived = ERC20(finalAssetId).balanceOf(address(this))",
              "2": "State Change: finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "_transferNativeTokensAndEmitEvent": {
            "name": "_transferNativeTokensAndEmitEvent",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountReceived < _minAmountOut",
                "line": 4
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 10
              }
            ],
            "state_changes": [
              {
                "variable": "amountReceived",
                "type": "uint256",
                "value": "address(this).balance",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (amountReceived < _minAmountOut)",
              "10": "if (!success)",
              "1": "State Change: amountReceived = address(this).balance"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "string",
                "name": "_integrator"
              },
              {
                "type": "string",
                "name": "_referrer"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_minAmountOut"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": []
          },
          "_returnPositiveSlippageERC20": {
            "name": "_returnPositiveSlippageERC20",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "address(sendingAsset",
                "line": 2
              },
              {
                "type": "if",
                "condition": "sendingAssetBalance > 0",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "sendingAssetBalance",
                "type": "uint256",
                "value": "sendingAsset.balanceOf(\n                address(this)\n            )",
                "line": 3
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (address(sendingAsset)",
              "7": "if (sendingAssetBalance > 0)",
              "3": "State Change: sendingAssetBalance = sendingAsset.balanceOf(\n                address(this)\n            )"
            },
            "parameters": [
              {
                "type": "ERC20",
                "name": "sendingAsset"
              },
              {
                "type": "address",
                "name": "receiver"
              }
            ],
            "returns": []
          },
          "_returnPositiveSlippageNative": {
            "name": "_returnPositiveSlippageNative",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "nativeBalance > 0",
                "line": 4
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "nativeBalance",
                "type": "uint256",
                "value": "address(this).balance",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (nativeBalance > 0)",
              "7": "if (!success)",
              "2": "State Change: nativeBalance = address(this).balance"
            },
            "parameters": [
              {
                "type": "address",
                "name": "receiver"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "GenericSwapFacetV3": {
          "swapTokensSingleV3ERC20ToERC20": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_depositAndSwapERC20Single",
                "state_changes": [
                  {
                    "variable": "fromAmount",
                    "type": "uint256",
                    "value": "_swapData.fromAmount",
                    "line": 2
                  },
                  {
                    "variable": "callTo",
                    "type": "address",
                    "value": "_swapData.callTo",
                    "line": 7
                  },
                  {
                    "variable": "sendingAsset",
                    "type": "ERC20",
                    "value": "ERC20(_swapData.sendingAssetId)",
                    "line": 1
                  },
                  {
                    "variable": "approveTo",
                    "type": "address",
                    "value": "_swapData.approveTo",
                    "line": 8
                  },
                  {
                    "variable": "currentAllowance",
                    "type": "uint256",
                    "value": "sendingAsset.allowance(\n            address(this),\n            approveTo\n        )",
                    "line": 20
                  }
                ],
                "external_calls": [
                  {
                    "target": "callTo",
                    "type": "call",
                    "arguments": "callData",
                    "line": 35
                  }
                ],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_depositAndSwapERC20Single": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_returnPositiveSlippageERC20",
                "state_changes": [
                  {
                    "variable": "sendingAssetBalance",
                    "type": "uint256",
                    "value": "sendingAsset.balanceOf(\n                address(this)\n            )",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapTokensSingleV3ERC20ToNative": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_depositAndSwapERC20Single",
                "state_changes": [
                  {
                    "variable": "fromAmount",
                    "type": "uint256",
                    "value": "_swapData.fromAmount",
                    "line": 2
                  },
                  {
                    "variable": "callTo",
                    "type": "address",
                    "value": "_swapData.callTo",
                    "line": 7
                  },
                  {
                    "variable": "sendingAsset",
                    "type": "ERC20",
                    "value": "ERC20(_swapData.sendingAssetId)",
                    "line": 1
                  },
                  {
                    "variable": "approveTo",
                    "type": "address",
                    "value": "_swapData.approveTo",
                    "line": 8
                  },
                  {
                    "variable": "currentAllowance",
                    "type": "uint256",
                    "value": "sendingAsset.allowance(\n            address(this),\n            approveTo\n        )",
                    "line": 20
                  }
                ],
                "external_calls": [
                  {
                    "target": "callTo",
                    "type": "call",
                    "arguments": "callData",
                    "line": 35
                  }
                ],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapTokensSingleV3NativeToERC20": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_returnPositiveSlippageNative",
                "state_changes": [
                  {
                    "variable": "nativeBalance",
                    "type": "uint256",
                    "value": "address(this).balance",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_returnPositiveSlippageNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapTokensMultipleV3ERC20ToNative": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_depositMultipleERC20Tokens",
                "state_changes": [
                  {
                    "variable": "numOfSwaps",
                    "type": "uint256",
                    "value": "_swapData.length",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_executeSwaps",
                "state_changes": [
                  {
                    "variable": "receivingAssetId",
                    "type": "address",
                    "value": "currentSwap.receivingAssetId",
                    "line": 16
                  },
                  {
                    "variable": "sendingAssetId",
                    "type": "address",
                    "value": "currentSwap.sendingAssetId",
                    "line": 14
                  },
                  {
                    "variable": "numOfSwaps",
                    "type": "uint256",
                    "value": "_swapData.length",
                    "line": 2
                  },
                  {
                    "variable": "sendingAsset",
                    "type": "ERC20",
                    "value": "ERC20(currentSwap.sendingAssetId)",
                    "line": 15
                  },
                  {
                    "variable": "currentAllowance",
                    "type": "uint256",
                    "value": "sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                )",
                    "line": 53
                  }
                ],
                "external_calls": [
                  {
                    "target": "currentSwap",
                    "type": "call",
                    "arguments": "currentSwap.callData",
                    "line": 66
                  }
                ],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_transferNativeTokensAndEmitEvent",
                "state_changes": [
                  {
                    "variable": "amountReceived",
                    "type": "uint256",
                    "value": "address(this).balance",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_depositMultipleERC20Tokens": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_executeSwaps": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_returnPositiveSlippageERC20",
                "state_changes": [
                  {
                    "variable": "sendingAssetBalance",
                    "type": "uint256",
                    "value": "sendingAsset.balanceOf(\n                address(this)\n            )",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_returnPositiveSlippageNative",
                "state_changes": [
                  {
                    "variable": "nativeBalance",
                    "type": "uint256",
                    "value": "address(this).balance",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_transferNativeTokensAndEmitEvent": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapTokensMultipleV3ERC20ToERC20": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_depositMultipleERC20Tokens",
                "state_changes": [
                  {
                    "variable": "numOfSwaps",
                    "type": "uint256",
                    "value": "_swapData.length",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_executeSwaps",
                "state_changes": [
                  {
                    "variable": "receivingAssetId",
                    "type": "address",
                    "value": "currentSwap.receivingAssetId",
                    "line": 16
                  },
                  {
                    "variable": "sendingAssetId",
                    "type": "address",
                    "value": "currentSwap.sendingAssetId",
                    "line": 14
                  },
                  {
                    "variable": "numOfSwaps",
                    "type": "uint256",
                    "value": "_swapData.length",
                    "line": 2
                  },
                  {
                    "variable": "sendingAsset",
                    "type": "ERC20",
                    "value": "ERC20(currentSwap.sendingAssetId)",
                    "line": 15
                  },
                  {
                    "variable": "currentAllowance",
                    "type": "uint256",
                    "value": "sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                )",
                    "line": 53
                  }
                ],
                "external_calls": [
                  {
                    "target": "currentSwap",
                    "type": "call",
                    "arguments": "currentSwap.callData",
                    "line": 66
                  }
                ],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_transferERC20TokensAndEmitEvent",
                "state_changes": [
                  {
                    "variable": "amountReceived",
                    "type": "uint256",
                    "value": "ERC20(finalAssetId).balanceOf(address(this))",
                    "line": 4
                  },
                  {
                    "variable": "finalAssetId",
                    "type": "address",
                    "value": "_swapData[_swapData.length - 1]\n            .receivingAssetId",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_transferERC20TokensAndEmitEvent": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapTokensMultipleV3NativeToERC20": {
            "calls": [
              {
                "contract": "GenericSwapFacetV3",
                "function": "_executeSwaps",
                "state_changes": [
                  {
                    "variable": "receivingAssetId",
                    "type": "address",
                    "value": "currentSwap.receivingAssetId",
                    "line": 16
                  },
                  {
                    "variable": "sendingAssetId",
                    "type": "address",
                    "value": "currentSwap.sendingAssetId",
                    "line": 14
                  },
                  {
                    "variable": "numOfSwaps",
                    "type": "uint256",
                    "value": "_swapData.length",
                    "line": 2
                  },
                  {
                    "variable": "sendingAsset",
                    "type": "ERC20",
                    "value": "ERC20(currentSwap.sendingAssetId)",
                    "line": 15
                  },
                  {
                    "variable": "currentAllowance",
                    "type": "uint256",
                    "value": "sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                )",
                    "line": 53
                  }
                ],
                "external_calls": [
                  {
                    "target": "currentSwap",
                    "type": "call",
                    "arguments": "currentSwap.callData",
                    "line": 66
                  }
                ],
                "value_transfers": []
              },
              {
                "contract": "GenericSwapFacetV3",
                "function": "_transferERC20TokensAndEmitEvent",
                "state_changes": [
                  {
                    "variable": "amountReceived",
                    "type": "uint256",
                    "value": "ERC20(finalAssetId).balanceOf(address(this))",
                    "line": 4
                  },
                  {
                    "variable": "finalAssetId",
                    "type": "address",
                    "value": "_swapData[_swapData.length - 1]\n            .receivingAssetId",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_returnPositiveSlippageERC20": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.700290"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.722464"
      },
      "final_report": {
        "file_id": "GenericSwapFacetV3.sol",
        "timestamp": "2025-03-11T07:05:50.722488",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "GenericSwapFacetV3": {
            "functions": 13,
            "state_variables": 13,
            "inheritance": [
              "ILiFi"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GenericSwapFacetV3.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.722502"
    },
    "GnosisBridgeFacet.sol": {
      "file_id": "GnosisBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "GnosisBridgeFacet": {
            "name": "GnosisBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibAsset.maxApproveERC20(\n            IERC20(DAI),\n            address(xDaiBridge),\n            _bridgeData.minAmount\n        );\n        xDaiBridge.relayTokens(_bridgeData.receiver, _bridgeData.minAmount);\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IXDaiBridge } from \"../Interfaces/IXDaiBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Gnosis Bridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through XDaiBridge\n/// @custom:version 1.0.0\ncontract GnosisBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The DAI address on the source chain.\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    /// @notice The chain id of Gnosis.\n    uint64 private constant GNOSIS_CHAIN_ID = 100;\n\n    /// @notice The contract address of the xdai bridge on the source chain.\n    IXDaiBridge private immutable xDaiBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _xDaiBridge The contract address of the xdai bridge on the source chain.\n    constructor(IXDaiBridge _xDaiBridge) {\n        xDaiBridge = _xDaiBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        LibAsset.depositAsset(DAI, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapAndStartBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        LibAsset.maxApproveERC20(\n            IERC20(DAI),\n            address(xDaiBridge),\n            _bridgeData.minAmount\n        );\n        xDaiBridge.relayTokens(_bridgeData.receiver, _bridgeData.minAmount);\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "GnosisBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "GnosisBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "GnosisBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.702498"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.722602"
      },
      "final_report": {
        "file_id": "GnosisBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.722618",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "GnosisBridgeFacet": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GnosisBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.722628"
    },
    "HopFacet.sol": {
      "file_id": "HopFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "HopFacet": {
            "name": "HopFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "initHop": {
                "name": "initHop",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "Config[]",
                    "name": "configs"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);\n        }\n\n        emit HopInitialized(configs);\n    }"
              },
              "registerBridge": {
                "name": "registerBridge",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "bridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IHopBridge(bridge);\n\n        emit HopBridgeRegistered(assetId, bridge);\n    }"
              },
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address sendingAssetId = _bridgeData.sendingAssetId;\n        Storage storage s = getStorage();\n        IHopBridge bridge = s.bridges[sendingAssetId];\n\n        // Give Hop approval to bridge tokens\n        LibAsset.maxApproveERC20(\n            IERC20(sendingAssetId),\n            address(bridge),\n            _bridgeData.minAmount\n        );\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee;\n\n        if (block.chainid == 1 || block.chainid == 5) {\n            // Ethereum L1\n            bridge.sendToL2{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                _hopData.relayer,\n                _hopData.relayerFee\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            bridge.swapAndSend{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "initialized": {
                "name": "initialized",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "assetId": {
                "name": "assetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "bridge": {
                "name": "bridge",
                "type": "IHopBridge",
                "visibility": "internal",
                "initial_value": "s.bridges[sendingAssetId]"
              },
              "bonderFee": {
                "name": "bonderFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "amountOutMin": {
                "name": "amountOutMin",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "deadline": {
                "name": "deadline",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationAmountOutMin": {
                "name": "destinationAmountOutMin",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationDeadline": {
                "name": "destinationDeadline",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "relayer": {
                "name": "relayer",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "relayerFee": {
                "name": "relayerFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "nativeFee": {
                "name": "nativeFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_bridgeData.sendingAssetId"
              },
              "value": {
                "name": "value",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee"
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Hop Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IHopBridge) bridges;\n        bool initialized; // no longer used but kept here to maintain the same storage layout\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// Events ///\n\n    event HopInitialized(Config[] configs);\n    event HopBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Hop Facet\n    /// @param configs Bridge configuration data\n    function initHop(Config[] calldata configs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);\n        }\n\n        emit HopInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IHopBridge(bridge);\n\n        emit HopBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// @notice Performs a swap before bridging via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    ) private {\n        address sendingAssetId = _bridgeData.sendingAssetId;\n        Storage storage s = getStorage();\n        IHopBridge bridge = s.bridges[sendingAssetId];\n\n        // Give Hop approval to bridge tokens\n        LibAsset.maxApproveERC20(\n            IERC20(sendingAssetId),\n            address(bridge),\n            _bridgeData.minAmount\n        );\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee;\n\n        if (block.chainid == 1 || block.chainid == 5) {\n            // Ethereum L1\n            bridge.sendToL2{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                _hopData.relayer,\n                _hopData.relayerFee\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            bridge.swapAndSend{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "HopFacet": {
          "initHop": [
            {
              "contract": "HopFacet",
              "function": "getStorage"
            }
          ],
          "registerBridge": [
            {
              "contract": "HopFacet",
              "function": "getStorage"
            }
          ],
          "_startBridge": [
            {
              "contract": "HopFacet",
              "function": "getStorage"
            }
          ],
          "getStorage": []
        }
      },
      "flow_data": {
        "HopFacet": {
          "initHop": {
            "name": "initHop",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < configs.length; i++",
                "line": 5
              },
              {
                "type": "if",
                "condition": "configs[i].bridge == address(0",
                "line": 6
              }
            ],
            "state_changes": [
              {
                "variable": "bridge",
                "type": "IHopBridge",
                "value": "= address(0)) {\n                revert InvalidConfig()",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "for (uint256 i = 0; i < configs.length; i++)",
              "6": "State Change: bridge = = address(0)) {\n                revert InvalidConfig()"
            },
            "parameters": [
              {
                "type": "Config[]",
                "name": "configs"
              }
            ],
            "returns": []
          },
          "registerBridge": {
            "name": "registerBridge",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "bridge == address(0",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "bridge",
                "type": "IHopBridge",
                "value": "= address(0)) {\n            revert InvalidConfig()",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "State Change: bridge = = address(0)) {\n            revert InvalidConfig()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "bridge"
              }
            ],
            "returns": []
          },
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "block.chainid == 1 || block.chainid == 5",
                "line": 16
              }
            ],
            "state_changes": [
              {
                "variable": "bridge",
                "type": "IHopBridge",
                "value": "s.bridges[sendingAssetId]",
                "line": 3
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "_bridgeData.sendingAssetId",
                "line": 1
              },
              {
                "variable": "value",
                "type": "uint256",
                "value": "LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee",
                "line": 12
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "16": "if (block.chainid == 1 || block.chainid == 5)",
              "3": "State Change: bridge = s.bridges[sendingAssetId]",
              "1": "State Change: sendingAssetId = _bridgeData.sendingAssetId",
              "12": "State Change: value = LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "HopFacet": {
          "initHop": {
            "calls": [
              {
                "contract": "HopFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "registerBridge": {
            "calls": [
              {
                "contract": "HopFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_startBridge": {
            "calls": [
              {
                "contract": "HopFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.728930"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.736155"
      },
      "final_report": {
        "file_id": "HopFacet.sol",
        "timestamp": "2025-03-11T07:05:50.736179",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "HopFacet": {
            "functions": 4,
            "state_variables": 14,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of HopFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.736191"
    },
    "HopFacetOptimized.sol": {
      "file_id": "HopFacetOptimized.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "HopFacetOptimized": {
            "name": "HopFacetOptimized",
            "inheritance": [
              "ILiFi",
              "SwapperV2"
            ],
            "functions": {
              "setApprovalForBridges": {
                "name": "setApprovalForBridges",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address[]",
                    "name": "bridges"
                  },
                  {
                    "type": "address[]",
                    "name": "tokensToApprove"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        for (uint256 i; i < bridges.length; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }"
              },
              "startBridgeTokensViaHopL1ERC20": {
                "name": "startBridgeTokensViaHopL1ERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "startBridgeTokensViaHopL1Native": {
                "name": "startBridgeTokensViaHopL1Native",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "swapAndStartBridgeTokensViaHopL1ERC20": {
                "name": "swapAndStartBridgeTokensViaHopL1ERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "swapAndStartBridgeTokensViaHopL1Native": {
                "name": "swapAndStartBridgeTokensViaHopL1Native",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "startBridgeTokensViaHopL2ERC20": {
                "name": "startBridgeTokensViaHopL2ERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "startBridgeTokensViaHopL2Native": {
                "name": "startBridgeTokensViaHopL2Native",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "swapAndStartBridgeTokensViaHopL2ERC20": {
                "name": "swapAndStartBridgeTokensViaHopL2ERC20",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "swapAndStartBridgeTokensViaHopL2Native": {
                "name": "swapAndStartBridgeTokensViaHopL2Native",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "HopData",
                    "name": "_hopData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "bonderFee": {
                "name": "bonderFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "amountOutMin": {
                "name": "amountOutMin",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "deadline": {
                "name": "deadline",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationAmountOutMin": {
                "name": "destinationAmountOutMin",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationDeadline": {
                "name": "destinationDeadline",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "hopBridge": {
                "name": "hopBridge",
                "type": "IHopBridge",
                "visibility": "internal",
                "initial_value": null
              },
              "relayer": {
                "name": "relayer",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "relayerFee": {
                "name": "relayerFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "nativeFee": {
                "name": "nativeFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Hop Facet (Optimized)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacetOptimized is ILiFi, SwapperV2 {\n    /// Types ///\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        IHopBridge hopBridge;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// External Methods ///\n\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        for (uint256 i; i < bridges.length; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "HopFacetOptimized": {
          "setApprovalForBridges": [],
          "startBridgeTokensViaHopL1ERC20": [],
          "startBridgeTokensViaHopL1Native": [],
          "swapAndStartBridgeTokensViaHopL1ERC20": [],
          "swapAndStartBridgeTokensViaHopL1Native": [],
          "startBridgeTokensViaHopL2ERC20": [],
          "startBridgeTokensViaHopL2Native": [],
          "swapAndStartBridgeTokensViaHopL2ERC20": [],
          "swapAndStartBridgeTokensViaHopL2Native": []
        }
      },
      "flow_data": {
        "HopFacetOptimized": {
          "setApprovalForBridges": {
            "name": "setApprovalForBridges",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i; i < bridges.length; i++",
                "line": 2
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "for (uint256 i; i < bridges.length; i++)"
            },
            "parameters": [
              {
                "type": "address[]",
                "name": "bridges"
              },
              {
                "type": "address[]",
                "name": "tokensToApprove"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaHopL1ERC20": {
            "name": "startBridgeTokensViaHopL1ERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaHopL1Native": {
            "name": "startBridgeTokensViaHopL1Native",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "swapAndStartBridgeTokensViaHopL1ERC20": {
            "name": "swapAndStartBridgeTokensViaHopL1ERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "swapAndStartBridgeTokensViaHopL1Native": {
            "name": "swapAndStartBridgeTokensViaHopL1Native",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaHopL2ERC20": {
            "name": "startBridgeTokensViaHopL2ERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "startBridgeTokensViaHopL2Native": {
            "name": "startBridgeTokensViaHopL2Native",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "swapAndStartBridgeTokensViaHopL2ERC20": {
            "name": "swapAndStartBridgeTokensViaHopL2ERC20",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          },
          "swapAndStartBridgeTokensViaHopL2Native": {
            "name": "swapAndStartBridgeTokensViaHopL2Native",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "HopData",
                "name": "_hopData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "HopFacetOptimized": {
          "setApprovalForBridges": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL1ERC20": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL1Native": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapAndStartBridgeTokensViaHopL1ERC20": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapAndStartBridgeTokensViaHopL1Native": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL2ERC20": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL2Native": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapAndStartBridgeTokensViaHopL2ERC20": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swapAndStartBridgeTokensViaHopL2Native": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.736376"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.742177"
      },
      "final_report": {
        "file_id": "HopFacetOptimized.sol",
        "timestamp": "2025-03-11T07:05:50.742204",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "HopFacetOptimized": {
            "functions": 9,
            "state_variables": 9,
            "inheritance": [
              "ILiFi",
              "SwapperV2"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of HopFacetOptimized.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.742218"
    },
    "HopFacetPacked.sol": {
      "file_id": "HopFacetPacked.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "HopFacetPacked": {
            "name": "HopFacetPacked",
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ],
            "functions": {
              "startBridgeTokensViaHopL2NativePacked": {
                "name": "startBridgeTokensViaHopL2NativePacked",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[36:52]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[52:68])))\n        // => total calldata length required: 68\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[52:68])));\n        bool toL1 = destinationChainId == 1;\n\n        // Wrap ETH\n        WETH(payable(nativeL2CanonicalToken)).deposit{ value: msg.value }();\n\n        // Exchange WETH for hToken\n        uint256 swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(nativeBridge).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])), // receiver\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[36:52]))), // bonderFee\n            toL1 ? 0 : amountOutMin,\n            toL1 ? 0 : block.timestamp + 7 * 24 * 60 * 60\n        );\n\n        emit LiFiHopTransfer(\n            bytes8(msg.data[4:12]) // transactionId\n        );\n    }"
              },
              "startBridgeTokensViaHopL2NativeMin": {
                "name": "startBridgeTokensViaHopL2NativeMin",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint256",
                    "name": "bonderFee"
                  },
                  {
                    "type": "uint256",
                    "name": "amountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationDeadline"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Bridge assets\n        IHopBridge(hopBridge).swapAndSend{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }"
              },
              "encode_startBridgeTokensViaHopL2NativePacked": {
                "name": "encode_startBridgeTokensViaHopL2NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint256",
                    "name": "bonderFee"
                  },
                  {
                    "type": "uint256",
                    "name": "amountOutMin"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin))\n            );\n    }"
              },
              "decode_startBridgeTokensViaHopL2NativePacked": {
                "name": "decode_startBridgeTokensViaHopL2NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "HopFacetOptimized.HopData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 68,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[36:52])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[52:68])));\n\n        return (bridgeData, hopData);\n    }"
              },
              "startBridgeTokensViaHopL2ERC20Packed": {
                "name": "startBridgeTokensViaHopL2ERC20Packed",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[88:104]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[104:120]))),\n        // destinationDeadline: uint256(uint32(bytes4(msg.data[120:124]))),\n        // wrapper: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[88:104])));\n        bool toL1 = destinationChainId == 1;\n\n        IL2AmmWrapper wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        );\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Exchange sending asset to hToken\n        uint256 swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(wrapper.bridge()).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])),\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            toL1 ? 0 : uint256(uint128(bytes16(msg.data[104:120]))),\n            toL1 ? 0 : uint256(uint32(bytes4(msg.data[120:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaHopL2ERC20Min": {
                "name": "startBridgeTokensViaHopL2ERC20Min",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "bonderFee"
                  },
                  {
                    "type": "uint256",
                    "name": "amountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationDeadline"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend(\n            destinationChainId,\n            receiver,\n            minAmount,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }"
              },
              "encode_startBridgeTokensViaHopL2ERC20Packed": {
                "name": "encode_startBridgeTokensViaHopL2ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "bonderFee"
                  },
                  {
                    "type": "uint256",
                    "name": "amountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationDeadline"
                  },
                  {
                    "type": "address",
                    "name": "wrapper"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationDeadline <= type(uint32).max,\n            \"destinationDeadline value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes4(uint32(destinationDeadline)),\n                bytes20(wrapper)\n            );\n    }"
              },
              "decode_startBridgeTokensViaHopL2ERC20Packed": {
                "name": "decode_startBridgeTokensViaHopL2ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "HopFacetOptimized.HopData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[88:104])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[104:120]))\n        );\n        hopData.destinationDeadline = uint256(uint32(bytes4(_data[120:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }"
              },
              "startBridgeTokensViaHopL1NativePacked": {
                "name": "startBridgeTokensViaHopL1NativePacked",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[36:52]))),\n        // relayer: address(bytes20(msg.data[52:72])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // hopBridge: address(bytes20(msg.data[88:108]))\n        // => total calldata length required: 108\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[88:108]))).sendToL2{\n            value: msg.value\n        }(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            msg.value,\n            uint256(uint128(bytes16(msg.data[36:52]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[52:72])),\n            uint256(uint128(bytes16(msg.data[72:88])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaHopL1NativeMin": {
                "name": "startBridgeTokensViaHopL1NativeMin",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "address",
                    "name": "relayer"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Bridge assets\n        IHopBridge(hopBridge).sendToL2{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }"
              },
              "encode_startBridgeTokensViaHopL1NativePacked": {
                "name": "encode_startBridgeTokensViaHopL1NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "address",
                    "name": "relayer"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }"
              },
              "decode_startBridgeTokensViaHopL1NativePacked": {
                "name": "decode_startBridgeTokensViaHopL1NativePacked",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "HopFacetOptimized.HopData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 108,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[36:52]))\n        );\n        // relayer = address(bytes20(_data[52:72]));\n        // relayerFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[88:108])));\n\n        return (bridgeData, hopData);\n    }"
              },
              "startBridgeTokensViaHopL1ERC20Packed": {
                "name": "startBridgeTokensViaHopL1ERC20Packed",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[72:88]))),\n        // relayer: address(bytes20(msg.data[88:108])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[108:124]))),\n        // hopBridge: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[124:144]))).sendToL2(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            amount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[88:108])),\n            uint256(uint128(bytes16(msg.data[108:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }"
              },
              "startBridgeTokensViaHopL1ERC20Min": {
                "name": "startBridgeTokensViaHopL1ERC20Min",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "address",
                    "name": "relayer"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2(\n            destinationChainId,\n            receiver,\n            minAmount,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }"
              },
              "encode_startBridgeTokensViaHopL1ERC20Packed": {
                "name": "encode_startBridgeTokensViaHopL1ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes8",
                    "name": "transactionId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationChainId"
                  },
                  {
                    "type": "address",
                    "name": "sendingAssetId"
                  },
                  {
                    "type": "uint256",
                    "name": "minAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "destinationAmountOutMin"
                  },
                  {
                    "type": "address",
                    "name": "relayer"
                  },
                  {
                    "type": "uint256",
                    "name": "relayerFee"
                  },
                  {
                    "type": "address",
                    "name": "hopBridge"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }"
              },
              "decode_startBridgeTokensViaHopL1ERC20Packed": {
                "name": "decode_startBridgeTokensViaHopL1ERC20Packed",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_data"
                  }
                ],
                "returns": [
                  {
                    "type": "BridgeData memory"
                  },
                  {
                    "type": "HopFacetOptimized.HopData memory"
                  }
                ],
                "modifiers": [],
                "code": "require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[72:88]))\n        );\n        // relayer = address(bytes20(_data[88:108]));\n        // relayerFee = uint256(uint128(bytes16(_data[108:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }"
              }
            },
            "state_variables": {
              "wrapperIsSet": {
                "name": "wrapperIsSet",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "_wrapper != address(0)"
              },
              "numBridges": {
                "name": "numBridges",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "bridges.length"
              },
              "destinationChainId": {
                "name": "destinationChainId",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint32(bytes4(msg.data[32:36])))"
              },
              "amountOutMin": {
                "name": "amountOutMin",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[88:104])))"
              },
              "toL1": {
                "name": "toL1",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "destinationChainId == 1"
              },
              "swapAmount": {
                "name": "swapAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        )"
              },
              "amount": {
                "name": "amount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "uint256(uint128(bytes16(msg.data[56:72])))"
              },
              "wrapper": {
                "name": "wrapper",
                "type": "IL2AmmWrapper",
                "visibility": "internal",
                "initial_value": "IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        )"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// // SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IHopBridge, IL2AmmWrapper, ISwap } from \"../Interfaces/IHopBridge.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { HopFacetOptimized } from \"lifi/Facets/HopFacetOptimized.sol\";\nimport { WETH } from \"solmate/tokens/WETH.sol\";\n\n/// @title Hop Facet (Optimized for Rollups)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 1.0.6\ncontract HopFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    address public immutable nativeBridge;\n    address public immutable nativeL2CanonicalToken;\n    address public immutable nativeHToken;\n    address public immutable nativeExchangeAddress;\n\n    /// Errors ///\n\n    error Invalid();\n\n    /// Events ///\n\n    event LiFiHopTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _owner The contract owner to approve tokens.\n    /// @param _wrapper The address of Hop L2_AmmWrapper for native asset.\n    constructor(\n        address _owner,\n        address _wrapper\n    ) TransferrableOwnership(_owner) {\n        bool wrapperIsSet = _wrapper != address(0);\n\n        if (block.chainid == 1 && wrapperIsSet) {\n            revert Invalid();\n        }\n\n        nativeL2CanonicalToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).l2CanonicalToken()\n            : address(0);\n        nativeHToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).hToken()\n            : address(0);\n        nativeExchangeAddress = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).exchangeAddress()\n            : address(0);\n        nativeBridge = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).bridge()\n            : address(0);\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForHopBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numBridges = bridges.length;\n\n        for (uint256 i; i < numBridges; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[36:52]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[52:68])))\n        // => total calldata length required: 68\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[52:68])));\n        bool toL1 = destinationChainId == 1;\n\n        // Wrap ETH\n        WETH(payable(nativeL2CanonicalToken)).deposit{ value: msg.value }();\n\n        // Exchange WETH for hToken\n        uint256 swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(nativeBridge).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])), // receiver\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[36:52]))), // bonderFee\n            toL1 ? 0 : amountOutMin,\n            toL1 ? 0 : block.timestamp + 7 * 24 * 60 * 60\n        );\n\n        emit LiFiHopTransfer(\n            bytes8(msg.data[4:12]) // transactionId\n        );\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    function encode_startBridgeTokensViaHopL2NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 68,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[36:52])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[52:68])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2ERC20Packed() external {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[88:104]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[104:120]))),\n        // destinationDeadline: uint256(uint32(bytes4(msg.data[120:124]))),\n        // wrapper: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[88:104])));\n        bool toL1 = destinationChainId == 1;\n\n        IL2AmmWrapper wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        );\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Exchange sending asset to hToken\n        uint256 swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(wrapper.bridge()).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])),\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            toL1 ? 0 : uint256(uint128(bytes16(msg.data[104:120]))),\n            toL1 ? 0 : uint256(uint32(bytes4(msg.data[120:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend(\n            destinationChainId,\n            receiver,\n            minAmount,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param wrapper Address of the Hop L2_AmmWrapper\n    function encode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address wrapper\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationDeadline <= type(uint32).max,\n            \"destinationDeadline value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes4(uint32(destinationDeadline)),\n                bytes20(wrapper)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[88:104])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[104:120]))\n        );\n        hopData.destinationDeadline = uint256(uint32(bytes4(_data[120:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[36:52]))),\n        // relayer: address(bytes20(msg.data[52:72])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // hopBridge: address(bytes20(msg.data[88:108]))\n        // => total calldata length required: 108\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[88:108]))).sendToL2{\n            value: msg.value\n        }(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            msg.value,\n            uint256(uint128(bytes16(msg.data[36:52]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[52:72])),\n            uint256(uint128(bytes16(msg.data[72:88])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 108,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[36:52]))\n        );\n        // relayer = address(bytes20(_data[52:72]));\n        // relayerFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[88:108])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1ERC20Packed() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[72:88]))),\n        // relayer: address(bytes20(msg.data[88:108])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[108:124]))),\n        // hopBridge: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[124:144]))).sendToL2(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            amount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[88:108])),\n            uint256(uint128(bytes16(msg.data[108:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2(\n            destinationChainId,\n            receiver,\n            minAmount,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[72:88]))\n        );\n        // relayer = address(bytes20(_data[88:108]));\n        // relayerFee = uint256(uint128(bytes16(_data[108:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n}\n"
      },
      "call_graph": {
        "HopFacetPacked": {
          "startBridgeTokensViaHopL2NativePacked": [],
          "startBridgeTokensViaHopL2NativeMin": [],
          "encode_startBridgeTokensViaHopL2NativePacked": [],
          "decode_startBridgeTokensViaHopL2NativePacked": [],
          "startBridgeTokensViaHopL2ERC20Packed": [],
          "startBridgeTokensViaHopL2ERC20Min": [],
          "encode_startBridgeTokensViaHopL2ERC20Packed": [],
          "decode_startBridgeTokensViaHopL2ERC20Packed": [],
          "startBridgeTokensViaHopL1NativePacked": [],
          "startBridgeTokensViaHopL1NativeMin": [],
          "encode_startBridgeTokensViaHopL1NativePacked": [],
          "decode_startBridgeTokensViaHopL1NativePacked": [],
          "startBridgeTokensViaHopL1ERC20Packed": [],
          "startBridgeTokensViaHopL1ERC20Min": [],
          "encode_startBridgeTokensViaHopL1ERC20Packed": [],
          "decode_startBridgeTokensViaHopL1ERC20Packed": []
        }
      },
      "flow_data": {
        "HopFacetPacked": {
          "startBridgeTokensViaHopL2NativePacked": {
            "name": "startBridgeTokensViaHopL2NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(msg.data[32:36])))",
                "line": 9
              },
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "= 1",
                "line": 11
              },
              {
                "variable": "amountOutMin",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[52:68])))",
                "line": 10
              },
              {
                "variable": "toL1",
                "type": "bool",
                "value": "destinationChainId == 1",
                "line": 11
              },
              {
                "variable": "swapAmount",
                "type": "uint256",
                "value": "ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        )",
                "line": 17
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "9": "State Change: destinationChainId = uint256(uint32(bytes4(msg.data[32:36])))",
              "11": "State Change: toL1 = destinationChainId == 1",
              "10": "State Change: amountOutMin = uint256(uint128(bytes16(msg.data[52:68])))",
              "17": "State Change: swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        )"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaHopL2NativeMin": {
            "name": "startBridgeTokensViaHopL2NativeMin",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "uint256",
                "name": "bonderFee"
              },
              {
                "type": "uint256",
                "name": "amountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationDeadline"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaHopL2NativePacked": {
            "name": "encode_startBridgeTokensViaHopL2NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "bonderFee <= type(uint128",
                "line": 5
              },
              {
                "type": "require",
                "condition": "amountOutMin <= type(uint128",
                "line": 9
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(bonderFee <= type(uint128)",
              "9": "require(amountOutMin <= type(uint128)"
            },
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "uint256",
                "name": "bonderFee"
              },
              {
                "type": "uint256",
                "name": "amountOutMin"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL2NativePacked": {
            "name": "decode_startBridgeTokensViaHopL2NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(_data[32:36])))",
                "line": 11
              },
              {
                "variable": "amountOutMin",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(_data[52:68])))",
                "line": 13
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 68,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "11": "State Change: destinationChainId = uint256(uint32(bytes4(_data[32:36])))",
              "13": "State Change: amountOutMin = uint256(uint128(bytes16(_data[52:68])))",
              "1": "require(_data.length >= 68,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "HopFacetOptimized.HopData memory"
              }
            ]
          },
          "startBridgeTokensViaHopL2ERC20Packed": {
            "name": "startBridgeTokensViaHopL2ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(msg.data[32:36])))",
                "line": 14
              },
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "= 1",
                "line": 17
              },
              {
                "variable": "amountOutMin",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[88:104])))",
                "line": 16
              },
              {
                "variable": "toL1",
                "type": "bool",
                "value": "destinationChainId == 1",
                "line": 17
              },
              {
                "variable": "swapAmount",
                "type": "uint256",
                "value": "ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        )",
                "line": 31
              },
              {
                "variable": "amount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[56:72])))",
                "line": 15
              },
              {
                "variable": "wrapper",
                "type": "IL2AmmWrapper",
                "value": "IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        )",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "14": "State Change: destinationChainId = uint256(uint32(bytes4(msg.data[32:36])))",
              "17": "State Change: toL1 = destinationChainId == 1",
              "16": "State Change: amountOutMin = uint256(uint128(bytes16(msg.data[88:104])))",
              "31": "State Change: swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        )",
              "15": "State Change: amount = uint256(uint128(bytes16(msg.data[56:72])))",
              "19": "State Change: wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        )"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaHopL2ERC20Min": {
            "name": "startBridgeTokensViaHopL2ERC20Min",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint256",
                "name": "bonderFee"
              },
              {
                "type": "uint256",
                "name": "amountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationDeadline"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaHopL2ERC20Packed": {
            "name": "encode_startBridgeTokensViaHopL2ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 5
              },
              {
                "type": "require",
                "condition": "bonderFee <= type(uint128",
                "line": 9
              },
              {
                "type": "require",
                "condition": "amountOutMin <= type(uint128",
                "line": 13
              },
              {
                "type": "require",
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 17
              },
              {
                "type": "require",
                "condition": "destinationDeadline <= type(uint32",
                "line": 21
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(minAmount <= type(uint128)",
              "9": "require(bonderFee <= type(uint128)",
              "13": "require(amountOutMin <= type(uint128)",
              "17": "require(destinationAmountOutMin <= type(uint128)",
              "21": "require(destinationDeadline <= type(uint32)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint256",
                "name": "bonderFee"
              },
              {
                "type": "uint256",
                "name": "amountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "uint256",
                "name": "destinationDeadline"
              },
              {
                "type": "address",
                "name": "wrapper"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL2ERC20Packed": {
            "name": "decode_startBridgeTokensViaHopL2ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(_data[32:36])))",
                "line": 11
              },
              {
                "variable": "amountOutMin",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(_data[88:104])))",
                "line": 15
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 144,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "11": "State Change: destinationChainId = uint256(uint32(bytes4(_data[32:36])))",
              "15": "State Change: amountOutMin = uint256(uint128(bytes16(_data[88:104])))",
              "1": "require(_data.length >= 144,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "HopFacetOptimized.HopData memory"
              }
            ]
          },
          "startBridgeTokensViaHopL1NativePacked": {
            "name": "startBridgeTokensViaHopL1NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaHopL1NativeMin": {
            "name": "startBridgeTokensViaHopL1NativeMin",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "address",
                "name": "relayer"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaHopL1NativePacked": {
            "name": "encode_startBridgeTokensViaHopL1NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 5
              },
              {
                "type": "require",
                "condition": "relayerFee <= type(uint128",
                "line": 9
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(destinationAmountOutMin <= type(uint128)",
              "9": "require(relayerFee <= type(uint128)"
            },
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "address",
                "name": "relayer"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL1NativePacked": {
            "name": "decode_startBridgeTokensViaHopL1NativePacked",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(_data[32:36])))",
                "line": 11
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 108,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "11": "State Change: destinationChainId = uint256(uint32(bytes4(_data[32:36])))",
              "1": "require(_data.length >= 108,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "HopFacetOptimized.HopData memory"
              }
            ]
          },
          "startBridgeTokensViaHopL1ERC20Packed": {
            "name": "startBridgeTokensViaHopL1ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "amount",
                "type": "uint256",
                "value": "uint256(uint128(bytes16(msg.data[56:72])))",
                "line": 13
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "13": "State Change: amount = uint256(uint128(bytes16(msg.data[56:72])))"
            },
            "parameters": [],
            "returns": []
          },
          "startBridgeTokensViaHopL1ERC20Min": {
            "name": "startBridgeTokensViaHopL1ERC20Min",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "address",
                "name": "relayer"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": []
          },
          "encode_startBridgeTokensViaHopL1ERC20Packed": {
            "name": "encode_startBridgeTokensViaHopL1ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "destinationChainId <= type(uint32",
                "line": 1
              },
              {
                "type": "require",
                "condition": "minAmount <= type(uint128",
                "line": 5
              },
              {
                "type": "require",
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 9
              },
              {
                "type": "require",
                "condition": "relayerFee <= type(uint128",
                "line": 13
              }
            ],
            "line_mapping": {
              "1": "require(destinationChainId <= type(uint32)",
              "5": "require(minAmount <= type(uint128)",
              "9": "require(destinationAmountOutMin <= type(uint128)",
              "13": "require(relayerFee <= type(uint128)"
            },
            "parameters": [
              {
                "type": "bytes8",
                "name": "transactionId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "destinationChainId"
              },
              {
                "type": "address",
                "name": "sendingAssetId"
              },
              {
                "type": "uint256",
                "name": "minAmount"
              },
              {
                "type": "uint256",
                "name": "destinationAmountOutMin"
              },
              {
                "type": "address",
                "name": "relayer"
              },
              {
                "type": "uint256",
                "name": "relayerFee"
              },
              {
                "type": "address",
                "name": "hopBridge"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL1ERC20Packed": {
            "name": "decode_startBridgeTokensViaHopL1ERC20Packed",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "destinationChainId",
                "type": "uint256",
                "value": "uint256(uint32(bytes4(_data[32:36])))",
                "line": 11
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "_data.length >= 144,\n            \"data passed in is not the correct length\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "11": "State Change: destinationChainId = uint256(uint32(bytes4(_data[32:36])))",
              "1": "require(_data.length >= 144,\n            \"data passed in is not the correct length\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_data"
              }
            ],
            "returns": [
              {
                "type": "BridgeData memory"
              },
              {
                "type": "HopFacetOptimized.HopData memory"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "HopFacetPacked": {
          "startBridgeTokensViaHopL2NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL2NativeMin": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaHopL2NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "bonderFee <= type(uint128",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "amountOutMin <= type(uint128",
                "line": 9,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL2NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 68,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "startBridgeTokensViaHopL2ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL2ERC20Min": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaHopL2ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "minAmount <= type(uint128",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "bonderFee <= type(uint128",
                "line": 9,
                "type": "require"
              },
              {
                "condition": "amountOutMin <= type(uint128",
                "line": 13,
                "type": "require"
              },
              {
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 17,
                "type": "require"
              },
              {
                "condition": "destinationDeadline <= type(uint32",
                "line": 21,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL2ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 144,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "startBridgeTokensViaHopL1NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL1NativeMin": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaHopL1NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "relayerFee <= type(uint128",
                "line": 9,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL1NativePacked": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 108,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          },
          "startBridgeTokensViaHopL1ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "startBridgeTokensViaHopL1ERC20Min": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "encode_startBridgeTokensViaHopL1ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "destinationChainId <= type(uint32",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "minAmount <= type(uint128",
                "line": 5,
                "type": "require"
              },
              {
                "condition": "destinationAmountOutMin <= type(uint128",
                "line": 9,
                "type": "require"
              },
              {
                "condition": "relayerFee <= type(uint128",
                "line": 13,
                "type": "require"
              }
            ]
          },
          "decode_startBridgeTokensViaHopL1ERC20Packed": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "_data.length >= 144,\n            \"data passed in is not the correct length\"",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.782244"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.786243"
      },
      "final_report": {
        "file_id": "HopFacetPacked.sol",
        "timestamp": "2025-03-11T07:05:50.786270",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "HopFacetPacked": {
            "functions": 16,
            "state_variables": 8,
            "inheritance": [
              "ILiFi",
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of HopFacetPacked.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.786284"
    },
    "LIFuelFacet.sol": {
      "file_id": "LIFuelFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "LIFuelFacet": {
            "name": "LIFuelFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LiFuelFeeCollector liFuelFeeCollector = LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            liFuelFeeCollector.collectNativeGasFees{\n                value: _bridgeData.minAmount\n            }(\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(liFuelFeeCollector),\n                _bridgeData.minAmount\n            );\n\n            liFuelFeeCollector.collectTokenGasFees(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "liFuelFeeCollector": {
                "name": "liFuelFeeCollector",
                "type": "LiFuelFeeCollector",
                "visibility": "internal",
                "initial_value": "LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        )"
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LiFuelFeeCollector } from \"../Periphery/LiFuelFeeCollector.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title LIFuel Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging gas through LIFuel\n/// @custom:version 1.0.1\ncontract LIFuelFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n    string internal constant FEE_COLLECTOR_NAME = \"LiFuelFeeCollector\";\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function startBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        LiFuelFeeCollector liFuelFeeCollector = LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            liFuelFeeCollector.collectNativeGasFees{\n                value: _bridgeData.minAmount\n            }(\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(liFuelFeeCollector),\n                _bridgeData.minAmount\n            );\n\n            liFuelFeeCollector.collectTokenGasFees(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "LIFuelFacet": {
          "_startBridge": [
            {
              "contract": "LIFuelFacet",
              "function": "getStorage"
            }
          ],
          "getStorage": []
        }
      },
      "flow_data": {
        "LIFuelFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "liFuelFeeCollector",
                "type": "LiFuelFeeCollector",
                "value": "LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        )",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "1": "State Change: liFuelFeeCollector = LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        )"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              }
            ],
            "returns": []
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "LIFuelFacet": {
          "_startBridge": {
            "calls": [
              {
                "contract": "LIFuelFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.783394"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.789681"
      },
      "final_report": {
        "file_id": "LIFuelFacet.sol",
        "timestamp": "2025-03-11T07:05:50.789703",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "LIFuelFacet": {
            "functions": 2,
            "state_variables": 2,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LIFuelFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.789715"
    },
    "MayanFacet.sol": {
      "file_id": "MayanFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "MayanFacet": {
            "name": "MayanFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "MayanData",
                    "name": "_mayanData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Validate receiver address\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            if (_mayanData.nonEVMReceiver == bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                );\n            }\n            bytes32 receiver = _parseReceiver(_mayanData.protocolData);\n            if (_mayanData.nonEVMReceiver != receiver) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    receiver\n                );\n            }\n        } else {\n            address receiver = address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            );\n            if (_bridgeData.receiver != receiver) {\n                revert InvalidReceiver(_bridgeData.receiver, receiver);\n            }\n        }\n\n        IMayan.PermitParams memory emptyPermitParams;\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(mayan),\n                _bridgeData.minAmount\n            );\n\n            mayan.forwardERC20(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                emptyPermitParams,\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        } else {\n            mayan.forwardEth{ value: _bridgeData.minAmount }(\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        }\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _mayanData.nonEVMReceiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "_parseReceiver": {
                "name": "_parseReceiver",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "protocolData"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32 receiver"
                  }
                ],
                "modifiers": [],
                "code": "bytes4 selector;\n        assembly {\n            // Load the selector from the protocol data\n            selector := mload(add(protocolData, 0x20))\n            // Shift the selector to the right by 224 bits to match shape of literal in switch statement\n            let shiftedSelector := shr(224, selector)\n            switch shiftedSelector\n            // Note: [*bytes32*] = location of receiver address\n            case 0x94454a5d {\n                // 0x94454a5d bridgeWithFee(address,uint256,uint64,uint64,[*bytes32*],(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0xa4)) // MayanCircle::bridgeWithFee()\n            }\n            case 0x32ad465f {\n                // 0x32ad465f bridgeWithLockedFee(address,uint256,uint64,uint256,(uint32,[*bytes32*],bytes32))\n                receiver := mload(add(protocolData, 0xc4)) // MayanCircle::bridgeWithLockedFee()\n            }\n            case 0xafd9b706 {\n                // 0xafd9b706 createOrder((address,uint256,uint64,[*bytes32*],uint16,bytes32,uint64,uint64,uint64,bytes32,uint8),(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0x84)) // MayanCircle::createOrder()\n            }\n            case 0x6111ad25 {\n                // 0x6111ad25 swap((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes),address,uint256)\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::swap()\n            }\n            case 0x1eb1cff0 {\n                // 0x1eb1cff0 wrapAndSwapETH((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes))\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::wrapAndSwapETH()\n            }\n            case 0xb866e173 {\n                // 0xb866e173 createOrderWithEth((bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x104)) // MayanSwift::createOrderWithEth()\n            }\n            case 0x8e8d142b {\n                // 0x8e8d142b createOrderWithToken(address,uint256,(bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x144)) // MayanSwift::createOrderWithToken()\n            }\n            default {\n                receiver := 0x0\n            }\n        }\n    }"
              },
              "_normalizeAmount": {
                "name": "_normalizeAmount",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "uint8",
                    "name": "decimals"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "if (decimals > 8) {\n            amount /= 10 ** (decimals - 8);\n            amount *= 10 ** (decimals - 8);\n        }\n        return amount;\n    }"
              },
              "_replaceInputAmount": {
                "name": "_replaceInputAmount",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "protocolData"
                  },
                  {
                    "type": "uint256",
                    "name": "inputAmount"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "require(protocolData.length >= 68, \"protocol data too short\");\n        bytes memory modifiedData = new bytes(protocolData.length);\n        bytes4 functionSelector = bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24);\n\n        uint256 amountIndex;\n        // Only the wh swap method has the amount as last argument\n        bytes4 swapSelector = 0x6111ad25;\n        if (functionSelector == swapSelector) {\n            amountIndex = protocolData.length - 256;\n        } else {\n            amountIndex = 36;\n        }\n\n        // Copy the function selector and params before amount in\n        for (uint i = 0; i < amountIndex; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        // Encode the amount and place it into the modified call data\n        bytes memory encodedAmount = abi.encode(inputAmount);\n        for (uint i = 0; i < 32; i++) {\n            modifiedData[i + amountIndex] = encodedAmount[i];\n        }\n\n        // Copy the rest of the original data after the input argument\n        for (uint i = amountIndex + 32; i < protocolData.length; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        return modifiedData;\n    }"
              }
            },
            "state_variables": {
              "nonEVMReceiver": {
                "name": "nonEVMReceiver",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "mayanProtocol": {
                "name": "mayanProtocol",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "protocolData": {
                "name": "protocolData",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "decimals": {
                "name": "decimals",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "isNative": {
                "name": "isNative",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
              },
              "receiver": {
                "name": "receiver",
                "type": "address",
                "visibility": "internal",
                "initial_value": "address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            )"
              },
              "selector": {
                "name": "selector",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": null
              },
              "amount": {
                "name": "amount",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "functionSelector": {
                "name": "functionSelector",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": "bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24)"
              },
              "amountIndex": {
                "name": "amountIndex",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "swapSelector": {
                "name": "swapSelector",
                "type": "bytes4",
                "visibility": "internal",
                "initial_value": "0x6111ad25"
              },
              "modifiedData": {
                "name": "modifiedData",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { IMayan } from \"../Interfaces/IMayan.sol\";\nimport { UnsupportedChainId } from \"../Errors/GenericErrors.sol\";\n\n/// @title Mayan Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Mayan Bridge\n/// @custom:version 1.0.0\ncontract MayanFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.mayan\");\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n\n    IMayan public immutable mayan;\n\n    /// @dev Mayan specific bridge data\n    /// @param nonEVMReceiver The address of the non-EVM receiver if applicable\n    /// @param mayanProtocol The address of the Mayan protocol final contract\n    /// @param protocolData The protocol data for the Mayan protocol\n    struct MayanData {\n        bytes32 nonEVMReceiver;\n        address mayanProtocol;\n        bytes protocolData;\n    }\n\n    /// Errors ///\n    error InvalidReceiver(address expected, address actual);\n    error InvalidNonEVMReceiver(bytes32 expected, bytes32 actual);\n\n    /// Events ///\n\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed destinationChainId,\n        bytes32 receiver\n    );\n\n    /// Constructor ///\n\n    /// @notice Constructor for the contract.\n    constructor(IMayan _mayan) {\n        mayan = _mayan;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _mayanData Data specific to Mayan\n    function startBridgeTokensViaMayan(\n        ILiFi.BridgeData memory _bridgeData,\n        MayanData calldata _mayanData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Normalize the amount to 8 decimals\n            _bridgeData.minAmount = _normalizeAmount(\n                _bridgeData.minAmount,\n                18\n            );\n        }\n\n        _startBridge(_bridgeData, _mayanData);\n    }\n\n    /// @notice Performs a swap before bridging via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _mayanData Data specific to Mayan\n    function swapAndStartBridgeTokensViaMayan(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        MayanData memory _mayanData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        uint256 decimals;\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        decimals = isNative\n            ? 18\n            : ERC20(_bridgeData.sendingAssetId).decimals();\n\n        // Normalize the amount to 8 decimals\n        _bridgeData.minAmount = _normalizeAmount(\n            _bridgeData.minAmount,\n            uint8(decimals)\n        );\n\n        // Native values are not passed as calldata\n        if (!isNative) {\n            // Update the protocol data with the new input amount\n            _mayanData.protocolData = _replaceInputAmount(\n                _mayanData.protocolData,\n                _bridgeData.minAmount\n            );\n        }\n\n        _startBridge(_bridgeData, _mayanData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _mayanData Data specific to Mayan\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        MayanData memory _mayanData\n    ) internal {\n        // Validate receiver address\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            if (_mayanData.nonEVMReceiver == bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                );\n            }\n            bytes32 receiver = _parseReceiver(_mayanData.protocolData);\n            if (_mayanData.nonEVMReceiver != receiver) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    receiver\n                );\n            }\n        } else {\n            address receiver = address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            );\n            if (_bridgeData.receiver != receiver) {\n                revert InvalidReceiver(_bridgeData.receiver, receiver);\n            }\n        }\n\n        IMayan.PermitParams memory emptyPermitParams;\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(mayan),\n                _bridgeData.minAmount\n            );\n\n            mayan.forwardERC20(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                emptyPermitParams,\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        } else {\n            mayan.forwardEth{ value: _bridgeData.minAmount }(\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        }\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _mayanData.nonEVMReceiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    // @dev Parses the receiver address from the protocol data\n    // @param protocolData The protocol data for the Mayan protocol\n    // @return receiver The receiver address\n    function _parseReceiver(\n        bytes memory protocolData\n    ) internal pure returns (bytes32 receiver) {\n        bytes4 selector;\n        assembly {\n            // Load the selector from the protocol data\n            selector := mload(add(protocolData, 0x20))\n            // Shift the selector to the right by 224 bits to match shape of literal in switch statement\n            let shiftedSelector := shr(224, selector)\n            switch shiftedSelector\n            // Note: [*bytes32*] = location of receiver address\n            case 0x94454a5d {\n                // 0x94454a5d bridgeWithFee(address,uint256,uint64,uint64,[*bytes32*],(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0xa4)) // MayanCircle::bridgeWithFee()\n            }\n            case 0x32ad465f {\n                // 0x32ad465f bridgeWithLockedFee(address,uint256,uint64,uint256,(uint32,[*bytes32*],bytes32))\n                receiver := mload(add(protocolData, 0xc4)) // MayanCircle::bridgeWithLockedFee()\n            }\n            case 0xafd9b706 {\n                // 0xafd9b706 createOrder((address,uint256,uint64,[*bytes32*],uint16,bytes32,uint64,uint64,uint64,bytes32,uint8),(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0x84)) // MayanCircle::createOrder()\n            }\n            case 0x6111ad25 {\n                // 0x6111ad25 swap((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes),address,uint256)\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::swap()\n            }\n            case 0x1eb1cff0 {\n                // 0x1eb1cff0 wrapAndSwapETH((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes))\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::wrapAndSwapETH()\n            }\n            case 0xb866e173 {\n                // 0xb866e173 createOrderWithEth((bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x104)) // MayanSwift::createOrderWithEth()\n            }\n            case 0x8e8d142b {\n                // 0x8e8d142b createOrderWithToken(address,uint256,(bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x144)) // MayanSwift::createOrderWithToken()\n            }\n            default {\n                receiver := 0x0\n            }\n        }\n    }\n\n    // @dev Normalizes the amount to 8 decimals\n    // @param amount The amount to normalize\n    // @param decimals The number of decimals in the asset\n    function _normalizeAmount(\n        uint256 amount,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        if (decimals > 8) {\n            amount /= 10 ** (decimals - 8);\n            amount *= 10 ** (decimals - 8);\n        }\n        return amount;\n    }\n\n    // @dev Replaces the input amount in the protocol data\n    // @param protocolData The protocol data for the Mayan protocol\n    // @param inputAmount The new input amount\n    // @return modifiedData The modified protocol data\n    function _replaceInputAmount(\n        bytes memory protocolData,\n        uint256 inputAmount\n    ) internal pure returns (bytes memory) {\n        require(protocolData.length >= 68, \"protocol data too short\");\n        bytes memory modifiedData = new bytes(protocolData.length);\n        bytes4 functionSelector = bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24);\n\n        uint256 amountIndex;\n        // Only the wh swap method has the amount as last argument\n        bytes4 swapSelector = 0x6111ad25;\n        if (functionSelector == swapSelector) {\n            amountIndex = protocolData.length - 256;\n        } else {\n            amountIndex = 36;\n        }\n\n        // Copy the function selector and params before amount in\n        for (uint i = 0; i < amountIndex; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        // Encode the amount and place it into the modified call data\n        bytes memory encodedAmount = abi.encode(inputAmount);\n        for (uint i = 0; i < 32; i++) {\n            modifiedData[i + amountIndex] = encodedAmount[i];\n        }\n\n        // Copy the rest of the original data after the input argument\n        for (uint i = amountIndex + 32; i < protocolData.length; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        return modifiedData;\n    }\n}\n"
      },
      "call_graph": {
        "MayanFacet": {
          "_startBridge": [
            {
              "contract": "MayanFacet",
              "function": "_parseReceiver"
            }
          ],
          "_parseReceiver": [],
          "_normalizeAmount": [],
          "_replaceInputAmount": []
        }
      },
      "flow_data": {
        "MayanFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "_bridgeData.receiver == NON_EVM_ADDRESS",
                "line": 2
              },
              {
                "type": "if",
                "condition": "_mayanData.nonEVMReceiver == bytes32(0",
                "line": 3
              },
              {
                "type": "if",
                "condition": "_mayanData.nonEVMReceiver != receiver",
                "line": 10
              },
              {
                "type": "if",
                "condition": "_bridgeData.receiver != receiver",
                "line": 20
              },
              {
                "type": "if",
                "condition": "!LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 27
              },
              {
                "type": "if",
                "condition": "_bridgeData.receiver == NON_EVM_ADDRESS",
                "line": 48
              }
            ],
            "state_changes": [
              {
                "variable": "nonEVMReceiver",
                "type": "bytes32",
                "value": "= bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                )",
                "line": 3
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "= NON_EVM_ADDRESS) {\n            if (_mayanData.nonEVMReceiver == bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                )",
                "line": 2
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "_parseReceiver(_mayanData.protocolData)",
                "line": 9
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            )",
                "line": 17
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "= NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _mayanData.nonEVMReceiver\n            )",
                "line": 48
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: receiver = = NON_EVM_ADDRESS) {\n            if (_mayanData.nonEVMReceiver == bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                )",
              "3": "State Change: nonEVMReceiver = = bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                )",
              "10": "if (_mayanData.nonEVMReceiver != receiver)",
              "20": "if (_bridgeData.receiver != receiver)",
              "27": "if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "48": "State Change: receiver = = NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _mayanData.nonEVMReceiver\n            )",
              "9": "State Change: receiver = _parseReceiver(_mayanData.protocolData)",
              "17": "State Change: receiver = address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            )"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "MayanData",
                "name": "_mayanData"
              }
            ],
            "returns": []
          },
          "_parseReceiver": {
            "name": "_parseReceiver",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "protocolData"
              }
            ],
            "returns": [
              {
                "type": "bytes32 receiver"
              }
            ]
          },
          "_normalizeAmount": {
            "name": "_normalizeAmount",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "decimals > 8",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (decimals > 8)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "uint8",
                "name": "decimals"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          },
          "_replaceInputAmount": {
            "name": "_replaceInputAmount",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "functionSelector == swapSelector",
                "line": 11
              },
              {
                "type": "for",
                "condition": "uint i = 0; i < amountIndex; i++",
                "line": 18
              },
              {
                "type": "for",
                "condition": "uint i = 0; i < 32; i++",
                "line": 24
              },
              {
                "type": "for",
                "condition": "uint i = amountIndex + 32; i < protocolData.length; i++",
                "line": 29
              }
            ],
            "state_changes": [
              {
                "variable": "functionSelector",
                "type": "bytes4",
                "value": "bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24)",
                "line": 3
              },
              {
                "variable": "functionSelector",
                "type": "bytes4",
                "value": "= swapSelector) {\n            amountIndex = protocolData.length - 256",
                "line": 11
              },
              {
                "variable": "amountIndex",
                "type": "uint256",
                "value": "protocolData.length - 256",
                "line": 12
              },
              {
                "variable": "amountIndex",
                "type": "uint256",
                "value": "36",
                "line": 14
              },
              {
                "variable": "swapSelector",
                "type": "bytes4",
                "value": "0x6111ad25",
                "line": 10
              },
              {
                "variable": "modifiedData",
                "type": "return",
                "value": "new bytes(protocolData.length)",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "protocolData.length >= 68, \"protocol data too short\"",
                "line": 1
              }
            ],
            "line_mapping": {
              "11": "State Change: functionSelector = = swapSelector) {\n            amountIndex = protocolData.length - 256",
              "18": "for (uint i = 0; i < amountIndex; i++)",
              "24": "for (uint i = 0; i < 32; i++)",
              "29": "for (uint i = amountIndex + 32; i < protocolData.length; i++)",
              "3": "State Change: functionSelector = bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24)",
              "12": "State Change: amountIndex = protocolData.length - 256",
              "14": "State Change: amountIndex = 36",
              "10": "State Change: swapSelector = 0x6111ad25",
              "2": "State Change: modifiedData = new bytes(protocolData.length)",
              "1": "require(protocolData.length >= 68, \"protocol data too short\")"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "protocolData"
              },
              {
                "type": "uint256",
                "name": "inputAmount"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "MayanFacet": {
          "_startBridge": {
            "calls": [
              {
                "contract": "MayanFacet",
                "function": "_parseReceiver",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_parseReceiver": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_normalizeAmount": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_replaceInputAmount": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "protocolData.length >= 68, \"protocol data too short\"",
                "line": 1,
                "type": "require"
              }
            ]
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.817388"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.820433"
      },
      "final_report": {
        "file_id": "MayanFacet.sol",
        "timestamp": "2025-03-11T07:05:50.820459",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "MayanFacet": {
            "functions": 4,
            "state_variables": 12,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of MayanFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.820473"
    },
    "OmniBridgeFacet.sol": {
      "file_id": "OmniBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "OmniBridgeFacet": {
            "name": "OmniBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            wethOmniBridge.wrapAndRelayTokens{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(foreignOmniBridge),\n                _bridgeData.minAmount\n            );\n            foreignOmniBridge.relayTokens(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IOmniBridge } from \"../Interfaces/IOmniBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title OmniBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through OmniBridge\n/// @custom:version 1.0.0\ncontract OmniBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the foreign omni bridge on the source chain.\n    IOmniBridge private immutable foreignOmniBridge;\n\n    /// @notice The contract address of the weth omni bridge on the source chain.\n    IOmniBridge private immutable wethOmniBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _foreignOmniBridge The contract address of the foreign omni bridge on the source chain.\n    /// @param _wethOmniBridge The contract address of the weth omni bridge on the source chain.\n    constructor(IOmniBridge _foreignOmniBridge, IOmniBridge _wethOmniBridge) {\n        foreignOmniBridge = _foreignOmniBridge;\n        wethOmniBridge = _wethOmniBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function startBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            wethOmniBridge.wrapAndRelayTokens{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(foreignOmniBridge),\n                _bridgeData.minAmount\n            );\n            foreignOmniBridge.relayTokens(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "OmniBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "OmniBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "OmniBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.784226"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.793955"
      },
      "final_report": {
        "file_id": "OmniBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.793982",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "OmniBridgeFacet": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of OmniBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.793995"
    },
    "OptimismBridgeFacet.sol": {
      "file_id": "OptimismBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "OptimismBridgeFacet": {
            "name": "OptimismBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "initOptimism": {
                "name": "initOptimism",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "Config[]",
                    "name": "configs"
                  },
                  {
                    "type": "IL1StandardBridge",
                    "name": "standardBridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (s.initialized) {\n            revert AlreadyInitialized();\n        }\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IL1StandardBridge(\n                configs[i].bridge\n            );\n        }\n\n        s.standardBridge = standardBridge;\n        s.initialized = true;\n\n        emit OptimismInitialized(configs);\n    }"
              },
              "registerOptimismBridge": {
                "name": "registerOptimismBridge",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "bridge"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (!s.initialized) revert NotInitialized();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IL1StandardBridge(bridge);\n\n        emit OptimismBridgeRegistered(assetId, bridge);\n    }"
              },
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "OptimismData",
                    "name": "_optimismData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "Storage storage s = getStorage();\n        IL1StandardBridge nonStandardBridge = s.bridges[\n            _bridgeData.sendingAssetId\n        ];\n        IL1StandardBridge bridge = LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            bridge.depositETHTo{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _optimismData.l2Gas,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(bridge),\n                _bridgeData.minAmount\n            );\n\n            if (_optimismData.isSynthetix) {\n                bridge.depositTo(_bridgeData.receiver, _bridgeData.minAmount);\n            } else {\n                bridge.depositERC20To(\n                    _bridgeData.sendingAssetId,\n                    _optimismData.assetIdOnL2,\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    _optimismData.l2Gas,\n                    \"\"\n                );\n            }\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "standardBridge": {
                "name": "standardBridge",
                "type": "IL1StandardBridge",
                "visibility": "internal",
                "initial_value": null
              },
              "initialized": {
                "name": "initialized",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "assetId": {
                "name": "assetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "bridge": {
                "name": "bridge",
                "type": "IL1StandardBridge",
                "visibility": "internal",
                "initial_value": "LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge"
              },
              "assetIdOnL2": {
                "name": "assetIdOnL2",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "l2Gas": {
                "name": "l2Gas",
                "type": "uint32",
                "visibility": "internal",
                "initial_value": null
              },
              "isSynthetix": {
                "name": "isSynthetix",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "nonStandardBridge": {
                "name": "nonStandardBridge",
                "type": "IL1StandardBridge",
                "visibility": "internal",
                "initial_value": "s.bridges[\n            _bridgeData.sendingAssetId\n        ]"
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IL1StandardBridge } from \"../Interfaces/IL1StandardBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\n\n/// @title Optimism Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Optimism Bridge\n/// @custom:version 1.0.0\ncontract OptimismBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.optimism\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IL1StandardBridge) bridges;\n        IL1StandardBridge standardBridge;\n        bool initialized;\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct OptimismData {\n        address assetIdOnL2;\n        uint32 l2Gas;\n        bool isSynthetix;\n    }\n\n    /// Events ///\n\n    event OptimismInitialized(Config[] configs);\n    event OptimismBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Optimism Bridge Facet\n    /// @param configs Bridge configuration data\n    function initOptimism(\n        Config[] calldata configs,\n        IL1StandardBridge standardBridge\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (s.initialized) {\n            revert AlreadyInitialized();\n        }\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IL1StandardBridge(\n                configs[i].bridge\n            );\n        }\n\n        s.standardBridge = standardBridge;\n        s.initialized = true;\n\n        emit OptimismInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerOptimismBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (!s.initialized) revert NotInitialized();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IL1StandardBridge(bridge);\n\n        emit OptimismBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function startBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// @notice Performs a swap before bridging via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function swapAndStartBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    ) private {\n        Storage storage s = getStorage();\n        IL1StandardBridge nonStandardBridge = s.bridges[\n            _bridgeData.sendingAssetId\n        ];\n        IL1StandardBridge bridge = LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            bridge.depositETHTo{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _optimismData.l2Gas,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(bridge),\n                _bridgeData.minAmount\n            );\n\n            if (_optimismData.isSynthetix) {\n                bridge.depositTo(_bridgeData.receiver, _bridgeData.minAmount);\n            } else {\n                bridge.depositERC20To(\n                    _bridgeData.sendingAssetId,\n                    _optimismData.assetIdOnL2,\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    _optimismData.l2Gas,\n                    \"\"\n                );\n            }\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "OptimismBridgeFacet": {
          "initOptimism": [
            {
              "contract": "OptimismBridgeFacet",
              "function": "getStorage"
            }
          ],
          "registerOptimismBridge": [
            {
              "contract": "OptimismBridgeFacet",
              "function": "getStorage"
            }
          ],
          "_startBridge": [
            {
              "contract": "OptimismBridgeFacet",
              "function": "getStorage"
            }
          ],
          "getStorage": []
        }
      },
      "flow_data": {
        "OptimismBridgeFacet": {
          "initOptimism": {
            "name": "initOptimism",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "s.initialized",
                "line": 5
              },
              {
                "type": "for",
                "condition": "uint256 i = 0; i < configs.length; i++",
                "line": 9
              },
              {
                "type": "if",
                "condition": "configs[i].bridge == address(0",
                "line": 10
              }
            ],
            "state_changes": [
              {
                "variable": "standardBridge",
                "type": "IL1StandardBridge",
                "value": "standardBridge",
                "line": 18
              },
              {
                "variable": "initialized",
                "type": "bool",
                "value": "true",
                "line": 19
              },
              {
                "variable": "bridge",
                "type": "IL1StandardBridge",
                "value": "= address(0)) {\n                revert InvalidConfig()",
                "line": 10
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "if (s.initialized)",
              "9": "for (uint256 i = 0; i < configs.length; i++)",
              "10": "State Change: bridge = = address(0)) {\n                revert InvalidConfig()",
              "18": "State Change: standardBridge = standardBridge",
              "19": "State Change: initialized = true"
            },
            "parameters": [
              {
                "type": "Config[]",
                "name": "configs"
              },
              {
                "type": "IL1StandardBridge",
                "name": "standardBridge"
              }
            ],
            "returns": []
          },
          "registerOptimismBridge": {
            "name": "registerOptimismBridge",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "!s.initialized",
                "line": 5
              },
              {
                "type": "if",
                "condition": "bridge == address(0",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "bridge",
                "type": "IL1StandardBridge",
                "value": "= address(0)) {\n            revert InvalidConfig()",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "if (!s.initialized)",
              "7": "State Change: bridge = = address(0)) {\n            revert InvalidConfig()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "bridge"
              }
            ],
            "returns": []
          },
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 11
              },
              {
                "type": "if",
                "condition": "_optimismData.isSynthetix",
                "line": 24
              }
            ],
            "state_changes": [
              {
                "variable": "bridge",
                "type": "IL1StandardBridge",
                "value": "LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge",
                "line": 5
              },
              {
                "variable": "nonStandardBridge",
                "type": "IL1StandardBridge",
                "value": "s.bridges[\n            _bridgeData.sendingAssetId\n        ]",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "11": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "24": "if (_optimismData.isSynthetix)",
              "5": "State Change: bridge = LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge",
              "2": "State Change: nonStandardBridge = s.bridges[\n            _bridgeData.sendingAssetId\n        ]"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "OptimismData",
                "name": "_optimismData"
              }
            ],
            "returns": []
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "OptimismBridgeFacet": {
          "initOptimism": {
            "calls": [
              {
                "contract": "OptimismBridgeFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "registerOptimismBridge": {
            "calls": [
              {
                "contract": "OptimismBridgeFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_startBridge": {
            "calls": [
              {
                "contract": "OptimismBridgeFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.819354"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.824281"
      },
      "final_report": {
        "file_id": "OptimismBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.824303",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "OptimismBridgeFacet": {
            "functions": 4,
            "state_variables": 9,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of OptimismBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.824314"
    },
    "OwnershipFacet.sol": {
      "file_id": "OwnershipFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "OwnershipFacet": {
            "name": "OwnershipFacet",
            "inheritance": [
              "IERC173"
            ],
            "functions": {
              "transferOwnership": {
                "name": "transferOwnership",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_newOwner"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(_newOwner)) revert NoNullOwner();\n\n        if (_newOwner == LibDiamond.contractOwner())\n            revert NewOwnerMustNotBeSelf();\n\n        s.newOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, s.newOwner);\n    }"
              },
              "cancelOwnershipTransfer": {
                "name": "cancelOwnershipTransfer",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(s.newOwner))\n            revert NoPendingOwnershipTransfer();\n        s.newOwner = address(0);\n    }"
              },
              "confirmOwnershipTransfer": {
                "name": "confirmOwnershipTransfer",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "Storage storage s = getStorage();\n        address _pendingOwner = s.newOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(LibDiamond.contractOwner(), _pendingOwner);\n        LibDiamond.setContractOwner(_pendingOwner);\n        s.newOwner = LibAsset.NULL_ADDRESS;\n    }"
              },
              "owner": {
                "name": "owner",
                "visibility": "external",
                "parameters": [],
                "returns": [
                  {
                    "type": "address owner_"
                  }
                ],
                "modifiers": [],
                "code": "owner_ = LibDiamond.contractOwner();\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "newOwner": {
                "name": "newOwner",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "_pendingOwner": {
                "name": "_pendingOwner",
                "type": "address",
                "visibility": "internal",
                "initial_value": "s.newOwner"
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title Ownership Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Manages ownership of the LiFi Diamond contract for admin purposes\n/// @custom:version 1.0.0\ncontract OwnershipFacet is IERC173 {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.ownership\");\n\n    /// Types ///\n\n    struct Storage {\n        address newOwner;\n    }\n\n    /// Errors ///\n\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// External Methods ///\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(_newOwner)) revert NoNullOwner();\n\n        if (_newOwner == LibDiamond.contractOwner())\n            revert NewOwnerMustNotBeSelf();\n\n        s.newOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, s.newOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(s.newOwner))\n            revert NoPendingOwnershipTransfer();\n        s.newOwner = address(0);\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        Storage storage s = getStorage();\n        address _pendingOwner = s.newOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(LibDiamond.contractOwner(), _pendingOwner);\n        LibDiamond.setContractOwner(_pendingOwner);\n        s.newOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Return the current owner address\n    /// @return owner_ The current owner address\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "OwnershipFacet": {
          "transferOwnership": [
            {
              "contract": "OwnershipFacet",
              "function": "getStorage"
            }
          ],
          "cancelOwnershipTransfer": [
            {
              "contract": "OwnershipFacet",
              "function": "getStorage"
            }
          ],
          "confirmOwnershipTransfer": [
            {
              "contract": "OwnershipFacet",
              "function": "getStorage"
            }
          ],
          "owner": [],
          "getStorage": []
        }
      },
      "flow_data": {
        "OwnershipFacet": {
          "transferOwnership": {
            "name": "transferOwnership",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibUtil.isZeroAddress(_newOwner",
                "line": 4
              },
              {
                "type": "if",
                "condition": "_newOwner == LibDiamond.contractOwner(",
                "line": 6
              }
            ],
            "state_changes": [
              {
                "variable": "newOwner",
                "type": "address",
                "value": "_newOwner",
                "line": 9
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (LibUtil.isZeroAddress(_newOwner)",
              "6": "if (_newOwner == LibDiamond.contractOwner()",
              "9": "State Change: newOwner = _newOwner"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_newOwner"
              }
            ],
            "returns": []
          },
          "cancelOwnershipTransfer": {
            "name": "cancelOwnershipTransfer",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibUtil.isZeroAddress(s.newOwner",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "newOwner",
                "type": "address",
                "value": "address(0)",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (LibUtil.isZeroAddress(s.newOwner)",
              "6": "State Change: newOwner = address(0)"
            },
            "parameters": [],
            "returns": []
          },
          "confirmOwnershipTransfer": {
            "name": "confirmOwnershipTransfer",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != _pendingOwner",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "newOwner",
                "type": "address",
                "value": "LibAsset.NULL_ADDRESS",
                "line": 6
              },
              {
                "variable": "_pendingOwner",
                "type": "address",
                "value": "s.newOwner",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (msg.sender != _pendingOwner)",
              "6": "State Change: newOwner = LibAsset.NULL_ADDRESS",
              "2": "State Change: _pendingOwner = s.newOwner"
            },
            "parameters": [],
            "returns": []
          },
          "owner": {
            "name": "owner",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": [
              {
                "type": "address owner_"
              }
            ]
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "OwnershipFacet": {
          "transferOwnership": {
            "calls": [
              {
                "contract": "OwnershipFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "cancelOwnershipTransfer": {
            "calls": [
              {
                "contract": "OwnershipFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "confirmOwnershipTransfer": {
            "calls": [
              {
                "contract": "OwnershipFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "owner": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.795855"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.799886"
      },
      "final_report": {
        "file_id": "OwnershipFacet.sol",
        "timestamp": "2025-03-11T07:05:50.799912",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "OwnershipFacet": {
            "functions": 5,
            "state_variables": 3,
            "inheritance": [
              "IERC173"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of OwnershipFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.799926"
    },
    "PeripheryRegistryFacet.sol": {
      "file_id": "PeripheryRegistryFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "PeripheryRegistryFacet": {
            "name": "PeripheryRegistryFacet",
            "inheritance": [],
            "functions": {
              "registerPeripheryContract": {
                "name": "registerPeripheryContract",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "string",
                    "name": "_name"
                  },
                  {
                    "type": "address",
                    "name": "_contractAddress"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.contracts[_name] = _contractAddress;\n        emit PeripheryContractRegistered(_name, _contractAddress);\n    }"
              },
              "getPeripheryContract": {
                "name": "getPeripheryContract",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "string",
                    "name": "_name"
                  }
                ],
                "returns": [
                  {
                    "type": "address"
                  }
                ],
                "modifiers": [],
                "code": "return getStorage().contracts[_name];\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Periphery Registry Facet\n/// @author LI.FI (https://li.fi)\n/// @notice A simple registry to track LIFI periphery contracts\n/// @custom:version 1.0.0\ncontract PeripheryRegistryFacet {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// Events ///\n\n    event PeripheryContractRegistered(string name, address contractAddress);\n\n    /// External Methods ///\n\n    /// @notice Registers a periphery contract address with a specified name\n    /// @param _name the name to register the contract address under\n    /// @param _contractAddress the address of the contract to register\n    function registerPeripheryContract(\n        string calldata _name,\n        address _contractAddress\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.contracts[_name] = _contractAddress;\n        emit PeripheryContractRegistered(_name, _contractAddress);\n    }\n\n    /// @notice Returns the registered contract address by its name\n    /// @param _name the registered name of the contract\n    function getPeripheryContract(\n        string calldata _name\n    ) external view returns (address) {\n        return getStorage().contracts[_name];\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "PeripheryRegistryFacet": {
          "registerPeripheryContract": [
            {
              "contract": "PeripheryRegistryFacet",
              "function": "getStorage"
            }
          ],
          "getPeripheryContract": [
            {
              "contract": "PeripheryRegistryFacet",
              "function": "getStorage"
            }
          ],
          "getStorage": []
        }
      },
      "flow_data": {
        "PeripheryRegistryFacet": {
          "registerPeripheryContract": {
            "name": "registerPeripheryContract",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "string",
                "name": "_name"
              },
              {
                "type": "address",
                "name": "_contractAddress"
              }
            ],
            "returns": []
          },
          "getPeripheryContract": {
            "name": "getPeripheryContract",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "string",
                "name": "_name"
              }
            ],
            "returns": [
              {
                "type": "address"
              }
            ]
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "PeripheryRegistryFacet": {
          "registerPeripheryContract": {
            "calls": [
              {
                "contract": "PeripheryRegistryFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getPeripheryContract": {
            "calls": [
              {
                "contract": "PeripheryRegistryFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.798255"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.805153"
      },
      "final_report": {
        "file_id": "PeripheryRegistryFacet.sol",
        "timestamp": "2025-03-11T07:05:50.805180",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "PeripheryRegistryFacet": {
            "functions": 3,
            "state_variables": 1,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of PeripheryRegistryFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.805193"
    },
    "PolygonBridgeFacet.sol": {
      "file_id": "PolygonBridgeFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "PolygonBridgeFacet": {
            "name": "PolygonBridgeFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address childToken;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            rootChainManager.depositEtherFor{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            childToken = rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            );\n\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                erc20Predicate,\n                _bridgeData.minAmount\n            );\n\n            bytes memory depositData = abi.encode(_bridgeData.minAmount);\n            rootChainManager.depositFor(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                depositData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "childToken": {
                "name": "childToken",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IRootChainManager } from \"../Interfaces/IRootChainManager.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Polygon Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Polygon Bridge\n/// @custom:version 1.0.0\ncontract PolygonBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the RootChainManager on the source chain.\n    IRootChainManager private immutable rootChainManager;\n\n    /// @notice The contract address of the ERC20Predicate on the source chain.\n    address private immutable erc20Predicate;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _rootChainManager The contract address of the RootChainManager on the source chain.\n    /// @param _erc20Predicate The contract address of the ERC20Predicate on the source chain.\n    constructor(IRootChainManager _rootChainManager, address _erc20Predicate) {\n        rootChainManager = _rootChainManager;\n        erc20Predicate = _erc20Predicate;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        address childToken;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            rootChainManager.depositEtherFor{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            childToken = rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            );\n\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                erc20Predicate,\n                _bridgeData.minAmount\n            );\n\n            bytes memory depositData = abi.encode(_bridgeData.minAmount);\n            rootChainManager.depositFor(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                depositData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "PolygonBridgeFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "PolygonBridgeFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "childToken",
                "type": "address",
                "value": "rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            )",
                "line": 8
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "8": "State Change: childToken = rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            )"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "PolygonBridgeFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.800105"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.808467"
      },
      "final_report": {
        "file_id": "PolygonBridgeFacet.sol",
        "timestamp": "2025-03-11T07:05:50.808492",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "PolygonBridgeFacet": {
            "functions": 1,
            "state_variables": 1,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of PolygonBridgeFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.808505"
    },
    "RelayFacet.sol": {
      "file_id": "RelayFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "RelayFacet": {
            "name": "RelayFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "RelayData",
                    "name": "_relayData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// check if sendingAsset is native or ERC20\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Native\n\n            // Send Native to relayReceiver along with requestId as extra data\n            (bool success, bytes memory reason) = relayReceiver.call{\n                value: _bridgeData.minAmount\n            }(abi.encode(_relayData.requestId));\n            if (!success) {\n                revert(LibUtil.getRevertMsg(reason));\n            }\n        } else {\n            // ERC20\n\n            // We build the calldata from scratch to ensure that we can only\n            // send to the solver address\n            bytes memory transferCallData = bytes.concat(\n                abi.encodeWithSignature(\n                    \"transfer(address,uint256)\",\n                    relaySolver,\n                    _bridgeData.minAmount\n                ),\n                abi.encode(_relayData.requestId)\n            );\n            (bool success, bytes memory reason) = address(\n                _bridgeData.sendingAssetId\n            ).call(transferCallData);\n            if (!success) {\n                revert(LibUtil.getRevertMsg(reason));\n            }\n        }\n\n        consumedIds[_relayData.requestId] = true;\n\n        // Emit special event if bridging to non-EVM chain\n        if (_bridgeData.receiver == LibAsset.NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _getMappedChainId(_bridgeData.destinationChainId),\n                _relayData.nonEVMReceiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "_getMappedChainId": {
                "name": "_getMappedChainId",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "chainId"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "// Bitcoin\n        if (chainId == 20000000000001) {\n            return 8253038;\n        }\n\n        // Solana\n        if (chainId == 1151111081099710) {\n            return 792703809;\n        }\n\n        return chainId;\n    }"
              }
            },
            "state_variables": {
              "requestId": {
                "name": "requestId",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "nonEVMReceiver": {
                "name": "nonEVMReceiver",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "receivingAssetId": {
                "name": "receivingAssetId",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "signature": {
                "name": "signature",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "message": {
                "name": "message",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "ECDSA.toEthSignedMessageHash(\n            keccak256(\n                abi.encodePacked(\n                    _relayData.requestId,\n                    block.chainid,\n                    bytes32(uint256(uint160(address(this)))),\n                    bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                    _getMappedChainId(_bridgeData.destinationChainId),\n                    _bridgeData.receiver == LibAsset.NON_EVM_ADDRESS\n                        ? _relayData.nonEVMReceiver\n                        : bytes32(uint256(uint160(_bridgeData.receiver))),\n                    _relayData.receivingAssetId\n                )\n            )\n        )"
              },
              "signer": {
                "name": "signer",
                "type": "address",
                "visibility": "internal",
                "initial_value": "ECDSA.recover(message, _relayData.signature)"
              },
              "8253038": {
                "name": "8253038",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "792703809": {
                "name": "792703809",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "chainId": {
                "name": "chainId",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\n\n/// @title Relay Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Relay Protocol\n/// @custom:version 1.0.0\ncontract RelayFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    // Receiver for native transfers\n    address public immutable relayReceiver;\n    // Relayer wallet for ERC20 transfers\n    address public immutable relaySolver;\n\n    /// Storage ///\n\n    mapping(bytes32 => bool) public consumedIds;\n\n    /// Types ///\n\n    /// @dev Relay specific parameters\n    /// @param requestId Relay API request ID\n    /// @param nonEVMReceiver set only if bridging to non-EVM chain\n    /// @params receivingAssetId address of receiving asset\n    /// @params signature attestation signature provided by the Relay solver\n    struct RelayData {\n        bytes32 requestId;\n        bytes32 nonEVMReceiver;\n        bytes32 receivingAssetId;\n        bytes signature;\n    }\n\n    /// Events ///\n\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed destinationChainId,\n        bytes32 receiver\n    );\n\n    /// Errors ///\n\n    error InvalidQuote();\n\n    /// Modifiers ///\n\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _relayData Data specific to Relay\n    modifier onlyValidQuote(\n        ILiFi.BridgeData memory _bridgeData,\n        RelayData calldata _relayData\n    ) {\n        // Ensure that the id isn't already consumed\n        if (consumedIds[_relayData.requestId]) {\n            revert InvalidQuote();\n        }\n\n        // Ensure nonEVMAddress is not empty\n        if (\n            _bridgeData.receiver == LibAsset.NON_EVM_ADDRESS &&\n            _relayData.nonEVMReceiver == bytes32(0)\n        ) {\n            revert InvalidQuote();\n        }\n\n        // Verify that the bridging quote has been signed by the Relay solver\n        // as attested using the attestation API\n        // API URL: https://api.relay.link/requests/{requestId}/signature/v2\n        bytes32 message = ECDSA.toEthSignedMessageHash(\n            keccak256(\n                abi.encodePacked(\n                    _relayData.requestId,\n                    block.chainid,\n                    bytes32(uint256(uint160(address(this)))),\n                    bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                    _getMappedChainId(_bridgeData.destinationChainId),\n                    _bridgeData.receiver == LibAsset.NON_EVM_ADDRESS\n                        ? _relayData.nonEVMReceiver\n                        : bytes32(uint256(uint160(_bridgeData.receiver))),\n                    _relayData.receivingAssetId\n                )\n            )\n        );\n        address signer = ECDSA.recover(message, _relayData.signature);\n        if (signer != relaySolver) {\n            revert InvalidQuote();\n        }\n        _;\n    }\n\n    /// Constructor ///\n\n    /// @param _relayReceiver The receiver for native transfers\n    /// @param _relaySolver The relayer wallet for ERC20 transfers\n    constructor(address _relayReceiver, address _relaySolver) {\n        relayReceiver = _relayReceiver;\n        relaySolver = _relaySolver;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Relay\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _relayData Data specific to Relay\n    function startBridgeTokensViaRelay(\n        ILiFi.BridgeData calldata _bridgeData,\n        RelayData calldata _relayData\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidQuote(_bridgeData, _relayData)\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _relayData);\n    }\n\n    /// @notice Performs a swap before bridging via Relay\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _relayData Data specific to Relay\n    function swapAndStartBridgeTokensViaRelay(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        RelayData calldata _relayData\n    )\n        external\n        payable\n        nonReentrant\n        onlyValidQuote(_bridgeData, _relayData)\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _relayData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Relay\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _relayData Data specific to Relay\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        RelayData calldata _relayData\n    ) internal {\n        // check if sendingAsset is native or ERC20\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Native\n\n            // Send Native to relayReceiver along with requestId as extra data\n            (bool success, bytes memory reason) = relayReceiver.call{\n                value: _bridgeData.minAmount\n            }(abi.encode(_relayData.requestId));\n            if (!success) {\n                revert(LibUtil.getRevertMsg(reason));\n            }\n        } else {\n            // ERC20\n\n            // We build the calldata from scratch to ensure that we can only\n            // send to the solver address\n            bytes memory transferCallData = bytes.concat(\n                abi.encodeWithSignature(\n                    \"transfer(address,uint256)\",\n                    relaySolver,\n                    _bridgeData.minAmount\n                ),\n                abi.encode(_relayData.requestId)\n            );\n            (bool success, bytes memory reason) = address(\n                _bridgeData.sendingAssetId\n            ).call(transferCallData);\n            if (!success) {\n                revert(LibUtil.getRevertMsg(reason));\n            }\n        }\n\n        consumedIds[_relayData.requestId] = true;\n\n        // Emit special event if bridging to non-EVM chain\n        if (_bridgeData.receiver == LibAsset.NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _getMappedChainId(_bridgeData.destinationChainId),\n                _relayData.nonEVMReceiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice get Relay specific chain id for non-EVM chains\n    ///         IDs found here  https://li.quest/v1/chains?chainTypes=UTXO,SVM\n    /// @param chainId LIFI specific chain id\n    function _getMappedChainId(\n        uint256 chainId\n    ) internal pure returns (uint256) {\n        // Bitcoin\n        if (chainId == 20000000000001) {\n            return 8253038;\n        }\n\n        // Solana\n        if (chainId == 1151111081099710) {\n            return 792703809;\n        }\n\n        return chainId;\n    }\n}\n"
      },
      "call_graph": {
        "RelayFacet": {
          "_startBridge": [
            {
              "contract": "RelayFacet",
              "function": "_getMappedChainId"
            }
          ],
          "_getMappedChainId": []
        }
      },
      "flow_data": {
        "RelayFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 2
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 9
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 28
              },
              {
                "type": "if",
                "condition": "_bridgeData.receiver == LibAsset.NON_EVM_ADDRESS",
                "line": 36
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "9": "if (!success)",
              "28": "if (!success)",
              "36": "if (_bridgeData.receiver == LibAsset.NON_EVM_ADDRESS)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "RelayData",
                "name": "_relayData"
              }
            ],
            "returns": []
          },
          "_getMappedChainId": {
            "name": "_getMappedChainId",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "chainId == 20000000000001",
                "line": 2
              },
              {
                "type": "if",
                "condition": "chainId == 1151111081099710",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "chainId",
                "type": "return",
                "value": "= 20000000000001) {\n            return 8253038",
                "line": 2
              },
              {
                "variable": "chainId",
                "type": "return",
                "value": "= 1151111081099710) {\n            return 792703809",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: chainId = = 20000000000001) {\n            return 8253038",
              "7": "State Change: chainId = = 1151111081099710) {\n            return 792703809"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "chainId"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "RelayFacet": {
          "_startBridge": {
            "calls": [
              {
                "contract": "RelayFacet",
                "function": "_getMappedChainId",
                "state_changes": [
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "= 20000000000001) {\n            return 8253038",
                    "line": 2
                  },
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "= 1151111081099710) {\n            return 792703809",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getMappedChainId": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.829550"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.836086"
      },
      "final_report": {
        "file_id": "RelayFacet.sol",
        "timestamp": "2025-03-11T07:05:50.836109",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "RelayFacet": {
            "functions": 2,
            "state_variables": 9,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of RelayFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.836121"
    },
    "SquidFacet.sol": {
      "file_id": "SquidFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "SquidFacet": {
            "name": "SquidFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "SquidData",
                    "name": "_squidData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "BridgeContext memory context = BridgeContext({\n            bridgeData: _bridgeData,\n            squidData: _squidData,\n            msgValue: _calculateMsgValue(_bridgeData, _squidData)\n        });\n\n        // ensure max approval if non-native asset\n        if (!LibAsset.isNativeAsset(context.squidData.depositAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(context.squidData.depositAssetId),\n                address(squidRouter),\n                context.bridgeData.minAmount\n            );\n        }\n\n        // make the call to Squid router based on RouteType\n        if (_squidData.routeType == RouteType.BridgeCall) {\n            _bridgeCall(context);\n        } else if (_squidData.routeType == RouteType.CallBridge) {\n            _callBridge(context);\n        } else if (_squidData.routeType == RouteType.CallBridgeCall) {\n            _callBridgeCall(context);\n        } else {\n            revert InvalidRouteType();\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "_bridgeCall": {
                "name": "_bridgeCall",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "BridgeContext",
                    "name": "_context"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "squidRouter.bridgeCall{ value: _context.msgValue }(\n            _context.squidData.bridgedTokenSymbol,\n            _context.bridgeData.minAmount,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }"
              },
              "_callBridge": {
                "name": "_callBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "BridgeContext",
                    "name": "_context"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "squidRouter.callBridge{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            LibBytes.toHexString(uint160(_context.bridgeData.receiver), 20)\n        );\n    }"
              },
              "_callBridgeCall": {
                "name": "_callBridgeCall",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "BridgeContext",
                    "name": "_context"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "squidRouter.callBridgeCall{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }"
              },
              "_calculateMsgValue": {
                "name": "_calculateMsgValue",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "SquidData",
                    "name": "_squidData"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "uint256 msgValue = _squidData.fee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            msgValue += _bridgeData.minAmount;\n        }\n        return msgValue;\n    }"
              }
            },
            "state_variables": {
              "routeType": {
                "name": "routeType",
                "type": "RouteType",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationChain": {
                "name": "destinationChain",
                "type": "string",
                "visibility": "internal",
                "initial_value": null
              },
              "destinationAddress": {
                "name": "destinationAddress",
                "type": "string",
                "visibility": "internal",
                "initial_value": null
              },
              "bridgedTokenSymbol": {
                "name": "bridgedTokenSymbol",
                "type": "string",
                "visibility": "internal",
                "initial_value": null
              },
              "depositAssetId": {
                "name": "depositAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "payload": {
                "name": "payload",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "fee": {
                "name": "fee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "enableExpress": {
                "name": "enableExpress",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "squidData": {
                "name": "squidData",
                "type": "SquidData",
                "visibility": "internal",
                "initial_value": null
              },
              "msgValue": {
                "name": "msgValue",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISquidRouter } from \"../Interfaces/ISquidRouter.sol\";\nimport { ISquidMulticall } from \"../Interfaces/ISquidMulticall.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibBytes } from \"../Libraries/LibBytes.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @title Squid Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Squid Router\n/// @custom:version 1.0.0\ncontract SquidFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Types ///\n\n    enum RouteType {\n        BridgeCall,\n        CallBridge,\n        CallBridgeCall\n    }\n\n    /// @dev Contains the data needed for bridging via Squid squidRouter\n    /// @param RouteType The type of route to use\n    /// @param destinationChain The chain to bridge tokens to\n    /// @param destinationAddress The receiver address in dst chain format\n    /// @param bridgedTokenSymbol The symbol of the to-be-bridged token\n    /// @param depositAssetId The asset to be deposited on src network (input for optional Squid-internal src swaps)\n    /// @param sourceCalls The calls to be made by Squid on the source chain before bridging the bridgeData.sendingAsssetId token\n    /// @param payload The payload for the calls to be made at dest chain\n    /// @param fee The fee to be payed in native token on src chain\n    /// @param enableExpress enable Squid Router's instant execution service\n    struct SquidData {\n        RouteType routeType;\n        string destinationChain;\n        string destinationAddress; // required to allow future bridging to non-EVM networks\n        string bridgedTokenSymbol;\n        address depositAssetId;\n        ISquidMulticall.Call[] sourceCalls;\n        bytes payload;\n        uint256 fee;\n        bool enableExpress;\n    }\n\n    // introduced to tacke a stack-too-deep error\n    struct BridgeContext {\n        ILiFi.BridgeData bridgeData;\n        SquidData squidData;\n        uint256 msgValue;\n    }\n\n    /// Errors ///\n    error InvalidRouteType();\n\n    /// State ///\n\n    ISquidRouter private immutable squidRouter;\n\n    /// Constructor ///\n\n    constructor(ISquidRouter _squidRouter) {\n        squidRouter = _squidRouter;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _squidData Data specific to Squid Router\n    function startBridgeTokensViaSquid(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _squidData.depositAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _squidData);\n    }\n\n    /// @notice Swaps and bridges tokens via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _squidData Data specific to Squid Router\n    function swapAndStartBridgeTokensViaSquid(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SquidData calldata _squidData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        // in case of native we need to keep the fee as reserve from the swap\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _squidData.fee\n        );\n\n        _startBridge(_bridgeData, _squidData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _squidData Data specific to Squid Router\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    ) internal {\n        BridgeContext memory context = BridgeContext({\n            bridgeData: _bridgeData,\n            squidData: _squidData,\n            msgValue: _calculateMsgValue(_bridgeData, _squidData)\n        });\n\n        // ensure max approval if non-native asset\n        if (!LibAsset.isNativeAsset(context.squidData.depositAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(context.squidData.depositAssetId),\n                address(squidRouter),\n                context.bridgeData.minAmount\n            );\n        }\n\n        // make the call to Squid router based on RouteType\n        if (_squidData.routeType == RouteType.BridgeCall) {\n            _bridgeCall(context);\n        } else if (_squidData.routeType == RouteType.CallBridge) {\n            _callBridge(context);\n        } else if (_squidData.routeType == RouteType.CallBridgeCall) {\n            _callBridgeCall(context);\n        } else {\n            revert InvalidRouteType();\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function _bridgeCall(BridgeContext memory _context) internal {\n        squidRouter.bridgeCall{ value: _context.msgValue }(\n            _context.squidData.bridgedTokenSymbol,\n            _context.bridgeData.minAmount,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }\n\n    function _callBridge(BridgeContext memory _context) private {\n        squidRouter.callBridge{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            LibBytes.toHexString(uint160(_context.bridgeData.receiver), 20)\n        );\n    }\n\n    function _callBridgeCall(BridgeContext memory _context) private {\n        squidRouter.callBridgeCall{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }\n\n    function _calculateMsgValue(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    ) private pure returns (uint256) {\n        uint256 msgValue = _squidData.fee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            msgValue += _bridgeData.minAmount;\n        }\n        return msgValue;\n    }\n}\n"
      },
      "call_graph": {
        "SquidFacet": {
          "_startBridge": [
            {
              "contract": "SquidFacet",
              "function": "_bridgeCall"
            },
            {
              "contract": "SquidFacet",
              "function": "_callBridge"
            },
            {
              "contract": "SquidFacet",
              "function": "_callBridgeCall"
            },
            {
              "contract": "SquidFacet",
              "function": "_calculateMsgValue"
            }
          ],
          "_bridgeCall": [],
          "_callBridge": [],
          "_callBridgeCall": [],
          "_calculateMsgValue": []
        }
      },
      "flow_data": {
        "SquidFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "!LibAsset.isNativeAsset(context.squidData.depositAssetId",
                "line": 8
              },
              {
                "type": "if",
                "condition": "_squidData.routeType == RouteType.BridgeCall",
                "line": 17
              },
              {
                "type": "if",
                "condition": "_squidData.routeType == RouteType.CallBridge",
                "line": 19
              },
              {
                "type": "if",
                "condition": "_squidData.routeType == RouteType.CallBridgeCall",
                "line": 21
              }
            ],
            "state_changes": [
              {
                "variable": "routeType",
                "type": "RouteType",
                "value": "= RouteType.BridgeCall) {\n            _bridgeCall(context)",
                "line": 17
              },
              {
                "variable": "routeType",
                "type": "RouteType",
                "value": "= RouteType.CallBridge) {\n            _callBridge(context)",
                "line": 19
              },
              {
                "variable": "routeType",
                "type": "RouteType",
                "value": "= RouteType.CallBridgeCall) {\n            _callBridgeCall(context)",
                "line": 21
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "8": "if (!LibAsset.isNativeAsset(context.squidData.depositAssetId)",
              "17": "State Change: routeType = = RouteType.BridgeCall) {\n            _bridgeCall(context)",
              "19": "State Change: routeType = = RouteType.CallBridge) {\n            _callBridge(context)",
              "21": "State Change: routeType = = RouteType.CallBridgeCall) {\n            _callBridgeCall(context)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "SquidData",
                "name": "_squidData"
              }
            ],
            "returns": []
          },
          "_bridgeCall": {
            "name": "_bridgeCall",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "BridgeContext",
                "name": "_context"
              }
            ],
            "returns": []
          },
          "_callBridge": {
            "name": "_callBridge",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "BridgeContext",
                "name": "_context"
              }
            ],
            "returns": []
          },
          "_callBridgeCall": {
            "name": "_callBridgeCall",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "BridgeContext",
                "name": "_context"
              }
            ],
            "returns": []
          },
          "_calculateMsgValue": {
            "name": "_calculateMsgValue",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 2
              }
            ],
            "state_changes": [
              {
                "variable": "msgValue",
                "type": "return",
                "value": "_squidData.fee",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "1": "State Change: msgValue = _squidData.fee"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "SquidData",
                "name": "_squidData"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "SquidFacet": {
          "_startBridge": {
            "calls": [
              {
                "contract": "SquidFacet",
                "function": "_bridgeCall",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "SquidFacet",
                "function": "_callBridge",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "SquidFacet",
                "function": "_callBridgeCall",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "SquidFacet",
                "function": "_calculateMsgValue",
                "state_changes": [
                  {
                    "variable": "msgValue",
                    "type": "return",
                    "value": "_squidData.fee",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_bridgeCall": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_callBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_callBridgeCall": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_calculateMsgValue": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.828668"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.832878"
      },
      "final_report": {
        "file_id": "SquidFacet.sol",
        "timestamp": "2025-03-11T07:05:50.832904",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "SquidFacet": {
            "functions": 5,
            "state_variables": 10,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of SquidFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.832917"
    },
    "StandardizedCallFacet.sol": {
      "file_id": "StandardizedCallFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "StandardizedCallFacet": {
            "name": "StandardizedCallFacet",
            "inheritance": [],
            "functions": {
              "standardizedCall": {
                "name": "standardizedCall",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "execute(callData);\n    }"
              },
              "standardizedSwapCall": {
                "name": "standardizedSwapCall",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "execute(callData);\n    }"
              },
              "standardizedBridgeCall": {
                "name": "standardizedBridgeCall",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "execute(callData);\n    }"
              },
              "standardizedSwapAndBridgeCall": {
                "name": "standardizedSwapAndBridgeCall",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "execute(callData);\n    }"
              },
              "execute": {
                "name": "execute",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "callData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Fetch the facetAddress from the dimaond's internal storage\n        // Cheaper than calling the external facetAddress(selector) method directly\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        address facetAddress = ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress;\n\n        if (facetAddress == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // execute function call using the facet\n            let result := delegatecall(\n                gas(),\n                facetAddress,\n                add(callData, 0x20),\n                mload(callData),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }"
              }
            },
            "state_variables": {
              "facetAddress": {
                "name": "facetAddress",
                "type": "address",
                "visibility": "internal",
                "initial_value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Standardized Call Facet\n/// @author LIFI https://li.finance ed@li.finance\n/// @notice Allows calling different facet methods through a single standardized entrypoint\n/// @custom:version 1.1.0\ncontract StandardizedCallFacet {\n    /// External Methods ///\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedSwapCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedBridgeCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedSwapAndBridgeCall(\n        bytes memory callData\n    ) external payable {\n        execute(callData);\n    }\n\n    function execute(bytes memory callData) internal {\n        // Fetch the facetAddress from the dimaond's internal storage\n        // Cheaper than calling the external facetAddress(selector) method directly\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        address facetAddress = ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress;\n\n        if (facetAddress == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // execute function call using the facet\n            let result := delegatecall(\n                gas(),\n                facetAddress,\n                add(callData, 0x20),\n                mload(callData),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
      },
      "call_graph": {
        "StandardizedCallFacet": {
          "standardizedCall": [
            {
              "contract": "StandardizedCallFacet",
              "function": "execute"
            }
          ],
          "standardizedSwapCall": [
            {
              "contract": "StandardizedCallFacet",
              "function": "execute"
            }
          ],
          "standardizedBridgeCall": [
            {
              "contract": "StandardizedCallFacet",
              "function": "execute"
            }
          ],
          "standardizedSwapAndBridgeCall": [
            {
              "contract": "StandardizedCallFacet",
              "function": "execute"
            }
          ],
          "execute": []
        }
      },
      "flow_data": {
        "StandardizedCallFacet": {
          "standardizedCall": {
            "name": "standardizedCall",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "callData"
              }
            ],
            "returns": []
          },
          "standardizedSwapCall": {
            "name": "standardizedSwapCall",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "callData"
              }
            ],
            "returns": []
          },
          "standardizedBridgeCall": {
            "name": "standardizedBridgeCall",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "callData"
              }
            ],
            "returns": []
          },
          "standardizedSwapAndBridgeCall": {
            "name": "standardizedSwapAndBridgeCall",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "callData"
              }
            ],
            "returns": []
          },
          "execute": {
            "name": "execute",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "facetAddress == address(0",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "facetAddress",
                "type": "address",
                "value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress",
                "line": 4
              },
              {
                "variable": "facetAddress",
                "type": "address",
                "value": "= address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
                "line": 8
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "8": "State Change: facetAddress = = address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
              "4": "State Change: facetAddress = ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "callData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "StandardizedCallFacet": {
          "standardizedCall": {
            "calls": [
              {
                "contract": "StandardizedCallFacet",
                "function": "execute",
                "state_changes": [
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress",
                    "line": 4
                  },
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "= address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
                    "line": 8
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "execute": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "standardizedSwapCall": {
            "calls": [
              {
                "contract": "StandardizedCallFacet",
                "function": "execute",
                "state_changes": [
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress",
                    "line": 4
                  },
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "= address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
                    "line": 8
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "standardizedBridgeCall": {
            "calls": [
              {
                "contract": "StandardizedCallFacet",
                "function": "execute",
                "state_changes": [
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress",
                    "line": 4
                  },
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "= address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
                    "line": 8
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "standardizedSwapAndBridgeCall": {
            "calls": [
              {
                "contract": "StandardizedCallFacet",
                "function": "execute",
                "state_changes": [
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress",
                    "line": 4
                  },
                  {
                    "variable": "facetAddress",
                    "type": "address",
                    "value": "= address(0)) {\n            revert LibDiamond.FunctionDoesNotExist()",
                    "line": 8
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.833010"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.840124"
      },
      "final_report": {
        "file_id": "StandardizedCallFacet.sol",
        "timestamp": "2025-03-11T07:05:50.840147",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "StandardizedCallFacet": {
            "functions": 5,
            "state_variables": 1,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of StandardizedCallFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.840159"
    },
    "StargateFacet.sol": {
      "file_id": "StargateFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "StargateFacet": {
            "name": "StargateFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "initStargate": {
                "name": "initStargate",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "ChainIdConfig[]",
                    "name": "chainIdConfigs"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.layerZeroChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .layerZeroChainId;\n        }\n\n        sm.initialized = true;\n\n        emit StargateInitialized(chainIdConfigs);\n    }"
              },
              "quoteLayerZeroFee": {
                "name": "quoteLayerZeroFee",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "_destinationChainId"
                  },
                  {
                    "type": "StargateData",
                    "name": "_stargateData"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  },
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "return\n            composer.quoteLayerZeroFee(\n                getLayerZeroChainId(_destinationChainId),\n                1, // TYPE_SWAP_REMOTE on Bridge\n                _stargateData.callTo,\n                _stargateData.callData,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                )\n            );\n    }"
              },
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "StargateData",
                    "name": "_stargateData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            composer.swapETHAndCall{\n                value: _bridgeData.minAmount + _stargateData.lzFee\n            }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.refundAddress,\n                _stargateData.callTo,\n                IStargateRouter.SwapAmount(\n                    _bridgeData.minAmount,\n                    _stargateData.minAmountLD\n                ),\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callData\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(composer),\n                _bridgeData.minAmount\n            );\n\n            composer.swap{ value: _stargateData.lzFee }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.srcPoolId,\n                _stargateData.dstPoolId,\n                _stargateData.refundAddress,\n                _bridgeData.minAmount,\n                _stargateData.minAmountLD,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callTo,\n                _stargateData.callData\n            );\n        }\n\n        emit PartnerSwap(0x0006);\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "validateDestinationCallFlag": {
                "name": "validateDestinationCallFlag",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "StargateData",
                    "name": "_stargateData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (\n            (_stargateData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }"
              },
              "setLayerZeroChainId": {
                "name": "setLayerZeroChainId",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "_chainId"
                  },
                  {
                    "type": "uint16",
                    "name": "_layerZeroChainId"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.layerZeroChainId[_chainId] = _layerZeroChainId;\n        emit LayerZeroChainIdSet(_chainId, _layerZeroChainId);\n    }"
              },
              "getLayerZeroChainId": {
                "name": "getLayerZeroChainId",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "_chainId"
                  }
                ],
                "returns": [
                  {
                    "type": "uint16"
                  }
                ],
                "modifiers": [],
                "code": "Storage storage sm = getStorage();\n        uint16 chainId = sm.layerZeroChainId[_chainId];\n        if (chainId == 0) revert UnknownLayerZeroChain();\n        return chainId;\n    }"
              },
              "toBytes": {
                "name": "toBytes",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_address"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "return abi.encodePacked(_address);\n    }"
              },
              "getStorage": {
                "name": "getStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "Storage storage s"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }"
              }
            },
            "state_variables": {
              "initialized": {
                "name": "initialized",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "chainId": {
                "name": "chainId",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "layerZeroChainId": {
                "name": "layerZeroChainId",
                "type": "uint16",
                "visibility": "internal",
                "initial_value": null
              },
              "srcPoolId": {
                "name": "srcPoolId",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "dstPoolId": {
                "name": "dstPoolId",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "minAmountLD": {
                "name": "minAmountLD",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "dstGasForCall": {
                "name": "dstGasForCall",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "lzFee": {
                "name": "lzFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "callTo": {
                "name": "callTo",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "callData": {
                "name": "callData",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "namespace": {
                "name": "namespace",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IStargateRouter } from \"../Interfaces/IStargateRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Stargate Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Stargate\n/// @custom:version 2.2.0\ncontract StargateFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// CONSTANTS ///\n\n    /// @notice The contract address of the stargate composer on the source chain.\n    IStargateRouter private immutable composer;\n\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.stargate\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(uint256 => uint16) layerZeroChainId;\n        bool initialized;\n    }\n\n    struct ChainIdConfig {\n        uint256 chainId;\n        uint16 layerZeroChainId;\n    }\n\n    /// @param srcPoolId Source pool id.\n    /// @param dstPoolId Dest pool id.\n    /// @param minAmountLD The min qty you would accept on the destination.\n    /// @param dstGasForCall Additional gas fee for extral call on the destination.\n    /// @param lzFee Estimated message fee.\n    /// @param refundAddress Refund adddress. Extra gas (if any) is returned to this address\n    /// @param callTo The address to send the tokens to on the destination.\n    /// @param callData Additional payload.\n    struct StargateData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minAmountLD;\n        uint256 dstGasForCall;\n        uint256 lzFee;\n        address payable refundAddress;\n        bytes callTo;\n        bytes callData;\n    }\n\n    /// Errors ///\n\n    error UnknownLayerZeroChain();\n\n    /// Events ///\n\n    event StargateInitialized(ChainIdConfig[] chainIdConfigs);\n\n    event LayerZeroChainIdSet(\n        uint256 indexed chainId,\n        uint16 layerZeroChainId\n    );\n\n    /// @notice Emit to get credited for referral\n    /// @dev Our partner id is 0x0006\n    event PartnerSwap(bytes2 partnerId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _composer The contract address of the stargate composer router on the source chain.\n    constructor(IStargateRouter _composer) {\n        composer = _composer;\n    }\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Stargate Facet\n    /// @param chainIdConfigs Chain Id configuration data\n    function initStargate(ChainIdConfig[] calldata chainIdConfigs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.layerZeroChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .layerZeroChainId;\n        }\n\n        sm.initialized = true;\n\n        emit StargateInitialized(chainIdConfigs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function startBridgeTokensViaStargate(\n        ILiFi.BridgeData calldata _bridgeData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// @notice Performs a swap before bridging via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _stargateData Data specific to Stargate Bridge\n    function swapAndStartBridgeTokensViaStargate(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _stargateData.lzFee\n        );\n\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    function quoteLayerZeroFee(\n        uint256 _destinationChainId,\n        StargateData calldata _stargateData\n    ) external view returns (uint256, uint256) {\n        return\n            composer.quoteLayerZeroFee(\n                getLayerZeroChainId(_destinationChainId),\n                1, // TYPE_SWAP_REMOTE on Bridge\n                _stargateData.callTo,\n                _stargateData.callData,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                )\n            );\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            composer.swapETHAndCall{\n                value: _bridgeData.minAmount + _stargateData.lzFee\n            }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.refundAddress,\n                _stargateData.callTo,\n                IStargateRouter.SwapAmount(\n                    _bridgeData.minAmount,\n                    _stargateData.minAmountLD\n                ),\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callData\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(composer),\n                _bridgeData.minAmount\n            );\n\n            composer.swap{ value: _stargateData.lzFee }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.srcPoolId,\n                _stargateData.dstPoolId,\n                _stargateData.refundAddress,\n                _bridgeData.minAmount,\n                _stargateData.minAmountLD,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callTo,\n                _stargateData.callData\n            );\n        }\n\n        emit PartnerSwap(0x0006);\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private pure {\n        if (\n            (_stargateData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n\n    /// Mappings management ///\n\n    /// @notice Sets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint16 of the chain ID\n    /// @param _layerZeroChainId uint16 of the Layer 0 chain ID\n    /// @dev This is used to map a chain ID to its Layer 0 chain ID\n    function setLayerZeroChainId(\n        uint256 _chainId,\n        uint16 _layerZeroChainId\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.layerZeroChainId[_chainId] = _layerZeroChainId;\n        emit LayerZeroChainIdSet(_chainId, _layerZeroChainId);\n    }\n\n    /// @notice Gets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint256 of the chain ID\n    /// @return uint16 of the Layer 0 chain ID\n    function getLayerZeroChainId(\n        uint256 _chainId\n    ) private view returns (uint16) {\n        Storage storage sm = getStorage();\n        uint16 chainId = sm.layerZeroChainId[_chainId];\n        if (chainId == 0) revert UnknownLayerZeroChain();\n        return chainId;\n    }\n\n    function toBytes(address _address) private pure returns (bytes memory) {\n        return abi.encodePacked(_address);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
      },
      "call_graph": {
        "StargateFacet": {
          "initStargate": [
            {
              "contract": "StargateFacet",
              "function": "getStorage"
            }
          ],
          "quoteLayerZeroFee": [
            {
              "contract": "StargateFacet",
              "function": "quoteLayerZeroFee"
            },
            {
              "contract": "StargateFacet",
              "function": "getLayerZeroChainId"
            },
            {
              "contract": "StargateFacet",
              "function": "toBytes"
            }
          ],
          "_startBridge": [
            {
              "contract": "StargateFacet",
              "function": "getLayerZeroChainId"
            },
            {
              "contract": "StargateFacet",
              "function": "toBytes"
            }
          ],
          "validateDestinationCallFlag": [],
          "setLayerZeroChainId": [
            {
              "contract": "StargateFacet",
              "function": "getStorage"
            }
          ],
          "getLayerZeroChainId": [
            {
              "contract": "StargateFacet",
              "function": "getStorage"
            }
          ],
          "toBytes": [],
          "getStorage": []
        }
      },
      "flow_data": {
        "StargateFacet": {
          "initStargate": {
            "name": "initStargate",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < chainIdConfigs.length; i++",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "initialized",
                "type": "bool",
                "value": "true",
                "line": 10
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "for (uint256 i = 0; i < chainIdConfigs.length; i++)",
              "10": "State Change: initialized = true"
            },
            "parameters": [
              {
                "type": "ChainIdConfig[]",
                "name": "chainIdConfigs"
              }
            ],
            "returns": []
          },
          "quoteLayerZeroFee": {
            "name": "quoteLayerZeroFee",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "uint256",
                "name": "_destinationChainId"
              },
              {
                "type": "StargateData",
                "name": "_stargateData"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              },
              {
                "type": "uint256"
              }
            ]
          },
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "StargateData",
                "name": "_stargateData"
              }
            ],
            "returns": []
          },
          "validateDestinationCallFlag": {
            "name": "validateDestinationCallFlag",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "(_stargateData.callData.length > 0",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if ((_stargateData.callData.length > 0)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "StargateData",
                "name": "_stargateData"
              }
            ],
            "returns": []
          },
          "setLayerZeroChainId": {
            "name": "setLayerZeroChainId",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "!sm.initialized",
                "line": 4
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (!sm.initialized)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "_chainId"
              },
              {
                "type": "uint16",
                "name": "_layerZeroChainId"
              }
            ],
            "returns": []
          },
          "getLayerZeroChainId": {
            "name": "getLayerZeroChainId",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "chainId == 0",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "chainId",
                "type": "return",
                "value": "sm.layerZeroChainId[_chainId]",
                "line": 2
              },
              {
                "variable": "chainId",
                "type": "return",
                "value": "= 0) revert UnknownLayerZeroChain()",
                "line": 3
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "State Change: chainId = = 0) revert UnknownLayerZeroChain()",
              "2": "State Change: chainId = sm.layerZeroChainId[_chainId]"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "_chainId"
              }
            ],
            "returns": [
              {
                "type": "uint16"
              }
            ]
          },
          "toBytes": {
            "name": "toBytes",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "_address"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "getStorage": {
            "name": "getStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "namespace",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: namespace = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "Storage storage s"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "StargateFacet": {
          "initStargate": {
            "calls": [
              {
                "contract": "StargateFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "quoteLayerZeroFee": {
            "calls": [
              {
                "contract": "StargateFacet",
                "function": "quoteLayerZeroFee",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "StargateFacet",
                "function": "getLayerZeroChainId",
                "state_changes": [
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "sm.layerZeroChainId[_chainId]",
                    "line": 2
                  },
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "= 0) revert UnknownLayerZeroChain()",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "StargateFacet",
                "function": "toBytes",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [
              {
                "contract": "StargateFacet",
                "function": "quoteLayerZeroFee"
              }
            ],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getLayerZeroChainId": {
            "calls": [
              {
                "contract": "StargateFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "toBytes": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_startBridge": {
            "calls": [
              {
                "contract": "StargateFacet",
                "function": "getLayerZeroChainId",
                "state_changes": [
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "sm.layerZeroChainId[_chainId]",
                    "line": 2
                  },
                  {
                    "variable": "chainId",
                    "type": "return",
                    "value": "= 0) revert UnknownLayerZeroChain()",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "StargateFacet",
                "function": "toBytes",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "validateDestinationCallFlag": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "setLayerZeroChainId": {
            "calls": [
              {
                "contract": "StargateFacet",
                "function": "getStorage",
                "state_changes": [
                  {
                    "variable": "namespace",
                    "type": "bytes32",
                    "value": "NAMESPACE",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.836240"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.841470"
      },
      "final_report": {
        "file_id": "StargateFacet.sol",
        "timestamp": "2025-03-11T07:05:50.841495",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "StargateFacet": {
            "functions": 8,
            "state_variables": 11,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of StargateFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.841508"
    },
    "StargateFacetV2.sol": {
      "file_id": "StargateFacetV2.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "StargateFacetV2": {
            "name": "StargateFacetV2",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "StargateData",
                    "name": "_stargateData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// validate destination call flag\n        if (\n            (_stargateData.sendParams.composeMsg.length > 0 !=\n                _bridgeData.hasDestinationCall) ||\n            (_bridgeData.hasDestinationCall &&\n                _stargateData.sendParams.oftCmd.length != 0)\n        ) revert InformationMismatch();\n\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver !=\n                address(uint160(uint256(_stargateData.sendParams.to))))\n        ) revert InformationMismatch();\n\n        // get the router-/pool address through the TokenMessaging contract\n        address routerAddress = tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        );\n        if (routerAddress == address(0))\n            revert InvalidAssetId(_stargateData.assetId);\n\n        // check if NATIVE or ERC20\n        uint256 msgValue = _stargateData.fee.nativeFee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // NATIVE\n            // add minAmount to msgValue\n            msgValue += _bridgeData.minAmount;\n        } else {\n            // ERC20\n            // check current allowance to router\n            address sendingAssetId = _bridgeData.sendingAssetId;\n            uint256 currentAllowance = ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            );\n            // check if allowance is sufficient\n            if (currentAllowance < _bridgeData.minAmount) {\n                // check if allowance is 0\n                if (currentAllowance != 0) {\n                    sendingAssetId.safeApprove(routerAddress, 0);\n                }\n                // set allowance to uintMax\n                sendingAssetId.safeApprove(routerAddress, type(uint256).max);\n            }\n        }\n\n        // update amount in sendParams\n        _stargateData.sendParams.amountLD = _bridgeData.minAmount;\n\n        // execute call to Stargate router\n        IStargate(routerAddress).sendToken{ value: msgValue }(\n            _stargateData.sendParams,\n            _stargateData.fee,\n            _stargateData.refundAddress\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "assetId": {
                "name": "assetId",
                "type": "uint16",
                "visibility": "internal",
                "initial_value": null
              },
              "routerAddress": {
                "name": "routerAddress",
                "type": "address",
                "visibility": "internal",
                "initial_value": "tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        )"
              },
              "msgValue": {
                "name": "msgValue",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_stargateData.fee.nativeFee"
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_bridgeData.sendingAssetId"
              },
              "currentAllowance": {
                "name": "currentAllowance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            )"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IStargate, ITokenMessaging } from \"../Interfaces/IStargate.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"solady/tokens/ERC20.sol\";\n\n/// @title StargateFacetV2\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Stargate (V2)\n/// @custom:version 1.0.1\ncontract StargateFacetV2 is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    using SafeTransferLib for address;\n\n    /// STORAGE ///\n    ITokenMessaging public immutable tokenMessaging;\n\n    /// @param assetId The Stargate-specific assetId for the token that should be bridged\n    /// @param sendParams Various parameters that describe what needs to be bridged, how to bridge it and what to do with it on dst\n    /// @param fee Information about the (native) LayerZero fee that needs to be sent with the tx\n    /// @param refundAddress the address that is used for potential refunds\n    struct StargateData {\n        uint16 assetId;\n        IStargate.SendParam sendParams;\n        IStargate.MessagingFee fee;\n        address payable refundAddress;\n    }\n\n    /// ERRORS ///\n    error InvalidAssetId(uint16 invalidAssetId);\n\n    /// CONSTRUCTOR ///\n    /// @param _tokenMessaging The address of the tokenMessaging contract (used to obtain pool addresses)\n    constructor(address _tokenMessaging) {\n        tokenMessaging = ITokenMessaging(_tokenMessaging);\n    }\n\n    /// EXTERNAL METHODS ///\n\n    /// @notice Bridges tokens via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function startBridgeTokensViaStargate(\n        ILiFi.BridgeData calldata _bridgeData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// @notice Performs a swap before bridging via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _stargateData Data specific to Stargate Bridge\n    function swapAndStartBridgeTokensViaStargate(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _stargateData.fee.nativeFee\n        );\n\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// PRIVATE METHODS ///\n\n    /// @dev Contains the business logic for the bridging via StargateV2\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData memory _stargateData\n    ) private {\n        // validate destination call flag\n        if (\n            (_stargateData.sendParams.composeMsg.length > 0 !=\n                _bridgeData.hasDestinationCall) ||\n            (_bridgeData.hasDestinationCall &&\n                _stargateData.sendParams.oftCmd.length != 0)\n        ) revert InformationMismatch();\n\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver !=\n                address(uint160(uint256(_stargateData.sendParams.to))))\n        ) revert InformationMismatch();\n\n        // get the router-/pool address through the TokenMessaging contract\n        address routerAddress = tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        );\n        if (routerAddress == address(0))\n            revert InvalidAssetId(_stargateData.assetId);\n\n        // check if NATIVE or ERC20\n        uint256 msgValue = _stargateData.fee.nativeFee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // NATIVE\n            // add minAmount to msgValue\n            msgValue += _bridgeData.minAmount;\n        } else {\n            // ERC20\n            // check current allowance to router\n            address sendingAssetId = _bridgeData.sendingAssetId;\n            uint256 currentAllowance = ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            );\n            // check if allowance is sufficient\n            if (currentAllowance < _bridgeData.minAmount) {\n                // check if allowance is 0\n                if (currentAllowance != 0) {\n                    sendingAssetId.safeApprove(routerAddress, 0);\n                }\n                // set allowance to uintMax\n                sendingAssetId.safeApprove(routerAddress, type(uint256).max);\n            }\n        }\n\n        // update amount in sendParams\n        _stargateData.sendParams.amountLD = _bridgeData.minAmount;\n\n        // execute call to Stargate router\n        IStargate(routerAddress).sendToken{ value: msgValue }(\n            _stargateData.sendParams,\n            _stargateData.fee,\n            _stargateData.refundAddress\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "StargateFacetV2": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "StargateFacetV2": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "(_stargateData.sendParams.composeMsg.length > 0 !=\n                _bridgeData.hasDestinationCall",
                "line": 2
              },
              {
                "type": "if",
                "condition": "!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver !=\n                address(uint160(uint256(_stargateData.sendParams.to",
                "line": 10
              },
              {
                "type": "if",
                "condition": "routerAddress == address(0",
                "line": 20
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId",
                "line": 25
              },
              {
                "type": "if",
                "condition": "currentAllowance < _bridgeData.minAmount",
                "line": 38
              },
              {
                "type": "if",
                "condition": "currentAllowance != 0",
                "line": 40
              }
            ],
            "state_changes": [
              {
                "variable": "routerAddress",
                "type": "address",
                "value": "tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        )",
                "line": 17
              },
              {
                "variable": "routerAddress",
                "type": "address",
                "value": "= address(0))\n            revert InvalidAssetId(_stargateData.assetId)",
                "line": 20
              },
              {
                "variable": "msgValue",
                "type": "uint256",
                "value": "_stargateData.fee.nativeFee",
                "line": 24
              },
              {
                "variable": "sendingAssetId",
                "type": "address",
                "value": "_bridgeData.sendingAssetId",
                "line": 32
              },
              {
                "variable": "currentAllowance",
                "type": "uint256",
                "value": "ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            )",
                "line": 33
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if ((_stargateData.sendParams.composeMsg.length > 0 !=\n                _bridgeData.hasDestinationCall)",
              "10": "if (!_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver !=\n                address(uint160(uint256(_stargateData.sendParams.to)",
              "20": "State Change: routerAddress = = address(0))\n            revert InvalidAssetId(_stargateData.assetId)",
              "25": "if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "38": "if (currentAllowance < _bridgeData.minAmount)",
              "40": "if (currentAllowance != 0)",
              "17": "State Change: routerAddress = tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        )",
              "24": "State Change: msgValue = _stargateData.fee.nativeFee",
              "32": "State Change: sendingAssetId = _bridgeData.sendingAssetId",
              "33": "State Change: currentAllowance = ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            )"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "StargateData",
                "name": "_stargateData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "StargateFacetV2": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.837860"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.845441"
      },
      "final_report": {
        "file_id": "StargateFacetV2.sol",
        "timestamp": "2025-03-11T07:05:50.845467",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "StargateFacetV2": {
            "functions": 1,
            "state_variables": 5,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of StargateFacetV2.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.845479"
    },
    "SymbiosisFacet.sol": {
      "file_id": "SymbiosisFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "SymbiosisFacet": {
            "name": "SymbiosisFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "SymbiosisData",
                    "name": "_symbiosisData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount;\n\n        if (isNative) {\n            nativeAssetAmount = _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                symbiosisGateway,\n                _bridgeData.minAmount\n            );\n        }\n\n        symbiosisMetaRouter.metaRoute{ value: nativeAssetAmount }(\n            ISymbiosisMetaRouter.MetaRouteTransaction(\n                _symbiosisData.firstSwapCalldata,\n                _symbiosisData.secondSwapCalldata,\n                _symbiosisData.approvedTokens,\n                _symbiosisData.firstDexRouter,\n                _symbiosisData.secondDexRouter,\n                _bridgeData.minAmount,\n                isNative,\n                _symbiosisData.callTo,\n                _symbiosisData.callData\n            )\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "firstSwapCalldata": {
                "name": "firstSwapCalldata",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "secondSwapCalldata": {
                "name": "secondSwapCalldata",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "intermediateToken": {
                "name": "intermediateToken",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "firstDexRouter": {
                "name": "firstDexRouter",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "secondDexRouter": {
                "name": "secondDexRouter",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "approvedTokens": {
                "name": "approvedTokens",
                "type": "address[]",
                "visibility": "internal",
                "initial_value": null
              },
              "callTo": {
                "name": "callTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "callData": {
                "name": "callData",
                "type": "bytes",
                "visibility": "internal",
                "initial_value": null
              },
              "isNative": {
                "name": "isNative",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId)"
              },
              "nativeAssetAmount": {
                "name": "nativeAssetAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISymbiosisMetaRouter } from \"../Interfaces/ISymbiosisMetaRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Symbiosis Facet\n/// @author Symbiosis (https://symbiosis.finance)\n/// @notice Provides functionality for bridging through Symbiosis Protocol\n/// @custom:version 1.0.0\ncontract SymbiosisFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the Symbiosis router on the source chain\n    ISymbiosisMetaRouter private immutable symbiosisMetaRouter;\n    address private immutable symbiosisGateway;\n\n    /// Types ///\n\n    /// @notice The data specific to Symbiosis\n    /// @param firstSwapCalldata The calldata for the first swap\n    /// @param secondSwapCalldata The calldata for the second swap\n    /// @param intermediateToken The intermediate token used for swapping\n    /// @param firstDexRouter The router for the first swap\n    /// @param secondDexRouter The router for the second swap\n    /// @param approvedTokens The tokens approved for swapping\n    /// @param callTo The bridging entrypoint\n    /// @param callData The bridging calldata\n    struct SymbiosisData {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address intermediateToken;\n        address firstDexRouter;\n        address secondDexRouter;\n        address[] approvedTokens;\n        address callTo;\n        bytes callData;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _symbiosisMetaRouter The contract address of the Symbiosis MetaRouter on the source chain.\n    /// @param _symbiosisGateway The contract address of the Symbiosis Gateway on the source chain.\n    constructor(\n        ISymbiosisMetaRouter _symbiosisMetaRouter,\n        address _symbiosisGateway\n    ) {\n        symbiosisMetaRouter = _symbiosisMetaRouter;\n        symbiosisGateway = _symbiosisGateway;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function startBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before bridging via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function swapAndStartBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// @dev Contains the business logic for the bridge via Symbiosis\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _symbiosisData data specific to Symbiosis\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    ) internal {\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount;\n\n        if (isNative) {\n            nativeAssetAmount = _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                symbiosisGateway,\n                _bridgeData.minAmount\n            );\n        }\n\n        symbiosisMetaRouter.metaRoute{ value: nativeAssetAmount }(\n            ISymbiosisMetaRouter.MetaRouteTransaction(\n                _symbiosisData.firstSwapCalldata,\n                _symbiosisData.secondSwapCalldata,\n                _symbiosisData.approvedTokens,\n                _symbiosisData.firstDexRouter,\n                _symbiosisData.secondDexRouter,\n                _bridgeData.minAmount,\n                isNative,\n                _symbiosisData.callTo,\n                _symbiosisData.callData\n            )\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "SymbiosisFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "SymbiosisFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "isNative",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "isNative",
                "type": "bool",
                "value": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
                "line": 1
              },
              {
                "variable": "nativeAssetAmount",
                "type": "uint256",
                "value": "_bridgeData.minAmount",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (isNative)",
              "1": "State Change: isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)",
              "5": "State Change: nativeAssetAmount = _bridgeData.minAmount"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "SymbiosisData",
                "name": "_symbiosisData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "SymbiosisFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.847835"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.850758"
      },
      "final_report": {
        "file_id": "SymbiosisFacet.sol",
        "timestamp": "2025-03-11T07:05:50.850786",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "SymbiosisFacet": {
            "functions": 1,
            "state_variables": 10,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of SymbiosisFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.850800"
    },
    "ThorSwapFacet.sol": {
      "file_id": "ThorSwapFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ThorSwapFacet": {
            "name": "ThorSwapFacet",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "ThorSwapData",
                    "name": "_thorSwapData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (\n            block.chainid == 1 && _bridgeData.sendingAssetId == DEPRECATED_RUNE\n        ) {\n            revert DeprecatedToken();\n        }\n\n        IERC20 sendingAssetId = IERC20(_bridgeData.sendingAssetId);\n        bool isNative = LibAsset.isNativeAsset(address(sendingAssetId));\n\n        if (!isNative) {\n            LibAsset.maxApproveERC20(\n                sendingAssetId,\n                thorchainRouter,\n                _bridgeData.minAmount\n            );\n        }\n        IThorSwap(thorchainRouter).depositWithExpiry{\n            value: isNative ? _bridgeData.minAmount : 0\n        }(\n            _thorSwapData.vault,\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            _thorSwapData.memo,\n            _thorSwapData.expiration\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              }
            },
            "state_variables": {
              "vault": {
                "name": "vault",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "memo": {
                "name": "memo",
                "type": "string",
                "visibility": "internal",
                "initial_value": null
              },
              "expiration": {
                "name": "expiration",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "sendingAssetId": {
                "name": "sendingAssetId",
                "type": "IERC20",
                "visibility": "internal",
                "initial_value": "IERC20(_bridgeData.sendingAssetId)"
              },
              "isNative": {
                "name": "isNative",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(address(sendingAssetId))"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IThorSwap } from \"../Interfaces/IThorSwap.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ContractCallNotAllowed } from \"../Errors/GenericErrors.sol\";\n\n/// @title ThorSwap Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through ThorSwap\n/// @custom:version 1.2.1\ncontract ThorSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    address private immutable thorchainRouter;\n\n    address private constant DEPRECATED_RUNE =\n        0x3155BA85D5F96b2d030a4966AF206230e46849cb;\n\n    /// @notice The struct for the ThorSwap data.\n    /// @param vault The Thorchain vault address\n    /// @param memo The memo to send to Thorchain for the swap\n    /// @param expiration The expiration time for the swap\n    struct ThorSwapData {\n        address vault;\n        string memo;\n        uint256 expiration;\n    }\n\n    error DeprecatedToken();\n\n    /// @notice Initializes the ThorSwap contract\n    constructor(address _thorchainRouter) {\n        thorchainRouter = _thorchainRouter;\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function startBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function swapAndStartBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The thorSwap data struct for ThorSwap specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    ) internal {\n        if (\n            block.chainid == 1 && _bridgeData.sendingAssetId == DEPRECATED_RUNE\n        ) {\n            revert DeprecatedToken();\n        }\n\n        IERC20 sendingAssetId = IERC20(_bridgeData.sendingAssetId);\n        bool isNative = LibAsset.isNativeAsset(address(sendingAssetId));\n\n        if (!isNative) {\n            LibAsset.maxApproveERC20(\n                sendingAssetId,\n                thorchainRouter,\n                _bridgeData.minAmount\n            );\n        }\n        IThorSwap(thorchainRouter).depositWithExpiry{\n            value: isNative ? _bridgeData.minAmount : 0\n        }(\n            _thorSwapData.vault,\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            _thorSwapData.memo,\n            _thorSwapData.expiration\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
      },
      "call_graph": {
        "ThorSwapFacet": {
          "_startBridge": []
        }
      },
      "flow_data": {
        "ThorSwapFacet": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "block.chainid == 1 && _bridgeData.sendingAssetId == DEPRECATED_RUNE",
                "line": 1
              },
              {
                "type": "if",
                "condition": "!isNative",
                "line": 10
              }
            ],
            "state_changes": [
              {
                "variable": "sendingAssetId",
                "type": "IERC20",
                "value": "= DEPRECATED_RUNE\n        ) {\n            revert DeprecatedToken()",
                "line": 2
              },
              {
                "variable": "sendingAssetId",
                "type": "IERC20",
                "value": "IERC20(_bridgeData.sendingAssetId)",
                "line": 7
              },
              {
                "variable": "isNative",
                "type": "bool",
                "value": "LibAsset.isNativeAsset(address(sendingAssetId))",
                "line": 8
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (block.chainid == 1 && _bridgeData.sendingAssetId == DEPRECATED_RUNE)",
              "10": "if (!isNative)",
              "2": "State Change: sendingAssetId = = DEPRECATED_RUNE\n        ) {\n            revert DeprecatedToken()",
              "7": "State Change: sendingAssetId = IERC20(_bridgeData.sendingAssetId)",
              "8": "State Change: isNative = LibAsset.isNativeAsset(address(sendingAssetId))"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "ThorSwapData",
                "name": "_thorSwapData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "ThorSwapFacet": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.900517"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.904018"
      },
      "final_report": {
        "file_id": "ThorSwapFacet.sol",
        "timestamp": "2025-03-11T07:05:50.904042",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ThorSwapFacet": {
            "functions": 1,
            "state_variables": 5,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ThorSwapFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.904055"
    },
    "WithdrawFacet.sol": {
      "file_id": "WithdrawFacet.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "WithdrawFacet": {
            "name": "WithdrawFacet",
            "inheritance": [],
            "functions": {
              "executeCallAndWithdraw": {
                "name": "executeCallAndWithdraw",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_callTo"
                  },
                  {
                    "type": "bytes",
                    "name": "_callData"
                  },
                  {
                    "type": "address",
                    "name": "_assetAddress"
                  },
                  {
                    "type": "address",
                    "name": "_to"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // Check if the _callTo is a contract\n        bool success;\n        bool isContract = LibAsset.isContract(_callTo);\n        if (!isContract) revert NotAContract();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        if (success) {\n            _withdrawAsset(_assetAddress, _to, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }"
              },
              "withdraw": {
                "name": "withdraw",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_assetAddress"
                  },
                  {
                    "type": "address",
                    "name": "_to"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        _withdrawAsset(_assetAddress, _to, _amount);\n    }"
              },
              "_withdrawAsset": {
                "name": "_withdrawAsset",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_assetAddress"
                  },
                  {
                    "type": "address",
                    "name": "_to"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit LogWithdraw(_assetAddress, sendTo, _amount);\n    }"
              }
            },
            "state_variables": {
              "success": {
                "name": "success",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "isContract": {
                "name": "isContract",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "LibAsset.isContract(_callTo)"
              },
              "sendTo": {
                "name": "sendTo",
                "type": "address",
                "visibility": "internal",
                "initial_value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { NotAContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Withdraw Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Allows admin to withdraw funds that are kept in the contract by accident\n/// @custom:version 1.0.0\ncontract WithdrawFacet {\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Events ///\n\n    event LogWithdraw(\n        address indexed _assetAddress,\n        address _to,\n        uint256 amount\n    );\n\n    /// External Methods ///\n\n    /// @notice Execute call data and withdraw asset.\n    /// @param _callTo The address to execute the calldata on.\n    /// @param _callData The data to execute.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function executeCallAndWithdraw(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // Check if the _callTo is a contract\n        bool success;\n        bool isContract = LibAsset.isContract(_callTo);\n        if (!isContract) revert NotAContract();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        if (success) {\n            _withdrawAsset(_assetAddress, _to, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function withdraw(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        _withdrawAsset(_assetAddress, _to, _amount);\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function _withdrawAsset(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) internal {\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit LogWithdraw(_assetAddress, sendTo, _amount);\n    }\n}\n"
      },
      "call_graph": {
        "WithdrawFacet": {
          "executeCallAndWithdraw": [
            {
              "contract": "WithdrawFacet",
              "function": "_withdrawAsset"
            }
          ],
          "withdraw": [
            {
              "contract": "WithdrawFacet",
              "function": "_withdrawAsset"
            }
          ],
          "_withdrawAsset": []
        }
      },
      "flow_data": {
        "WithdrawFacet": {
          "executeCallAndWithdraw": {
            "name": "executeCallAndWithdraw",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              },
              {
                "type": "if",
                "condition": "!isContract",
                "line": 8
              },
              {
                "type": "if",
                "condition": "success",
                "line": 13
              }
            ],
            "state_changes": [
              {
                "variable": "isContract",
                "type": "bool",
                "value": "LibAsset.isContract(_callTo)",
                "line": 7
              }
            ],
            "external_calls": [
              {
                "target": "_callTo",
                "type": "call",
                "arguments": "_callData",
                "line": 11
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()",
              "8": "if (!isContract)",
              "13": "if (success)",
              "7": "State Change: isContract = LibAsset.isContract(_callTo)",
              "11": "External Call: _callTo.call(_callData)"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_callTo"
              },
              {
                "type": "bytes",
                "name": "_callData"
              },
              {
                "type": "address",
                "name": "_assetAddress"
              },
              {
                "type": "address",
                "name": "_to"
              },
              {
                "type": "uint256",
                "name": "_amount"
              }
            ],
            "returns": []
          },
          "withdraw": {
            "name": "withdraw",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != LibDiamond.contractOwner(",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.sender != LibDiamond.contractOwner()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_assetAddress"
              },
              {
                "type": "address",
                "name": "_to"
              },
              {
                "type": "uint256",
                "name": "_amount"
              }
            ],
            "returns": []
          },
          "_withdrawAsset": {
            "name": "_withdrawAsset",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "sendTo",
                "type": "address",
                "value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_assetAddress"
              },
              {
                "type": "address",
                "name": "_to"
              },
              {
                "type": "uint256",
                "name": "_amount"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "WithdrawFacet": {
          "executeCallAndWithdraw": {
            "calls": [
              {
                "contract": "WithdrawFacet",
                "function": "_withdrawAsset",
                "state_changes": [
                  {
                    "variable": "sendTo",
                    "type": "address",
                    "value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_withdrawAsset": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "withdraw": {
            "calls": [
              {
                "contract": "WithdrawFacet",
                "function": "_withdrawAsset",
                "state_changes": [
                  {
                    "variable": "sendTo",
                    "type": "address",
                    "value": "(LibUtil.isZeroAddress(_to)) ? msg.sender : _to",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.900804"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.905509"
      },
      "final_report": {
        "file_id": "WithdrawFacet.sol",
        "timestamp": "2025-03-11T07:05:50.905534",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "WithdrawFacet": {
            "functions": 3,
            "state_variables": 3,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of WithdrawFacet.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.905546"
    },
    "CelerIMFacetBase.sol": {
      "file_id": "CelerIMFacetBase.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "CelerIMFacetBase": {
            "name": "CelerIMFacetBase",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ],
            "functions": {
              "_startBridge": {
                "name": "_startBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "CelerIM.CelerIMData",
                    "name": "_celerIMData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// Assuming messageBusFee is pre-calculated off-chain and available in _celerIMData\n        // Determine correct native asset amount to be forwarded (if so) and send funds to relayer\n        uint256 msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0;\n\n        // Check if transaction contains a destination call\n        if (!_bridgeData.hasDestinationCall) {\n            // Case 'no': Simple bridge transfer - Send to receiver\n            relayer.sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n        } else {\n            // Case 'yes': Bridge + Destination call - Send to relayer\n\n            // save address of original recipient\n            address receiver = _bridgeData.receiver;\n\n            // Set relayer as a receiver\n            _bridgeData.receiver = address(relayer);\n\n            // send token transfer\n            (bytes32 transferId, address bridgeAddress) = relayer\n                .sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n\n            // Call message bus via relayer incl messageBusFee\n            relayer.forwardSendMessageWithTransfer{\n                value: _celerIMData.messageBusFee\n            }(\n                _bridgeData.receiver,\n                uint64(_bridgeData.destinationChainId),\n                bridgeAddress,\n                transferId,\n                _celerIMData.callData\n            );\n\n            // Reset receiver of bridge data for event emission\n            _bridgeData.receiver = receiver;\n        }\n\n        // emit LiFi event\n        emit LiFiTransferStarted(_bridgeData);\n    }"
              },
              "_getRightAsset": {
                "name": "_getRightAsset",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "address",
                    "name": "_sendingAssetId"
                  }
                ],
                "returns": [
                  {
                    "type": "IERC20 _asset"
                  }
                ],
                "modifiers": [],
                "code": "if (_sendingAssetId == cfUSDC) {\n            // special case for cfUSDC token\n            _asset = IERC20(CelerToken(_sendingAssetId).canonical());\n        } else {\n            // any other ERC20 token\n            _asset = IERC20(_sendingAssetId);\n        }\n    }"
              },
              "validateDestinationCallFlag": {
                "name": "validateDestinationCallFlag",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "ILiFi.BridgeData",
                    "name": "_bridgeData"
                  },
                  {
                    "type": "CelerIM.CelerIMData",
                    "name": "_celerIMData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (\n            (_celerIMData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }"
              }
            },
            "state_variables": {
              "asset": {
                "name": "asset",
                "type": "IERC20",
                "visibility": "internal",
                "initial_value": "_getRightAsset(_bridgeData.sendingAssetId)"
              },
              "prevBalance": {
                "name": "prevBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "asset.balanceOf(address(relayer))"
              },
              "msgValue": {
                "name": "msgValue",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0"
              },
              "receiver": {
                "name": "receiver",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_bridgeData.receiver"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { InvalidAmount, InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus } from \"celer-network/contracts/message/libraries/MessageSenderLib.sol\";\nimport { RelayerCelerIM } from \"lifi/Periphery/RelayerCelerIM.sol\";\n\ninterface CelerToken {\n    function canonical() external returns (address);\n}\n\ninterface CelerIM {\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param callTo The address of the contract to be called at destination.\n    /// @param callData The encoded calldata with below data\n    ///                 bytes32 transactionId,\n    ///                 LibSwap.SwapData[] memory swapData,\n    ///                 address receiver,\n    ///                 address refundAddress\n    /// @param messageBusFee The fee to be paid to CBridge message bus for relaying the message\n    /// @param bridgeType Defines the bridge operation type (must be one of the values of CBridge library MsgDataTypes.BridgeSendType)\n    struct CelerIMData {\n        uint32 maxSlippage;\n        uint64 nonce;\n        bytes callTo;\n        bytes callData;\n        uint256 messageBusFee;\n        MsgDataTypes.BridgeSendType bridgeType;\n    }\n}\n\n/// @title CelerIM Facet Base\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice Used to differentiate between contract instances for mutable and immutable diamond as these cannot be shared\n/// @custom:version 2.0.0\nabstract contract CelerIMFacetBase is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @dev The contract address of the cBridge Message Bus\n    IMessageBus private immutable cBridgeMessageBus;\n\n    /// @dev The contract address of the RelayerCelerIM\n    RelayerCelerIM public immutable relayer;\n\n    /// @dev The contract address of the Celer Flow USDC\n    address private immutable cfUSDC;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) {\n        // deploy RelayerCelerIM\n        relayer = new RelayerCelerIM(\n            address(_messageBus),\n            _relayerOwner,\n            _diamondAddress\n        );\n\n        // store arguments in variables\n        cBridgeMessageBus = _messageBus;\n        cfUSDC = _cfUSDC;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function startBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransferFrom(\n                asset,\n                msg.sender,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function swapAndStartBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _celerIMData.messageBusFee\n        );\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransfer(\n                asset,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private {\n        // Assuming messageBusFee is pre-calculated off-chain and available in _celerIMData\n        // Determine correct native asset amount to be forwarded (if so) and send funds to relayer\n        uint256 msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0;\n\n        // Check if transaction contains a destination call\n        if (!_bridgeData.hasDestinationCall) {\n            // Case 'no': Simple bridge transfer - Send to receiver\n            relayer.sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n        } else {\n            // Case 'yes': Bridge + Destination call - Send to relayer\n\n            // save address of original recipient\n            address receiver = _bridgeData.receiver;\n\n            // Set relayer as a receiver\n            _bridgeData.receiver = address(relayer);\n\n            // send token transfer\n            (bytes32 transferId, address bridgeAddress) = relayer\n                .sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n\n            // Call message bus via relayer incl messageBusFee\n            relayer.forwardSendMessageWithTransfer{\n                value: _celerIMData.messageBusFee\n            }(\n                _bridgeData.receiver,\n                uint64(_bridgeData.destinationChainId),\n                bridgeAddress,\n                transferId,\n                _celerIMData.callData\n            );\n\n            // Reset receiver of bridge data for event emission\n            _bridgeData.receiver = receiver;\n        }\n\n        // emit LiFi event\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev Get right asset to transfer to relayer.\n    /// @param _sendingAssetId The address of asset to bridge.\n    /// @return _asset The address of asset to transfer to relayer.\n    function _getRightAsset(\n        address _sendingAssetId\n    ) private returns (IERC20 _asset) {\n        if (_sendingAssetId == cfUSDC) {\n            // special case for cfUSDC token\n            _asset = IERC20(CelerToken(_sendingAssetId).canonical());\n        } else {\n            // any other ERC20 token\n            _asset = IERC20(_sendingAssetId);\n        }\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private pure {\n        if (\n            (_celerIMData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
      },
      "call_graph": {
        "CelerIMFacetBase": {
          "_startBridge": [],
          "_getRightAsset": [],
          "validateDestinationCallFlag": []
        }
      },
      "flow_data": {
        "CelerIMFacetBase": {
          "_startBridge": {
            "name": "_startBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "!_bridgeData.hasDestinationCall",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "msgValue",
                "type": "uint256",
                "value": "LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0",
                "line": 3
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "_bridgeData.receiver",
                "line": 18
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "address(relayer)",
                "line": 21
              },
              {
                "variable": "receiver",
                "type": "address",
                "value": "receiver",
                "line": 42
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "8": "if (!_bridgeData.hasDestinationCall)",
              "3": "State Change: msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0",
              "18": "State Change: receiver = _bridgeData.receiver",
              "21": "State Change: receiver = address(relayer)",
              "42": "State Change: receiver = receiver"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "CelerIM.CelerIMData",
                "name": "_celerIMData"
              }
            ],
            "returns": []
          },
          "_getRightAsset": {
            "name": "_getRightAsset",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "_sendingAssetId == cfUSDC",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (_sendingAssetId == cfUSDC)"
            },
            "parameters": [
              {
                "type": "address",
                "name": "_sendingAssetId"
              }
            ],
            "returns": [
              {
                "type": "IERC20 _asset"
              }
            ]
          },
          "validateDestinationCallFlag": {
            "name": "validateDestinationCallFlag",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "(_celerIMData.callData.length > 0",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if ((_celerIMData.callData.length > 0)"
            },
            "parameters": [
              {
                "type": "ILiFi.BridgeData",
                "name": "_bridgeData"
              },
              {
                "type": "CelerIM.CelerIMData",
                "name": "_celerIMData"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "CelerIMFacetBase": {
          "_startBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getRightAsset": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "validateDestinationCallFlag": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.903151"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.907221"
      },
      "final_report": {
        "file_id": "CelerIMFacetBase.sol",
        "timestamp": "2025-03-11T07:05:50.907247",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "CelerIMFacetBase": {
            "functions": 3,
            "state_variables": 4,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "SwapperV2",
              "Validatable"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of CelerIMFacetBase.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.907260"
    },
    "ExcessivelySafeCall.sol": {
      "file_id": "ExcessivelySafeCall.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "assembly": {
            "name": "assembly",
            "inheritance": [],
            "functions": {},
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n// This contract has been taken from: https://github.com/nomad-xyz/ExcessivelySafeCall\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { InvalidCallData } from \"../Errors/GenericErrors.sol\";\n\n// solhint-disable no-inline-assembly\nlibrary ExcessivelySafeCall {\n    uint256 private constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(\n        bytes4 _newSelector,\n        bytes memory _buf\n    ) internal pure {\n        if (_buf.length < 4) {\n            revert InvalidCallData();\n        }\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
      },
      "call_graph": {
        "assembly": {}
      },
      "flow_data": {
        "assembly": {}
      },
      "flow_paths": {
        "assembly": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.903463"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.908812"
      },
      "final_report": {
        "file_id": "ExcessivelySafeCall.sol",
        "timestamp": "2025-03-11T07:05:50.908833",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "assembly": {
            "functions": 0,
            "state_variables": 0,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ExcessivelySafeCall.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.908846"
    },
    "ReentrancyGuard.sol": {
      "file_id": "ReentrancyGuard.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ReentrancyGuard": {
            "name": "ReentrancyGuard",
            "inheritance": [],
            "functions": {
              "reentrancyStorage": {
                "name": "reentrancyStorage",
                "visibility": "private",
                "parameters": [],
                "returns": [
                  {
                    "type": "ReentrancyStorage storage data"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data.slot := position\n        }\n    }"
              }
            },
            "state_variables": {
              "status": {
                "name": "status",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "position": {
                "name": "position",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "NAMESPACE"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n/// @title Reentrancy Guard\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide protection against reentrancy\nabstract contract ReentrancyGuard {\n    /// Storage ///\n\n    bytes32 private constant NAMESPACE = keccak256(\"com.lifi.reentrancyguard\");\n\n    /// Types ///\n\n    struct ReentrancyStorage {\n        uint256 status;\n    }\n\n    /// Errors ///\n\n    error ReentrancyError();\n\n    /// Constants ///\n\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    /// Modifiers ///\n\n    modifier nonReentrant() {\n        ReentrancyStorage storage s = reentrancyStorage();\n        if (s.status == _ENTERED) revert ReentrancyError();\n        s.status = _ENTERED;\n        _;\n        s.status = _NOT_ENTERED;\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function reentrancyStorage()\n        private\n        pure\n        returns (ReentrancyStorage storage data)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
      },
      "call_graph": {
        "ReentrancyGuard": {
          "reentrancyStorage": []
        }
      },
      "flow_data": {
        "ReentrancyGuard": {
          "reentrancyStorage": {
            "name": "reentrancyStorage",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "position",
                "type": "bytes32",
                "value": "NAMESPACE",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: position = NAMESPACE"
            },
            "parameters": [],
            "returns": [
              {
                "type": "ReentrancyStorage storage data"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "ReentrancyGuard": {
          "reentrancyStorage": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.908528"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.911223"
      },
      "final_report": {
        "file_id": "ReentrancyGuard.sol",
        "timestamp": "2025-03-11T07:05:50.911249",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ReentrancyGuard": {
            "functions": 1,
            "state_variables": 2,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ReentrancyGuard.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.911262"
    },
    "SwapperV2.sol": {
      "file_id": "SwapperV2.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "SwapperV2": {
            "name": "SwapperV2",
            "inheritance": [
              "ILiFi"
            ],
            "functions": {
              "_depositAndSwap": {
                "name": "_depositAndSwap",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "uint256",
                    "name": "_minAmount"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swaps"
                  },
                  {
                    "type": "address",
                    "name": "_leftoverReceiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_nativeReserve"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        ReserveData memory rd = ReserveData(\n            _transactionId,\n            _leftoverReceiver,\n            _nativeReserve\n        );\n        _executeSwaps(rd, _swaps, initialBalances);\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            newBalance -= _nativeReserve;\n        }\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }"
              },
              "_fetchBalances": {
                "name": "_fetchBalances",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swaps"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256[] memory"
                  }
                ],
                "modifiers": [],
                "code": "uint256 numSwaps = _swaps.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swaps[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }"
              }
            },
            "state_variables": {
              "transactionId": {
                "name": "transactionId",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "nativeReserve": {
                "name": "nativeReserve",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "numSwaps": {
                "name": "numSwaps",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_swaps.length"
              },
              "finalAsset": {
                "name": "finalAsset",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swaps[numSwaps - 1].receivingAssetId"
              },
              "curBalance": {
                "name": "curBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "curAsset": {
                "name": "curAsset",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swaps[i].receivingAssetId"
              },
              "reserve": {
                "name": "reserve",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.isNativeAsset(curAsset)\n                        ? _nativeReserve\n                        : 0"
              },
              "initialBalance": {
                "name": "initialBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.getOwnBalance(finalTokenId)"
              },
              "finalBalance": {
                "name": "finalBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "address(this).balance"
              },
              "finalTokenId": {
                "name": "finalTokenId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swaps[numSwaps - 1].receivingAssetId"
              },
              "newBalance": {
                "name": "newBalance",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "asset": {
                "name": "asset",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "balances": {
                "name": "balances",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { ContractCallNotAllowed, NoSwapDataProvided, CumulativeSlippageTooHigh } from \"../Errors/GenericErrors.sol\";\n\n/// @title Swapper\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide swap functionality\ncontract SwapperV2 is ILiFi {\n    /// Types ///\n\n    /// @dev only used to get around \"Stack Too Deep\" errors\n    struct ReserveData {\n        bytes32 transactionId;\n        address payable leftoverReceiver;\n        uint256 nativeReserve;\n    }\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Sends any leftover balances back to the user reserving native tokens\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftoversReserve(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances,\n        uint256 _nativeReserve\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    uint256 reserve = LibAsset.isNativeAsset(curAsset)\n                        ? _nativeReserve\n                        : 0;\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - reserve\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Refunds any excess native asset sent to the contract after the main function\n    /// @notice Refunds any excess native asset sent to the contract after the main function\n    /// @param _refundReceiver Address to send refunds to\n    modifier refundExcessNative(address payable _refundReceiver) {\n        uint256 initialBalance = address(this).balance - msg.value;\n        _;\n        uint256 finalBalance = address(this).balance;\n\n        if (finalBalance > initialBalance) {\n            LibAsset.transferAsset(\n                LibAsset.NATIVE_ASSETID,\n                _refundReceiver,\n                finalBalance - initialBalance\n            );\n        }\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @return uint256 result of the swap\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        _executeSwaps(\n            _transactionId,\n            _swaps,\n            _leftoverReceiver,\n            initialBalances\n        );\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check and reserves native token for fees\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @param _nativeReserve Amount of native token to prevent from being swept back to the caller\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256 _nativeReserve\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        ReserveData memory rd = ReserveData(\n            _transactionId,\n            _leftoverReceiver,\n            _nativeReserve\n        );\n        _executeSwaps(rd, _swaps, initialBalances);\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            newBalance -= _nativeReserve;\n        }\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// Private Methods ///\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial balances\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) internal noLeftovers(_swaps, _leftoverReceiver, _initialBalances) {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _reserveData Data passed used to reserve native tokens\n    /// @param _swaps Array of data used to execute swaps\n    function _executeSwaps(\n        ReserveData memory _reserveData,\n        LibSwap.SwapData[] calldata _swaps,\n        uint256[] memory _initialBalances\n    )\n        internal\n        noLeftoversReserve(\n            _swaps,\n            _reserveData.leftoverReceiver,\n            _initialBalances,\n            _reserveData.nativeReserve\n        )\n    {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_reserveData.transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swaps Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swaps\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swaps.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swaps[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n}\n"
      },
      "call_graph": {
        "SwapperV2": {
          "_depositAndSwap": [
            {
              "contract": "SwapperV2",
              "function": "_fetchBalances"
            }
          ],
          "_fetchBalances": []
        }
      },
      "flow_data": {
        "SwapperV2": {
          "_depositAndSwap": {
            "name": "_depositAndSwap",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "numSwaps == 0",
                "line": 3
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(finalTokenId",
                "line": 10
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(finalTokenId",
                "line": 27
              },
              {
                "type": "if",
                "condition": "newBalance < _minAmount",
                "line": 31
              }
            ],
            "state_changes": [
              {
                "variable": "numSwaps",
                "type": "uint256",
                "value": "_swaps.length",
                "line": 1
              },
              {
                "variable": "numSwaps",
                "type": "uint256",
                "value": "= 0) {\n            revert NoSwapDataProvided()",
                "line": 3
              },
              {
                "variable": "initialBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(finalTokenId)",
                "line": 8
              },
              {
                "variable": "finalTokenId",
                "type": "address",
                "value": "_swaps[numSwaps - 1].receivingAssetId",
                "line": 7
              },
              {
                "variable": "newBalance",
                "type": "return",
                "value": "LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance",
                "line": 24
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "State Change: numSwaps = = 0) {\n            revert NoSwapDataProvided()",
              "10": "if (LibAsset.isNativeAsset(finalTokenId)",
              "27": "if (LibAsset.isNativeAsset(finalTokenId)",
              "31": "if (newBalance < _minAmount)",
              "1": "State Change: numSwaps = _swaps.length",
              "8": "State Change: initialBalance = LibAsset.getOwnBalance(finalTokenId)",
              "7": "State Change: finalTokenId = _swaps[numSwaps - 1].receivingAssetId",
              "24": "State Change: newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "uint256",
                "name": "_minAmount"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swaps"
              },
              {
                "type": "address",
                "name": "_leftoverReceiver"
              },
              {
                "type": "uint256",
                "name": "_nativeReserve"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          },
          "_fetchBalances": {
            "name": "_fetchBalances",
            "visibility": "private",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < numSwaps;",
                "line": 4
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(asset",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "numSwaps",
                "type": "uint256",
                "value": "_swaps.length",
                "line": 1
              },
              {
                "variable": "asset",
                "type": "address",
                "value": "_swaps[i].receivingAssetId",
                "line": 5
              },
              {
                "variable": "balances",
                "type": "return",
                "value": "new uint256[](numSwaps)",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "for (uint256 i = 0; i < numSwaps;)",
              "8": "if (LibAsset.isNativeAsset(asset)",
              "1": "State Change: numSwaps = _swaps.length",
              "5": "State Change: asset = _swaps[i].receivingAssetId",
              "2": "State Change: balances = new uint256[](numSwaps)"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swaps"
              }
            ],
            "returns": [
              {
                "type": "uint256[] memory"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "SwapperV2": {
          "_depositAndSwap": {
            "calls": [
              {
                "contract": "SwapperV2",
                "function": "_fetchBalances",
                "state_changes": [
                  {
                    "variable": "numSwaps",
                    "type": "uint256",
                    "value": "_swaps.length",
                    "line": 1
                  },
                  {
                    "variable": "asset",
                    "type": "address",
                    "value": "_swaps[i].receivingAssetId",
                    "line": 5
                  },
                  {
                    "variable": "balances",
                    "type": "return",
                    "value": "new uint256[](numSwaps)",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_fetchBalances": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.921859"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.925527"
      },
      "final_report": {
        "file_id": "SwapperV2.sol",
        "timestamp": "2025-03-11T07:05:50.925553",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "SwapperV2": {
            "functions": 2,
            "state_variables": 13,
            "inheritance": [
              "ILiFi"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of SwapperV2.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.925565"
    },
    "TransferrableOwnership.sol": {
      "file_id": "TransferrableOwnership.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "TransferrableOwnership": {
            "name": "TransferrableOwnership",
            "inheritance": [
              "IERC173"
            ],
            "functions": {
              "confirmOwnershipTransfer": {
                "name": "confirmOwnershipTransfer",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "address _pendingOwner = pendingOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }"
              }
            },
            "state_variables": {
              "owner": {
                "name": "owner",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "pendingOwner": {
                "name": "pendingOwner",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "_pendingOwner": {
                "name": "_pendingOwner",
                "type": "address",
                "visibility": "internal",
                "initial_value": "pendingOwner"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\ncontract TransferrableOwnership is IERC173 {\n    address public owner;\n    address public pendingOwner;\n\n    /// Errors ///\n    error UnAuthorized();\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    constructor(address initialOwner) {\n        owner = initialOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert UnAuthorized();\n        _;\n    }\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external onlyOwner {\n        if (_newOwner == LibAsset.NULL_ADDRESS) revert NoNullOwner();\n        if (_newOwner == msg.sender) revert NewOwnerMustNotBeSelf();\n        pendingOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, pendingOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (pendingOwner == LibAsset.NULL_ADDRESS)\n            revert NoPendingOwnershipTransfer();\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        address _pendingOwner = pendingOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n}\n"
      },
      "call_graph": {
        "TransferrableOwnership": {
          "confirmOwnershipTransfer": []
        }
      },
      "flow_data": {
        "TransferrableOwnership": {
          "confirmOwnershipTransfer": {
            "name": "confirmOwnershipTransfer",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.sender != _pendingOwner",
                "line": 2
              }
            ],
            "state_changes": [
              {
                "variable": "owner",
                "type": "address",
                "value": "_pendingOwner",
                "line": 4
              },
              {
                "variable": "pendingOwner",
                "type": "address",
                "value": "LibAsset.NULL_ADDRESS",
                "line": 5
              },
              {
                "variable": "_pendingOwner",
                "type": "address",
                "value": "pendingOwner",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (msg.sender != _pendingOwner)",
              "4": "State Change: owner = _pendingOwner",
              "5": "State Change: pendingOwner = LibAsset.NULL_ADDRESS",
              "1": "State Change: _pendingOwner = pendingOwner"
            },
            "parameters": [],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "TransferrableOwnership": {
          "confirmOwnershipTransfer": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.926760"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.932692"
      },
      "final_report": {
        "file_id": "TransferrableOwnership.sol",
        "timestamp": "2025-03-11T07:05:50.932716",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "TransferrableOwnership": {
            "functions": 1,
            "state_variables": 3,
            "inheritance": [
              "IERC173"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of TransferrableOwnership.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.932729"
    },
    "Validatable.sol": {
      "file_id": "Validatable.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "Validatable": {
            "name": "Validatable",
            "inheritance": [],
            "functions": {},
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver, InformationMismatch, InvalidSendingToken, InvalidAmount, NativeAssetNotSupported, InvalidDestinationChain, CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\ncontract Validatable {\n    modifier validateBridgeData(ILiFi.BridgeData memory _bridgeData) {\n        if (LibUtil.isZeroAddress(_bridgeData.receiver)) {\n            revert InvalidReceiver();\n        }\n        if (_bridgeData.minAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (_bridgeData.destinationChainId == block.chainid) {\n            revert CannotBridgeToSameNetwork();\n        }\n        _;\n    }\n\n    modifier noNativeAsset(ILiFi.BridgeData memory _bridgeData) {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            revert NativeAssetNotSupported();\n        }\n        _;\n    }\n\n    modifier onlyAllowSourceToken(\n        ILiFi.BridgeData memory _bridgeData,\n        address _token\n    ) {\n        if (_bridgeData.sendingAssetId != _token) {\n            revert InvalidSendingToken();\n        }\n        _;\n    }\n\n    modifier onlyAllowDestinationChain(\n        ILiFi.BridgeData memory _bridgeData,\n        uint256 _chainId\n    ) {\n        if (_bridgeData.destinationChainId != _chainId) {\n            revert InvalidDestinationChain();\n        }\n        _;\n    }\n\n    modifier containsSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (!_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainDestinationCalls(\n        ILiFi.BridgeData memory _bridgeData\n    ) {\n        if (_bridgeData.hasDestinationCall) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n}\n"
      },
      "call_graph": {
        "Validatable": {}
      },
      "flow_data": {
        "Validatable": {}
      },
      "flow_paths": {
        "Validatable": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.933746"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.937831"
      },
      "final_report": {
        "file_id": "Validatable.sol",
        "timestamp": "2025-03-11T07:05:50.937857",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "Validatable": {
            "functions": 0,
            "state_variables": 0,
            "inheritance": []
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of Validatable.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.937869"
    },
    "WithdrawablePeriphery.sol": {
      "file_id": "WithdrawablePeriphery.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "WithdrawablePeriphery": {
            "name": "WithdrawablePeriphery",
            "inheritance": [
              "TransferrableOwnership"
            ],
            "functions": {},
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { TransferrableOwnership } from \"./TransferrableOwnership.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\nabstract contract WithdrawablePeriphery is TransferrableOwnership {\n    using SafeTransferLib for address;\n\n    event TokensWithdrawn(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    );\n\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    function withdrawToken(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) revert ExternalCallFailed();\n        } else {\n            assetId.safeTransfer(receiver, amount);\n        }\n\n        emit TokensWithdrawn(assetId, receiver, amount);\n    }\n}\n"
      },
      "call_graph": {
        "WithdrawablePeriphery": {}
      },
      "flow_data": {
        "WithdrawablePeriphery": {}
      },
      "flow_paths": {
        "WithdrawablePeriphery": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:50.931927"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.936371"
      },
      "final_report": {
        "file_id": "WithdrawablePeriphery.sol",
        "timestamp": "2025-03-11T07:05:50.936397",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "WithdrawablePeriphery": {
            "functions": 0,
            "state_variables": 0,
            "inheritance": [
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of WithdrawablePeriphery.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.936409"
    },
    "IAcrossSpokePool.sol": {
      "file_id": "IAcrossSpokePool.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @custom:version 1.0.0\ninterface IAcrossSpokePool {\n    function deposit(\n        address recipient, // Recipient address\n        address originToken, // Address of the token\n        uint256 amount, // Token amount\n        uint256 destinationChainId, // \u26d3 id\n        int64 relayerFeePct, // see #Fees Calculation\n        uint32 quoteTimestamp, // Timestamp for the quote creation\n        bytes memory message, // Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n        uint256 maxCount // Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    ) external payable;\n\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount, // <-- replaces fees\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.923330"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.927669"
      },
      "final_report": {
        "file_id": "IAcrossSpokePool.sol",
        "timestamp": "2025-03-11T07:05:50.927690",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IAcrossSpokePool.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.927701"
    },
    "IAllBridge.sol": {
      "file_id": "IAllBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n/// @title AllBridge Interface\ninterface IAllBridge {\n    /// @dev AllBridge Messenger Protocol Enum\n    enum MessengerProtocol {\n        None,\n        Allbridge,\n        Wormhole,\n        LayerZero\n    }\n\n    function pools(bytes32 addr) external returns (address);\n\n    function swapAndBridge(\n        bytes32 token,\n        uint256 amount,\n        bytes32 recipient,\n        uint256 destinationChainId,\n        bytes32 receiveToken,\n        uint256 nonce,\n        MessengerProtocol messenger,\n        uint256 feeTokenAmount\n    ) external payable;\n\n    function getTransactionCost(\n        uint256 chainId\n    ) external view returns (uint256);\n\n    function getMessageCost(\n        uint256 chainId,\n        MessengerProtocol protocol\n    ) external view returns (uint256);\n\n    function getBridgingCostInTokens(\n        uint256 destinationChainId,\n        MessengerProtocol messenger,\n        address tokenAddress\n    ) external view returns (uint256);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.924594"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.930759"
      },
      "final_report": {
        "file_id": "IAllBridge.sol",
        "timestamp": "2025-03-11T07:05:50.930782",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IAllBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.930812"
    },
    "ICBridge.sol": {
      "file_id": "ICBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ICBridge {\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge.\n    /// @dev This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\n    /// @param _receiver The address of the receiver.\n    /// @param _token The address of the token.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge using the native token.\n    /// @param _receiver The address of the receiver.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A unique number. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.922511"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.929113"
      },
      "final_report": {
        "file_id": "ICBridge.sol",
        "timestamp": "2025-03-11T07:05:50.929136",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ICBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.929148"
    },
    "ICircleBridgeProxy.sol": {
      "file_id": "ICircleBridgeProxy.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ICircleBridgeProxy {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param _amount Amount of tokens to burn.\n    /// @param _dstChid Destination domain.\n    /// @param _mintRecipient Address of mint recipient on destination domain.\n    /// @param _burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 _amount,\n        uint64 _dstChid,\n        bytes32 _mintRecipient,\n        address _burnToken\n    ) external returns (uint64 nonce);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.930105"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.934747"
      },
      "final_report": {
        "file_id": "ICircleBridgeProxy.sol",
        "timestamp": "2025-03-11T07:05:50.934770",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ICircleBridgeProxy.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.934783"
    },
    "IConnextHandler.sol": {
      "file_id": "IConnextHandler.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IConnextHandler {\n    /// @notice These are the call parameters that will remain constant between the\n    /// two chains. They are supplied on `xcall` and should be asserted on `execute`\n    /// @property to - The account that receives funds, in the event of a crosschain call,\n    /// will receive funds if the call fails.\n    /// @param to - The address you are sending funds (and potentially data) to\n    /// @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\n    /// @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\n    /// @param agent - An address who can execute txs on behalf of `to`, in addition to allowing relayers\n    /// @param recovery - The address to send funds to if your `Executor.execute call` fails\n    /// @param forceSlow - If true, will take slow liquidity path even if it is not a permissioned call\n    /// @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\n    /// @param callback - The address on the origin domain of the callback contract\n    /// @param callbackFee - The relayer fee to execute the callback\n    /// @param relayerFee - The amount of relayer fee the tx called xcall with\n    /// @param slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    struct CallParams {\n        address to;\n        bytes callData;\n        uint32 originDomain;\n        uint32 destinationDomain;\n        address agent;\n        address recovery;\n        bool forceSlow;\n        bool receiveLocal;\n        address callback;\n        uint256 callbackFee;\n        uint256 relayerFee;\n        uint256 slippageTol;\n    }\n\n    /// @notice The arguments you supply to the `xcall` function called by user on origin domain\n    /// @param params - The CallParams. These are consistent across sending and receiving chains\n    /// @param transactingAsset - The asset the caller sent with the transfer. Can be the adopted, canonical,\n    /// or the representational asset\n    /// @param transactingAmount - The amount of transferring asset supplied by the user in the `xcall`\n    /// @param originMinOut - Minimum amount received on swaps for adopted <> local on origin chain\n    struct XCallArgs {\n        CallParams params;\n        address transactingAsset; // Could be adopted, local, or wrapped\n        uint256 transactingAmount;\n        uint256 originMinOut;\n    }\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData\n    ) external payable returns (bytes32);\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData,\n        uint256 _relayerFee\n    ) external returns (bytes32);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.986108"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.989401"
      },
      "final_report": {
        "file_id": "IConnextHandler.sol",
        "timestamp": "2025-03-11T07:05:50.989426",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IConnextHandler.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.989439"
    },
    "IDeBridgeGate.sol": {
      "file_id": "IDeBridgeGate.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IDeBridgeGate {\n    /// @param fixedNativeFee Transfer fixed fee.\n    /// @param isSupported Whether the chain for the asset is supported.\n    /// @param transferFeeBps Transfer fee rate nominated in basis points (1/10000)\n    ///                       of transferred amount.\n    struct ChainSupportInfo {\n        uint256 fixedNativeFee;\n        bool isSupported;\n        uint16 transferFeeBps;\n    }\n\n    /// @dev Fallback fixed fee in native asset, used if a chain fixed fee is set to 0\n    function globalFixedNativeFee() external view returns (uint256);\n\n    /// @dev Whether the chain for the asset is supported to send\n    function getChainToConfig(\n        uint256\n    ) external view returns (ChainSupportInfo memory);\n\n    /// @dev This method is used for the transfer of assets.\n    ///      It locks an asset in the smart contract in the native chain\n    ///      and enables minting of deAsset on the secondary chain.\n    /// @param _tokenAddress Asset identifier.\n    /// @param _amount Amount to be transferred (note: the fee can be applied).\n    /// @param _chainIdTo Chain id of the target chain.\n    /// @param _receiver Receiver address.\n    /// @param _permit deadline + signature for approving the spender by signature.\n    /// @param _useAssetFee use assets fee for pay protocol fix (work only for specials token)\n    /// @param _referralCode Referral code\n    /// @param _autoParams Auto params for external call in target network\n    function send(\n        address _tokenAddress,\n        uint256 _amount,\n        uint256 _chainIdTo,\n        bytes memory _receiver,\n        bytes memory _permit,\n        bool _useAssetFee,\n        uint32 _referralCode,\n        bytes calldata _autoParams\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.987105"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.990618"
      },
      "final_report": {
        "file_id": "IDeBridgeGate.sol",
        "timestamp": "2025-03-11T07:05:50.990640",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IDeBridgeGate.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.990652"
    },
    "IDiamondCut.sol": {
      "file_id": "IDiamondCut.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 2.0.0\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\ninterface IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        LibDiamond.FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(\n        LibDiamond.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.986382"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.991828"
      },
      "final_report": {
        "file_id": "IDiamondCut.sol",
        "timestamp": "2025-03-11T07:05:50.991851",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IDiamondCut.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.991864"
    },
    "IDiamondLoupe.sol": {
      "file_id": "IDiamondLoupe.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view returns (address facetAddress_);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.988495"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.993736"
      },
      "final_report": {
        "file_id": "IDiamondLoupe.sol",
        "timestamp": "2025-03-11T07:05:50.993759",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IDiamondLoupe.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.993771"
    },
    "IDlnSource.sol": {
      "file_id": "IDlnSource.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IDlnSource {\n    struct OrderCreation {\n        // the address of the ERC-20 token you are giving;\n        // use the zero address to indicate you are giving a native blockchain token (ether, matic, etc).\n        address giveTokenAddress;\n        // the amount of tokens you are giving\n        uint256 giveAmount;\n        // the address of the ERC-20 token you are willing to take on the destination chain\n        bytes takeTokenAddress;\n        // the amount of tokens you are willing to take on the destination chain\n        uint256 takeAmount;\n        // the ID of the chain where an order should be fulfilled.\n        // Use the list of supported chains mentioned above\n        uint256 takeChainId;\n        // the address on the destination chain where the funds\n        // should be sent to upon order fulfillment\n        bytes receiverDst;\n        // the address on the source (current) chain who is allowed to patch the order\n        // giving more input tokens and thus making the order more attractive to takers, just in case\n        address givePatchAuthoritySrc;\n        // the address on the destination chain who is allowed to patch the order\n        // decreasing the take amount and thus making the order more attractive to takers, just in case\n        bytes orderAuthorityAddressDst;\n        // an optional address restricting anyone in the open market from fulfilling\n        // this order but the given address. This can be useful if you are creating a order\n        //  for a specific taker. By default, set to empty bytes array (0x)\n        bytes allowedTakerDst; // *optional\n        // set to an empty bytes array (0x)\n        bytes externalCall; // N/A, *optional\n        // an optional address on the source (current) chain where the given input tokens\n        // would be transferred to in case order cancellation is initiated by the orderAuthorityAddressDst\n        // on the destination chain. This property can be safely set to an empty bytes array (0x):\n        // in this case, tokens would be transferred to the arbitrary address specified\n        // by the orderAuthorityAddressDst upon order cancellation\n        bytes allowedCancelBeneficiarySrc; // *optional\n    }\n\n    function globalFixedNativeFee() external returns (uint256);\n\n    function createOrder(\n        OrderCreation calldata _orderCreation,\n        bytes calldata _affiliateFee,\n        uint32 _referralCode,\n        bytes calldata _permitEnvelope\n    ) external payable returns (bytes32 orderId);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.989526"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:50.992703"
      },
      "final_report": {
        "file_id": "IDlnSource.sol",
        "timestamp": "2025-03-11T07:05:50.992723",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IDlnSource.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:50.992734"
    },
    "IERC165.sol": {
      "file_id": "IERC165.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view returns (bool);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.003735"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.011007"
      },
      "final_report": {
        "file_id": "IERC165.sol",
        "timestamp": "2025-03-11T07:05:51.011027",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IERC165.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.011039"
    },
    "IERC173.sol": {
      "file_id": "IERC173.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.007404"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.011795"
      },
      "final_report": {
        "file_id": "IERC173.sol",
        "timestamp": "2025-03-11T07:05:51.011816",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IERC173.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.011827"
    },
    "IERC20Proxy.sol": {
      "file_id": "IERC20Proxy.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IERC20Proxy {\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.004746"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.008644"
      },
      "final_report": {
        "file_id": "IERC20Proxy.sol",
        "timestamp": "2025-03-11T07:05:51.008666",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IERC20Proxy.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.008678"
    },
    "IExecutor.sol": {
      "file_id": "IExecutor.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Interface for Executor\n/// @author LI.FI (https://li.fi)\ninterface IExecutor {\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param transferredAssetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address transferredAssetId,\n        address payable receiver\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.003467"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.007290"
      },
      "final_report": {
        "file_id": "IExecutor.sol",
        "timestamp": "2025-03-11T07:05:51.007314",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IExecutor.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.007327"
    },
    "IGasZip.sol": {
      "file_id": "IGasZip.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n/// @title Interface for GasZip\n/// @author LI.FI (https://li.fi)\ninterface IGasZip {\n    /// @dev GasZip-specific bridge data\n    /// @param receiverAddress the address on destination chain(s) where gas should be sent to\n    /// @param destinationChains a value that represents a list of chains to which gas should be distributed (see https://dev.gas.zip/gas/code-examples/deposit for more details)\n    struct GasZipData {\n        bytes32 receiverAddress;\n        // EVM addresses need to be padded with trailing 0s, e.g.:\n        // 0x391E7C679D29BD940D63BE94AD22A25D25B5A604000000000000000000000000 (correct)\n        // 0x000000000000000000000000391E7C679D29BD940D63BE94AD22A25D25B5A604 (incorrect)\n        uint256 destinationChains;\n    }\n\n    function deposit(uint256 destinationChains, bytes32 to) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.005727"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.009533"
      },
      "final_report": {
        "file_id": "IGasZip.sol",
        "timestamp": "2025-03-11T07:05:51.009552",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IGasZip.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.009563"
    },
    "IGatewayRouter.sol": {
      "file_id": "IGatewayRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IGatewayRouter {\n    /// @notice Transfer non-native assets\n    /// @param _token L1 address of ERC20\n    /// @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n    /// @param _amount Token Amount\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid Gas price for L2 execution\n    /// @param _data Encoded data from router and user\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /// @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress). createRetryableTicket method is the recommended standard.\n    /// @param _destAddr destination L2 contract address\n    /// @param _l2CallValue call value for retryable L2 message\n    /// @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    /// @param _excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n    /// @param _callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid price bid for L2 execution\n    /// @param _data ABI encoded data of L2 message\n    /// @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n    function unsafeCreateRetryableTicket(\n        address _destAddr,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        address _excessFeeRefundAddress,\n        address _callValueRefundAddress,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (uint256);\n\n    /// @notice Returns receiving token address on L2\n    /// @param _token Sending token address on L1\n    /// @return Receiving token address on L2\n    function calculateL2TokenAddress(\n        address _token\n    ) external view returns (address);\n\n    /// @notice Returns exact gateway router address for token\n    /// @param _token Sending token address on L1\n    /// @return Gateway router address for sending token\n    function getGateway(address _token) external view returns (address);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.007644"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.013532"
      },
      "final_report": {
        "file_id": "IGatewayRouter.sol",
        "timestamp": "2025-03-11T07:05:51.013554",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IGatewayRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.013566"
    },
    "IHopBridge.sol": {
      "file_id": "IHopBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IHopBridge {\n    function sendToL2(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 deadline,\n        address relayer,\n        uint256 relayerFee\n    ) external payable;\n\n    function swapAndSend(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline\n    ) external payable;\n\n    function send(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline\n    ) external;\n}\n\ninterface IL2AmmWrapper {\n    function bridge() external view returns (address);\n\n    function l2CanonicalToken() external view returns (address);\n\n    function hToken() external view returns (address);\n\n    function exchangeAddress() external view returns (address);\n}\n\ninterface ISwap {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.012508"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.016876"
      },
      "final_report": {
        "file_id": "IHopBridge.sol",
        "timestamp": "2025-03-11T07:05:51.016900",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IHopBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.016913"
    },
    "IHyphenRouter.sol": {
      "file_id": "IHyphenRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n// https://github.com/bcnmy/hyphen-contract/blob/master/contracts/hyphen/LiquidityPool.sol\ninterface IHyphenRouter {\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata tag\n    ) external;\n\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string calldata tag\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.010284"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.015465"
      },
      "final_report": {
        "file_id": "IHyphenRouter.sol",
        "timestamp": "2025-03-11T07:05:51.015489",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IHyphenRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.015502"
    },
    "IL1StandardBridge.sol": {
      "file_id": "IL1StandardBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IL1StandardBridge {\n    /// @notice Deposit an amount of ETH to a recipient's balance on L2.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @param _l1Token Address of the L1 ERC20 we are depositing\n    /// @param _l2Token Address of the L1 respective L2 ERC20\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @dev This function is implemented on SynthetixBridgeToOptimism contract.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    function depositTo(address _to, uint256 _amount) external;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.066426"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.073613"
      },
      "final_report": {
        "file_id": "IL1StandardBridge.sol",
        "timestamp": "2025-03-11T07:05:51.073635",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IL1StandardBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.073647"
    },
    "ILiFi.sol": {
      "file_id": "ILiFi.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ILiFi {\n    /// Structs ///\n\n    struct BridgeData {\n        bytes32 transactionId;\n        string bridge;\n        string integrator;\n        address referrer;\n        address sendingAssetId;\n        address receiver;\n        uint256 minAmount;\n        uint256 destinationChainId;\n        bool hasSourceSwaps;\n        bool hasDestinationCall;\n    }\n\n    /// Events ///\n\n    event LiFiTransferStarted(ILiFi.BridgeData bridgeData);\n\n    event LiFiTransferCompleted(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiTransferRecovered(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiGenericSwapCompleted(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address receiver,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n\n    // Deprecated but kept here to include in ABI to parse historic events\n    event LiFiSwappedGeneric(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.065870"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.069100"
      },
      "final_report": {
        "file_id": "ILiFi.sol",
        "timestamp": "2025-03-11T07:05:51.069124",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ILiFi.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.069137"
    },
    "IMayan.sol": {
      "file_id": "IMayan.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IMayan {\n    struct PermitParams {\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function forwardEth(\n        address mayanProtocol,\n        bytes calldata protocolData\n    ) external payable;\n\n    function forwardERC20(\n        address tokenIn,\n        uint256 amountIn,\n        PermitParams calldata permitParams,\n        address mayanProtocol,\n        bytes calldata protocolData\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.067478"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.071362"
      },
      "final_report": {
        "file_id": "IMayan.sol",
        "timestamp": "2025-03-11T07:05:51.071386",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IMayan.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.071399"
    },
    "IMultichainRouter.sol": {
      "file_id": "IMultichainRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IMultichainRouter {\n    function anySwapOutUnderlying(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOut(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOutNative(\n        address token,\n        address to,\n        uint256 toChainID\n    ) external payable;\n\n    function wNATIVE() external returns (address);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.067235"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.069976"
      },
      "final_report": {
        "file_id": "IMultichainRouter.sol",
        "timestamp": "2025-03-11T07:05:51.069996",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IMultichainRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.070007"
    },
    "IMultichainToken.sol": {
      "file_id": "IMultichainToken.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IMultichainToken {\n    function underlying() external returns (address);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.068347"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.072498"
      },
      "final_report": {
        "file_id": "IMultichainToken.sol",
        "timestamp": "2025-03-11T07:05:51.072523",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IMultichainToken.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.072536"
    },
    "IOmniBridge.sol": {
      "file_id": "IOmniBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IOmniBridge {\n    /// @dev Initiate the bridge operation for some amount of tokens from msg.sender.\n    /// @param token bridged token contract address.\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external;\n\n    /// @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.\n    /// @param receiver Bridged assets receiver on the other side of the bridge.\n    function wrapAndRelayTokens(address receiver) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.085367"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.089446"
      },
      "final_report": {
        "file_id": "IOmniBridge.sol",
        "timestamp": "2025-03-11T07:05:51.089466",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IOmniBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.089477"
    },
    "IRootChainManager.sol": {
      "file_id": "IRootChainManager.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IRootChainManager {\n    /// @notice Move ether from root to child chain, accepts ether transfer\n    /// @dev Keep in mind this ether cannot be used to pay gas on child chain\n    ///      Use Matic tokens deposited using plasma mechanism for that\n    /// @param user address of account that should receive WETH on child chain\n    function depositEtherFor(address user) external payable;\n\n    /// @notice Move tokens from root to child chain\n    /// @dev This mechanism supports arbitrary tokens as long as\n    ///      its predicate has been registered and the token is mapped\n    /// @param user address of account that should receive this deposit on child chain\n    /// @param rootToken address of token that is being deposited\n    /// @param depositData bytes data that is sent to predicate and\n    ///        child token contracts to handle deposit\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n\n    /// @notice Returns child token address for root token\n    /// @param rootToken Root token address\n    /// @return childToken Child token address\n    function rootToChildToken(\n        address rootToken\n    ) external view returns (address childToken);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.088772"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.092831"
      },
      "final_report": {
        "file_id": "IRootChainManager.sol",
        "timestamp": "2025-03-11T07:05:51.092852",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IRootChainManager.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.092863"
    },
    "ISquidMulticall.sol": {
      "file_id": "ISquidMulticall.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ISquidMulticall {\n    enum CallType {\n        Default,\n        FullTokenBalance,\n        FullNativeBalance,\n        CollectTokenBalance\n    }\n\n    struct Call {\n        CallType callType;\n        address target;\n        uint256 value;\n        bytes callData;\n        bytes payload;\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.083008"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.086784"
      },
      "final_report": {
        "file_id": "ISquidMulticall.sol",
        "timestamp": "2025-03-11T07:05:51.086808",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ISquidMulticall.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.086820"
    },
    "ISquidRouter.sol": {
      "file_id": "ISquidRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { ISquidMulticall } from \"./ISquidMulticall.sol\";\n\ninterface ISquidRouter {\n    function bridgeCall(\n        string calldata bridgedTokenSymbol,\n        uint256 amount,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n\n    function callBridge(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external payable;\n\n    function callBridgeCall(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.083609"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.091338"
      },
      "final_report": {
        "file_id": "ISquidRouter.sol",
        "timestamp": "2025-03-11T07:05:51.091352",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ISquidRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.091362"
    },
    "IStargate.sol": {
      "file_id": "IStargate.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// Interface for Stargate V2\n/// @custom:version 1.0.0\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\n/// @notice Stargate implementation type.\nenum StargateType {\n    Pool,\n    OFT\n}\n\n/// @notice Ticket data for bus ride.\nstruct Ticket {\n    uint72 ticketId;\n    bytes passengerBytes;\n}\n\n/// @title Interface for Stargate.\n/// @notice Defines an API for sending tokens to destination chains.\ninterface IStargate {\n    /**\n     * @dev Struct representing token parameters for the OFT send() operation.\n     */\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    /**\n     * @dev Struct representing OFT limit information.\n     * @dev These amounts can change dynamically and are up the the specific oft implementation.\n     */\n    struct OFTLimit {\n        uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n        uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n    }\n\n    /**\n     * @dev Struct representing OFT receipt information.\n     */\n    struct OFTReceipt {\n        uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n        // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n        uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n    }\n\n    /**\n     * @dev Struct representing OFT fee details.\n     * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n     */\n    struct OFTFeeDetail {\n        int256 feeAmountLD; // Amount of the fee in local decimals.\n        string description; // Description of the fee.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n\n    struct MessagingReceipt {\n        bytes32 guid;\n        uint64 nonce;\n        MessagingFee fee;\n    }\n\n    /// @dev This function is same as `send` in OFT interface but returns the ticket data if in the bus ride mode,\n    /// which allows the caller to ride and drive the bus in the same transaction.\n    function sendToken(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    )\n        external\n        payable\n        returns (\n            MessagingReceipt memory msgReceipt,\n            OFTReceipt memory oftReceipt,\n            Ticket memory ticket\n        );\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        returns (\n            OFTLimit memory,\n            OFTFeeDetail[] memory oftFeeDetails,\n            OFTReceipt memory\n        );\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n}\n\ninterface ITokenMessaging {\n    function assetIds(address tokenAddress) external returns (uint16);\n\n    function stargateImpls(uint16 assetId) external returns (address);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.084299"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.088113"
      },
      "final_report": {
        "file_id": "IStargate.sol",
        "timestamp": "2025-03-11T07:05:51.088133",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IStargate.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.088145"
    },
    "IStargateRouter.sol": {
      "file_id": "IStargateRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// Interface for Stargate V1\n/// @custom:version 1.0.0\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\n// solhint-disable contract-name-camelcase\ninterface IStargateRouter {\n    struct lzTxObj {\n        uint256 dstGasForCall;\n        uint256 dstNativeAmount;\n        bytes dstNativeAddr;\n    }\n\n    /// @notice SwapAmount struct\n    /// @param amountLD The amount, in Local Decimals, to be swapped\n    /// @param minAmountLD The minimum amount accepted out on destination\n    struct SwapAmount {\n        uint256 amountLD;\n        uint256 minAmountLD;\n    }\n\n    /// @notice Returns factory address used for creating pools.\n    function factory() external view returns (address);\n\n    /// @notice Swap assets cross-chain.\n    /// @dev Pass (0, 0, \"0x\") to lzTxParams\n    ///      for 0 additional gasLimit increase, 0 airdrop, at 0x address.\n    /// @param dstChainId Destination chainId\n    /// @param srcPoolId Source pool id\n    /// @param dstPoolId Dest pool id\n    /// @param refundAddress Refund adddress. extra gas (if any) is returned to this address\n    /// @param amountLD Quantity to swap\n    /// @param minAmountLD The min qty you would accept on the destination\n    /// @param lzTxParams Additional gas, airdrop data\n    /// @param to The address to send the tokens to on the destination\n    /// @param payload Additional payload. You can abi.encode() them here\n    function swap(\n        uint16 dstChainId,\n        uint256 srcPoolId,\n        uint256 dstPoolId,\n        address payable refundAddress,\n        uint256 amountLD,\n        uint256 minAmountLD,\n        lzTxObj memory lzTxParams,\n        bytes calldata to,\n        bytes calldata payload\n    ) external payable;\n\n    /// @notice Swap native assets cross-chain.\n    /// @param _dstChainId Destination Stargate chainId\n    /// @param _refundAddress Refunds additional messageFee to this address\n    /// @param _toAddress The receiver of the destination ETH\n    /// @param _swapAmount The amount and the minimum swap amount\n    /// @param _lzTxParams The LZ tx params\n    /// @param _payload The payload to send to the destination\n    function swapETHAndCall(\n        uint16 _dstChainId,\n        address payable _refundAddress,\n        bytes calldata _toAddress,\n        SwapAmount memory _swapAmount,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _payload\n    ) external payable;\n\n    /// @notice Returns the native gas fee required for swap.\n    function quoteLayerZeroFee(\n        uint16 dstChainId,\n        uint8 functionType,\n        bytes calldata toAddress,\n        bytes calldata transferAndCallPayload,\n        lzTxObj memory lzTxParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.086902"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.091224"
      },
      "final_report": {
        "file_id": "IStargateRouter.sol",
        "timestamp": "2025-03-11T07:05:51.091248",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IStargateRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.091260"
    },
    "ISymbiosisMetaRouter.sol": {
      "file_id": "ISymbiosisMetaRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ISymbiosisMetaRouter {\n    /// @notice entry point data to Symbiosis contracts\n    /// @param firstSwapCalldata calldata for the dex swap to get corresponding asset (USDC) on init chain\n    /// @param secondSwapCalldata legacy calldata from v1, should be empty\n    /// @param approvedTokens set of token for firstSwapCalldata, and o bridgingCalldata\n    /// @param firstDexRouter entry point for firstSwapCalldata\n    /// @param secondDexRouter legacy entry point from v1, should be empty\n    /// @param amount of tokens\n    /// @param nativeIn native token in amount or not\n    /// @param relayRecipient entry point to bridge provided from API\n    /// @param otherSideCalldata bridging calldata\n    struct MetaRouteTransaction {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address[] approvedTokens;\n        address firstDexRouter;\n        address secondDexRouter;\n        uint256 amount;\n        bool nativeIn;\n        address relayRecipient;\n        bytes otherSideCalldata;\n    }\n\n    /**\n     * @notice Method that starts the Meta Routing in Symbiosis\n     * @param _metarouteTransaction metaRoute offchain transaction data\n     */\n    function metaRoute(\n        MetaRouteTransaction calldata _metarouteTransaction\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.090133"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.094806"
      },
      "final_report": {
        "file_id": "ISymbiosisMetaRouter.sol",
        "timestamp": "2025-03-11T07:05:51.094831",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ISymbiosisMetaRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.094843"
    },
    "ISynapseRouter.sol": {
      "file_id": "ISynapseRouter.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ISynapseRouter {\n    /// @notice Struct representing a request for SynapseRouter.\n    /// @dev tokenIn is supplied separately.\n    /// @param swapAdapter Adapter address that will perform the swap.\n    ///                    Address(0) specifies a \"no swap\" query.\n    /// @param tokenOut Token address to swap to.\n    /// @param minAmountOut Minimum amount of tokens to receive after the swap,\n    ///                     or tx will be reverted.\n    /// @param deadline Latest timestamp for when the transaction needs to be executed,\n    ///                 or tx will be reverted.\n    /// @param rawParams ABI-encoded params for the swap that will be passed to `swapAdapter`.\n    ///                  Should be SynapseParams for swaps via SynapseAdapter.\n    struct SwapQuery {\n        address swapAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    /// @notice Struct representing a request for a swap quote from a bridge token.\n    /// @dev tokenOut is passed externally.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param amountIn Amount of bridge token to start with, before the bridge fee is applied.\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n    /// @notice Struct representing a bridge token.\n    ///         Used as the return value in view functions.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param token Bridge token address.\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n    /// @notice Initiate a bridge transaction with an optional swap on both origin\n    ///         and destination chains.\n    /// @dev Note This method is payable.\n    ///      If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    ///      If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    ///      Make sure to approve this contract for spending `token` beforehand.\n    ///      originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    ///      `token` is always a token user is sending.\n    ///      In case token requires a wrapper token to be bridge,\n    ///      use underlying address for `token` instead of the wrapper one.\n    ///\n    ///      `originQuery` contains instructions for the swap on origin chain.\n    ///      As above, originQuery.tokenOut should always use the underlying address.\n    ///      In other words, the concept of wrapper token is fully abstracted away from the end user.\n    ///\n    ///      `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    ///      Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    ///      `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    ///      Complex swaps on destination chain are not supported for the time being.\n    ///      Check contract description above for more details.\n    /// @param to Address to receive tokens on destination chain.\n    /// @param chainId Destination chain id.\n    /// @param token Initial token for the bridge transaction to be pulled from the user.\n    /// @param amount Amount of the initial tokens for the bridge transaction.\n    /// @param originQuery Origin swap query. Empty struct indicates no swap is required.\n    /// @param destQuery Destination swap query. Empty struct indicates no swap is required.\n    function bridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token\n    ///         from the given list, treating the swap as \"origin swap\",\n    ///         without putting any restrictions on the swap.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    ///      Check (query.minAmountOut != 0): this is true only if the swap is possible\n    ///      and bridge token is supported.\n    ///      The returned queries with minAmountOut != 0 could be used as `originQuery`\n    ///      with SynapseRouter.\n    /// Note: It is possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the origin swap.\n    /// @param tokenIn Initial token that user wants to bridge/swap.\n    /// @param tokenSymbols List of symbols representing bridge tokens.\n    /// @param amountIn Amount of tokens user wants to bridge/swap.\n    /// @return originQueries List of structs that could be used as `originQuery` in SynapseRouter.\n    ///                       minAmountOut and deadline fields will need to be adjusted\n    ///                       based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string[] memory tokenSymbols,\n        uint256 amountIn\n    ) external view returns (SwapQuery[] memory originQueries);\n\n    /// @notice Finds the best path between every supported bridge token from\n    ///         the given list and `tokenOut`, treating the swap as \"destination swap\",\n    ///         limiting possible actions to those available for every bridge token.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    /// Note: It is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the destination swap.\n    ///       For the time being, only swaps through the Synapse-supported pools\n    ///       are available on destination chain.\n    /// @param requests List of structs with following information:\n    ///                 - symbol: unique token ID consistent among all chains.\n    ///                 - amountIn: amount of bridge token to start with,\n    ///                              before the bridge fee is applied.\n    /// @param tokenOut Token user wants to receive on destination chain.\n    /// @return destQueries List of structs that could be used as `destQuery` in SynapseRouter.\n    ///                     minAmountOut and deadline fields will need to be adjusted based\n    ///                     on the user settings.\n    function getDestinationAmountOut(\n        DestRequest[] memory requests,\n        address tokenOut\n    ) external view returns (SwapQuery[] memory destQueries);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols),\n    ///         such that destination swap from a bridge token to `tokenOut` is possible.\n    /// @param tokenOut Token address to swap to on destination chain\n    /// @return tokens List of structs with following information:\n    ///                - symbol: unique token ID consistent among all chains\n    ///                - token: bridge token address\n    function getConnectedBridgeTokens(\n        address tokenOut\n    ) external view returns (BridgeToken[] memory tokens);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.092552"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.097191"
      },
      "final_report": {
        "file_id": "ISynapseRouter.sol",
        "timestamp": "2025-03-11T07:05:51.097217",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ISynapseRouter.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.097230"
    },
    "ITeleportGateway.sol": {
      "file_id": "ITeleportGateway.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ITeleportGateway {\n    /// @notice Initiate DAI transfer.\n    /// @param targetDomain Domain of destination chain.\n    /// @param receiver Receiver address.\n    /// @param amount The amount of DAI to transfer.\n    function initiateTeleport(\n        bytes32 targetDomain,\n        address receiver,\n        uint128 amount\n    ) external;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.146604"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.153933"
      },
      "final_report": {
        "file_id": "ITeleportGateway.sol",
        "timestamp": "2025-03-11T07:05:51.153958",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ITeleportGateway.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.153970"
    },
    "IThorSwap.sol": {
      "file_id": "IThorSwap.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n/// @title ThorSwap Interface\ninterface IThorSwap {\n    // Thorchain router\n    function depositWithExpiry(\n        address vault,\n        address asset,\n        uint256 amount,\n        string calldata memo,\n        uint256 expiration\n    ) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.145984"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.149816"
      },
      "final_report": {
        "file_id": "IThorSwap.sol",
        "timestamp": "2025-03-11T07:05:51.149839",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IThorSwap.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.149852"
    },
    "ITokenMessenger.sol": {
      "file_id": "ITokenMessenger.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ITokenMessenger {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param amount Amount of tokens to burn.\n    /// @param destinationDomain Destination domain.\n    /// @param mintRecipient Address of mint recipient on destination domain.\n    /// @param burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 nonce);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.147363"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.150785"
      },
      "final_report": {
        "file_id": "ITokenMessenger.sol",
        "timestamp": "2025-03-11T07:05:51.150810",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ITokenMessenger.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.150822"
    },
    "ITransactionManager.sol": {
      "file_id": "ITransactionManager.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface ITransactionManager {\n    // Structs\n\n    // Holds all data that is constant between sending and\n    // receiving chains. The hash of this is what gets signed\n    // to ensure the signature can be used on both chains.\n    struct InvariantTransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback; // funds sent here on cancel\n        address receivingAddress;\n        address callTo;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        bytes32 callDataHash; // hashed to prevent free option\n        bytes32 transactionId;\n    }\n\n    // All Transaction data, constant and variable\n    struct TransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback;\n        address receivingAddress;\n        address callTo;\n        bytes32 callDataHash;\n        bytes32 transactionId;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        uint256 amount;\n        uint256 expiry;\n        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel\n    }\n\n    /**\n     * Arguments for calling prepare()\n     * @param invariantData The data for a crosschain transaction that will\n     *                      not change between sending and receiving chains.\n     *                      The hash of this data is used as the key to store\n     *                      the inforamtion that does change between chains\n     *                      (amount,expiry,preparedBlock) for verification\n     * @param amount The amount of the transaction on this chain\n     * @param expiry The block.timestamp when the transaction will no longer be\n     *               fulfillable and is freely cancellable on this chain\n     * @param encryptedCallData The calldata to be executed when the tx is\n     *                          fulfilled. Used in the function to allow the user\n     *                          to reconstruct the tx from events. Hash is stored\n     *                          onchain to prevent shenanigans.\n     * @param encodedBid The encoded bid that was accepted by the user for this\n     *                   crosschain transfer. It is supplied as a param to the\n     *                   function but is only used in event emission\n     * @param bidSignature The signature of the bidder on the encoded bid for\n     *                     this transaction. Only used within the function for\n     *                     event emission. The validity of the bid and\n     *                     bidSignature are enforced offchain\n     * @param encodedMeta The meta for the function\n     */\n    struct PrepareArgs {\n        InvariantTransactionData invariantData;\n        uint256 amount;\n        uint256 expiry;\n        bytes encryptedCallData;\n        bytes encodedBid;\n        bytes bidSignature;\n        bytes encodedMeta;\n    }\n\n    // called in the following order (in happy case)\n    // 1. prepare by user on sending chain\n    function prepare(\n        PrepareArgs calldata args\n    ) external payable returns (TransactionData memory);\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.148341"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.151611"
      },
      "final_report": {
        "file_id": "ITransactionManager.sol",
        "timestamp": "2025-03-11T07:05:51.151634",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ITransactionManager.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.151647"
    },
    "IXDaiBridge.sol": {
      "file_id": "IXDaiBridge.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IXDaiBridge {\n    /// @notice Bridge Dai to xDai and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Ethereum\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(address receiver, uint256 amount) external;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.149210"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.152806"
      },
      "final_report": {
        "file_id": "IXDaiBridge.sol",
        "timestamp": "2025-03-11T07:05:51.152830",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IXDaiBridge.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.152843"
    },
    "IXDaiBridgeL2.sol": {
      "file_id": "IXDaiBridgeL2.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\ninterface IXDaiBridgeL2 {\n    /// @notice Bridge xDai to DAI and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Gnosis\n    /// @param receiver Receiver address\n    function relayTokens(address receiver) external payable;\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.164376"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.168288"
      },
      "final_report": {
        "file_id": "IXDaiBridgeL2.sol",
        "timestamp": "2025-03-11T07:05:51.168309",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of IXDaiBridgeL2.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.168321"
    },
    "LibAccess.sol": {
      "file_id": "LibAccess.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { CannotAuthoriseSelf, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Library\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\nlibrary LibAccess {\n    /// Types ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.access.management\");\n\n    /// Storage ///\n    struct AccessStorage {\n        mapping(bytes4 => mapping(address => bool)) execAccess;\n    }\n\n    /// Events ///\n    event AccessGranted(address indexed account, bytes4 indexed method);\n    event AccessRevoked(address indexed account, bytes4 indexed method);\n\n    /// @dev Fetch local storage\n    function accessStorage()\n        internal\n        pure\n        returns (AccessStorage storage accStor)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            accStor.slot := position\n        }\n    }\n\n    /// @notice Gives an address permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to grant permission to\n    function addAccess(bytes4 selector, address executor) internal {\n        if (executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = true;\n        emit AccessGranted(executor, selector);\n    }\n\n    /// @notice Revokes permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to revoke permission from\n    function removeAccess(bytes4 selector, address executor) internal {\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = false;\n        emit AccessRevoked(executor, selector);\n    }\n\n    /// @notice Enforces access control by reverting if `msg.sender`\n    ///     has not been given permission to execute `msg.sig`\n    function enforceAccessControl() internal view {\n        AccessStorage storage accStor = accessStorage();\n        if (accStor.execAccess[msg.sig][msg.sender] != true)\n            revert UnAuthorized();\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.167654"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.174749"
      },
      "final_report": {
        "file_id": "LibAccess.sol",
        "timestamp": "2025-03-11T07:05:51.174769",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibAccess.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.174781"
    },
    "LibAllowList.sol": {
      "file_id": "LibAllowList.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { InvalidContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Lib Allow List\n/// @author LI.FI (https://li.fi)\n/// @notice Library for managing and accessing the conract address allow list\nlibrary LibAllowList {\n    /// Storage ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.allow.list\");\n\n    struct AllowListStorage {\n        mapping(address => bool) allowlist;\n        mapping(bytes4 => bool) selectorAllowList;\n        address[] contracts;\n    }\n\n    /// @dev Adds a contract address to the allow list\n    /// @param _contract the contract address to add\n    function addAllowedContract(address _contract) internal {\n        _checkAddress(_contract);\n\n        AllowListStorage storage als = _getStorage();\n\n        if (als.allowlist[_contract]) return;\n\n        als.allowlist[_contract] = true;\n        als.contracts.push(_contract);\n    }\n\n    /// @dev Checks whether a contract address has been added to the allow list\n    /// @param _contract the contract address to check\n    function contractIsAllowed(\n        address _contract\n    ) internal view returns (bool) {\n        return _getStorage().allowlist[_contract];\n    }\n\n    /// @dev Remove a contract address from the allow list\n    /// @param _contract the contract address to remove\n    function removeAllowedContract(address _contract) internal {\n        AllowListStorage storage als = _getStorage();\n\n        if (!als.allowlist[_contract]) {\n            return;\n        }\n\n        als.allowlist[_contract] = false;\n\n        uint256 length = als.contracts.length;\n        // Find the contract in the list\n        for (uint256 i = 0; i < length; i++) {\n            if (als.contracts[i] == _contract) {\n                // Move the last element into the place to delete\n                als.contracts[i] = als.contracts[length - 1];\n                // Remove the last element\n                als.contracts.pop();\n                break;\n            }\n        }\n    }\n\n    /// @dev Fetch contract addresses from the allow list\n    function getAllowedContracts() internal view returns (address[] memory) {\n        return _getStorage().contracts;\n    }\n\n    /// @dev Add a selector to the allow list\n    /// @param _selector the selector to add\n    function addAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = true;\n    }\n\n    /// @dev Removes a selector from the allow list\n    /// @param _selector the selector to remove\n    function removeAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = false;\n    }\n\n    /// @dev Returns if selector has been added to the allow list\n    /// @param _selector the selector to check\n    function selectorIsAllowed(bytes4 _selector) internal view returns (bool) {\n        return _getStorage().selectorAllowList[_selector];\n    }\n\n    /// @dev Fetch local storage struct\n    function _getStorage()\n        internal\n        pure\n        returns (AllowListStorage storage als)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            als.slot := position\n        }\n    }\n\n    /// @dev Contains business logic for validating a contract address.\n    /// @param _contract address of the dex to check\n    function _checkAddress(address _contract) private view {\n        if (_contract == address(0)) revert InvalidContract();\n\n        if (_contract.code.length == 0) revert InvalidContract();\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.169245"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.178723"
      },
      "final_report": {
        "file_id": "LibAllowList.sol",
        "timestamp": "2025-03-11T07:05:51.178746",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibAllowList.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.178758"
    },
    "LibAsset.sol": {
      "file_id": "LibAsset.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\nimport { InsufficientBalance, NullAddrIsNotAnERC20Token, NullAddrIsNotAValidSpender, NoTransferToNullAddress, InvalidAmount, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LibSwap } from \"./LibSwap.sol\";\n\n/// @title LibAsset\n/// @custom:version 1.0.2\n/// @notice This library contains helpers for dealing with onchain transfers\n///         of assets, including accounting for the native asset `assetId`\n///         conventions and any noncompliant ERC20 transfers\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    address internal constant NULL_ADDRESS = address(0);\n\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n\n    /// @dev All native assets use the empty address for their asset id\n    ///      by convention\n\n    address internal constant NATIVE_ASSETID = NULL_ADDRESS; //address(0)\n\n    /// @notice Gets the balance of the inheriting contract for the given asset\n    /// @param assetId The asset identifier to get the balance of\n    /// @return Balance held by contracts using this library\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return\n            isNativeAsset(assetId)\n                ? address(this).balance\n                : IERC20(assetId).balanceOf(address(this));\n    }\n\n    /// @notice Transfers ether from the inheriting contract to a given\n    ///         recipient\n    /// @param recipient Address to send ether to\n    /// @param amount Amount to send to given recipient\n    function transferNativeAsset(\n        address payable recipient,\n        uint256 amount\n    ) private {\n        if (recipient == NULL_ADDRESS) revert NoTransferToNullAddress();\n        if (amount > address(this).balance)\n            revert InsufficientBalance(amount, address(this).balance);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n    }\n\n    /// @notice If the current allowance is insufficient, the allowance for a given spender\n    /// is set to MAX_UINT.\n    /// @param assetId Token address to transfer\n    /// @param spender Address to give spend approval to\n    /// @param amount Amount to approve for spending\n    function maxApproveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) {\n            return;\n        }\n        if (spender == NULL_ADDRESS) {\n            revert NullAddrIsNotAValidSpender();\n        }\n\n        if (assetId.allowance(address(this), spender) < amount) {\n            SafeERC20.forceApprove(IERC20(assetId), spender, MAX_UINT);\n        }\n    }\n\n    /// @notice Transfers tokens from the inheriting contract to a given\n    ///         recipient\n    /// @param assetId Token address to transfer\n    /// @param recipient Address to send token to\n    /// @param amount Amount to send to given recipient\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (recipient == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        uint256 assetBalance = IERC20(assetId).balanceOf(address(this));\n        if (amount > assetBalance) {\n            revert InsufficientBalance(amount, assetBalance);\n        }\n        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);\n    }\n\n    /// @notice Transfers tokens from a sender to a given recipient\n    /// @param assetId Token address to transfer\n    /// @param from Address of sender/owner\n    /// @param to Address of recipient/spender\n    /// @param amount Amount to transfer from owner to spender\n    function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (to == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        IERC20 asset = IERC20(assetId);\n        uint256 prevBalance = asset.balanceOf(to);\n        SafeERC20.safeTransferFrom(asset, from, to, amount);\n        if (asset.balanceOf(to) - prevBalance != amount) {\n            revert InvalidAmount();\n        }\n    }\n\n    function depositAsset(address assetId, uint256 amount) internal {\n        if (amount == 0) revert InvalidAmount();\n        if (isNativeAsset(assetId)) {\n            if (msg.value < amount) revert InvalidAmount();\n        } else {\n            uint256 balance = IERC20(assetId).balanceOf(msg.sender);\n            if (balance < amount) revert InsufficientBalance(amount, balance);\n            transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n    }\n\n    function depositAssets(LibSwap.SwapData[] calldata swaps) internal {\n        for (uint256 i = 0; i < swaps.length; ) {\n            LibSwap.SwapData calldata swap = swaps[i];\n            if (swap.requiresDeposit) {\n                depositAsset(swap.sendingAssetId, swap.fromAmount);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Determines whether the given assetId is the native asset\n    /// @param assetId The asset identifier to evaluate\n    /// @return Boolean indicating if the asset is the native asset\n    function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }\n\n    /// @notice Wrapper function to transfer a given asset (native or erc20) to\n    ///         some recipient. Should handle all non-compliant return value\n    ///         tokens as well by using the SafeERC20 contract by open zeppelin.\n    /// @param assetId Asset id for transfer (address(0) for native asset,\n    ///                token address for erc20s)\n    /// @param recipient Address to send asset to\n    /// @param amount Amount to send to given recipient\n    function transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal {\n        isNativeAsset(assetId)\n            ? transferNativeAsset(recipient, amount)\n            : transferERC20(assetId, recipient, amount);\n    }\n\n    /// @dev Checks whether the given address is a contract and contains code\n    function isContract(address _contractAddr) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_contractAddr)\n        }\n        return size > 0;\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.163264"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.166778"
      },
      "final_report": {
        "file_id": "LibAsset.sol",
        "timestamp": "2025-03-11T07:05:51.166799",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibAsset.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.166812"
    },
    "LibBytes.sol": {
      "file_id": "LibBytes.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(\n        bytes memory _bytes,\n        uint256 _start\n    ) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.165542"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.169976"
      },
      "final_report": {
        "file_id": "LibBytes.sol",
        "timestamp": "2025-03-11T07:05:51.169999",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibBytes.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.170012"
    },
    "LibDiamond.sol": {
      "file_id": "LibDiamond.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// import { IDiamondCut } from \"../Interfaces/LibDiamond.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { OnlyContractOwner } from \"../Errors/GenericErrors.sol\";\n\n/// Implementation of EIP-2535 Diamond Standard\n/// https://eips.ethereum.org/EIPS/eip-2535\nlibrary LibDiamond {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    // Diamond specific errors\n    error IncorrectFacetCutAction();\n    error NoSelectorsInFace();\n    error FunctionAlreadyExists();\n    error FacetAddressIsZero();\n    error FacetAddressIsNotZero();\n    error FacetContainsNoCode();\n    error FunctionDoesNotExist();\n    error FunctionIsImmutable();\n    error InitZeroButCalldataNotEmpty();\n    error CalldataEmptyButInitNotZero();\n    error InitReverted();\n    // ----------------\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner)\n            revert OnlyContractOwner();\n    }\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            LibDiamond.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == LibDiamond.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == LibDiamond.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == LibDiamond.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert IncorrectFacetCutAction();\n            }\n            unchecked {\n                ++facetIndex;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (!LibUtil.isZeroAddress(oldFacetAddress)) {\n                revert FunctionAlreadyExists();\n            }\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress == _facetAddress) {\n                revert FunctionAlreadyExists();\n            }\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        if (!LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsNotZero();\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function addFacet(\n        DiamondStorage storage ds,\n        address _facetAddress\n    ) internal {\n        enforceHasContractCode(_facetAddress);\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FunctionDoesNotExist();\n        }\n        // an immutable function is a function defined directly in a diamond\n        if (_facetAddress == address(this)) {\n            revert FunctionIsImmutable();\n        }\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                selectorPosition\n            ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (LibUtil.isZeroAddress(_init)) {\n            if (_calldata.length != 0) {\n                revert InitZeroButCalldataNotEmpty();\n            }\n        } else {\n            if (_calldata.length == 0) {\n                revert CalldataEmptyButInitNotZero();\n            }\n            if (_init != address(this)) {\n                enforceHasContractCode(_init);\n            }\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert InitReverted();\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert FacetContainsNoCode();\n        }\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.166478"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.171531"
      },
      "final_report": {
        "file_id": "LibDiamond.sol",
        "timestamp": "2025-03-11T07:05:51.171551",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibDiamond.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.171563"
    },
    "LibDiamondLoupe.sol": {
      "file_id": "LibDiamondLoupe.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../Interfaces/IDiamondLoupe.sol\";\n\n/// Library for DiamondLoupe functions (to avoid using external calls when using DiamondLoupe)\nlibrary LibDiamondLoupe {\n    function facets()\n        internal\n        view\n        returns (IDiamondLoupe.Facet[] memory facets_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new IDiamondLoupe.Facet[](numFacets);\n        for (uint256 i = 0; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function facetFunctionSelectors(\n        address _facet\n    ) internal view returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    function facetAddresses()\n        internal\n        view\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    function facetAddress(\n        bytes4 _functionSelector\n    ) internal view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.171245"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.182009"
      },
      "final_report": {
        "file_id": "LibDiamondLoupe.sol",
        "timestamp": "2025-03-11T07:05:51.182033",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibDiamondLoupe.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.182046"
    },
    "LibSwap.sol": {
      "file_id": "LibSwap.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { InvalidContract, NoSwapFromZeroBalance, InsufficientBalance } from \"../Errors/GenericErrors.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibSwap {\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n        bool requiresDeposit;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swap) internal {\n        if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract();\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n        uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId)\n            ? _swap.fromAmount\n            : 0;\n        uint256 initialSendingAssetBalance = LibAsset.getOwnBalance(\n            _swap.sendingAssetId\n        );\n        uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance(\n            _swap.receivingAssetId\n        );\n\n        if (nativeValue == 0) {\n            LibAsset.maxApproveERC20(\n                IERC20(_swap.sendingAssetId),\n                _swap.approveTo,\n                _swap.fromAmount\n            );\n        }\n\n        if (initialSendingAssetBalance < _swap.fromAmount) {\n            revert InsufficientBalance(\n                _swap.fromAmount,\n                initialSendingAssetBalance\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call{\n            value: nativeValue\n        }(_swap.callData);\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId);\n\n        emit AssetSwapped(\n            transactionId,\n            _swap.callTo,\n            _swap.sendingAssetId,\n            _swap.receivingAssetId,\n            _swap.fromAmount,\n            newBalance > initialReceivingAssetBalance\n                ? newBalance - initialReceivingAssetBalance\n                : newBalance,\n            block.timestamp\n        );\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.178116"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.205370"
      },
      "final_report": {
        "file_id": "LibSwap.sol",
        "timestamp": "2025-03-11T07:05:51.205396",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibSwap.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.205409"
    },
    "LibUtil.sol": {
      "file_id": "LibUtil.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\nimport \"./LibBytes.sol\";\n\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    function getRevertMsg(\n        bytes memory _res\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Determines whether the given address is the zero address\n    /// @param addr The address to verify\n    /// @return Boolean indicating if the address is the zero address\n    function isZeroAddress(address addr) internal pure returns (bool) {\n        return addr == address(0);\n    }\n\n    function revertWith(bytes memory data) internal pure {\n        assembly {\n            let dataSize := mload(data) // Load the size of the data\n            let dataPtr := add(data, 0x20) // Advance data pointer to the next word\n            revert(dataPtr, dataSize) // Revert with the given data\n        }\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.254515"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.257453"
      },
      "final_report": {
        "file_id": "LibUtil.sol",
        "timestamp": "2025-03-11T07:05:51.257476",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LibUtil.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.257489"
    },
    "OFTComposeMsgCodec.sol": {
      "file_id": "OFTComposeMsgCodec.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {},
        "source_code": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity ^0.8.17;\n\n// This library was taken from: https://github.com/LayerZero-Labs/LayerZero-v2/tree/38278c8d8f4606d0ce247d6edd473fc96674769b/packages/layerzero-v2/evm/oapp/contracts/oft/libs\n// since the Solidity version did not match with ours, we decided to use a copy of this library with adjusted solc version for better compatibility\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce from the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID from the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(\n        bytes calldata _msg\n    ) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
      },
      "call_graph": {},
      "flow_data": {},
      "flow_paths": {},
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.255588"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.264675"
      },
      "final_report": {
        "file_id": "OFTComposeMsgCodec.sol",
        "timestamp": "2025-03-11T07:05:51.264697",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {},
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of OFTComposeMsgCodec.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.264710"
    },
    "ERC20Proxy.sol": {
      "file_id": "ERC20Proxy.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ERC20Proxy": {
            "name": "ERC20Proxy",
            "inheritance": [
              "WithdrawablePeriphery"
            ],
            "functions": {
              "transferFrom": {
                "name": "transferFrom",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "to"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (!authorizedCallers[msg.sender]) revert UnAuthorized();\n\n        LibAsset.transferFromERC20(tokenAddress, from, to, amount);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\n\n/// @title ERC20 Proxy\n/// @author LI.FI (https://li.fi)\n/// @notice Proxy contract for safely transferring ERC20 tokens for swaps/executions\n/// @custom:version 1.1.0\ncontract ERC20Proxy is WithdrawablePeriphery {\n    /// Storage ///\n    mapping(address => bool) public authorizedCallers;\n\n    /// Events ///\n    event AuthorizationChanged(address indexed caller, bool authorized);\n\n    /// Constructor\n    constructor(address _owner) WithdrawablePeriphery(_owner) {}\n\n    /// @notice Sets whether or not a specified caller is authorized to call this contract\n    /// @param caller the caller to change authorization for\n    /// @param authorized specifies whether the caller is authorized (true/false)\n    function setAuthorizedCaller(\n        address caller,\n        bool authorized\n    ) external onlyOwner {\n        authorizedCallers[caller] = authorized;\n        emit AuthorizationChanged(caller, authorized);\n    }\n\n    /// @notice Transfers tokens from one address to another specified address\n    /// @param tokenAddress the ERC20 contract address of the token to send\n    /// @param from the address to transfer from\n    /// @param to the address to transfer to\n    /// @param amount the amount of tokens to send\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        if (!authorizedCallers[msg.sender]) revert UnAuthorized();\n\n        LibAsset.transferFromERC20(tokenAddress, from, to, amount);\n    }\n}\n"
      },
      "call_graph": {
        "ERC20Proxy": {
          "transferFrom": []
        }
      },
      "flow_data": {
        "ERC20Proxy": {
          "transferFrom": {
            "name": "transferFrom",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "!authorizedCallers[msg.sender]",
                "line": 1
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (!authorizedCallers[msg.sender])"
            },
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "to"
              },
              {
                "type": "uint256",
                "name": "amount"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "ERC20Proxy": {
          "transferFrom": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.273706"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.279815"
      },
      "final_report": {
        "file_id": "ERC20Proxy.sol",
        "timestamp": "2025-03-11T07:05:51.279839",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ERC20Proxy": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ERC20Proxy.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.279853"
    },
    "Executor.sol": {
      "file_id": "Executor.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "Executor": {
            "name": "Executor",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "ERC1155Holder",
              "ERC721Holder",
              "WithdrawablePeriphery"
            ],
            "functions": {
              "_processSwaps": {
                "name": "_processSwaps",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "_transferredAssetId"
                  },
                  {
                    "type": "address",
                    "name": "_receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  },
                  {
                    "type": "bool",
                    "name": "_depositAllowance"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 startingBalance;\n        uint256 finalAssetStartingBalance;\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        if (!LibAsset.isNativeAsset(finalAssetId)) {\n            finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId);\n        } else {\n            finalAssetStartingBalance =\n                LibAsset.getOwnBalance(finalAssetId) -\n                msg.value;\n        }\n\n        if (!LibAsset.isNativeAsset(_transferredAssetId)) {\n            startingBalance = LibAsset.getOwnBalance(_transferredAssetId);\n            if (_depositAllowance) {\n                uint256 allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                );\n                LibAsset.depositAsset(_transferredAssetId, allowance);\n            } else {\n                erc20Proxy.transferFrom(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        } else {\n            startingBalance =\n                LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value;\n        }\n\n        _executeSwaps(_transactionId, _swapData, _receiver);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId);\n        if (postSwapBalance > startingBalance) {\n            LibAsset.transferAsset(\n                _transferredAssetId,\n                _receiver,\n                postSwapBalance - startingBalance\n            );\n        }\n\n        uint256 finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        );\n\n        if (finalAssetPostSwapBalance > finalAssetStartingBalance) {\n            LibAsset.transferAsset(\n                finalAssetId,\n                _receiver,\n                finalAssetPostSwapBalance - finalAssetStartingBalance\n            );\n        }\n\n        emit LiFiTransferCompleted(\n            _transactionId,\n            _transferredAssetId,\n            _receiver,\n            finalAssetPostSwapBalance,\n            block.timestamp\n        );\n    }"
              },
              "_fetchBalances": {
                "name": "_fetchBalances",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256[] memory"
                  }
                ],
                "modifiers": [],
                "code": "uint256 numSwaps = _swapData.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swapData[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }"
              }
            },
            "state_variables": {
              "erc20Proxy": {
                "name": "erc20Proxy",
                "type": "IERC20Proxy",
                "visibility": "public",
                "initial_value": null
              },
              "numSwaps": {
                "name": "numSwaps",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_swapData.length"
              },
              "finalAsset": {
                "name": "finalAsset",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swaps[numSwaps - 1].receivingAssetId"
              },
              "curBalance": {
                "name": "curBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "0"
              },
              "curAsset": {
                "name": "curAsset",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swaps[i].receivingAssetId"
              },
              "startingBalance": {
                "name": "startingBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "finalAssetStartingBalance": {
                "name": "finalAssetStartingBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "finalAssetId": {
                "name": "finalAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "_swapData[_swapData.length - 1]\n            .receivingAssetId"
              },
              "allowance": {
                "name": "allowance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                )"
              },
              "postSwapBalance": {
                "name": "postSwapBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.getOwnBalance(_transferredAssetId)"
              },
              "finalAssetPostSwapBalance": {
                "name": "finalAssetPostSwapBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "LibAsset.getOwnBalance(\n            finalAssetId\n        )"
              },
              "asset": {
                "name": "asset",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "balances": {
                "name": "balances",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { UnAuthorized } from \"lifi/Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IERC20Proxy } from \"../Interfaces/IERC20Proxy.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { ERC1155Holder } from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Executor\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.1.0\ncontract Executor is\n    ILiFi,\n    ReentrancyGuard,\n    ERC1155Holder,\n    ERC721Holder,\n    WithdrawablePeriphery\n{\n    /// Storage ///\n\n    /// @notice The address of the ERC20Proxy contract\n    IERC20Proxy public erc20Proxy;\n\n    /// Events ///\n    event ERC20ProxySet(address indexed proxy);\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            uint256[] memory initialBalances = _fetchBalances(_swaps);\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance = 0;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance = LibAsset.getOwnBalance(curAsset);\n                    if (curBalance > initialBalances[i]) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - initialBalances[i]\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// Constructor\n    /// @notice Initialize local variables for the Executor\n    /// @param _erc20Proxy The address of the ERC20Proxy contract\n    constructor(\n        address _erc20Proxy,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        erc20Proxy = IERC20Proxy(_erc20Proxy);\n        emit ERC20ProxySet(_erc20Proxy);\n    }\n\n    /// External Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            0,\n            true\n        );\n    }\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    function swapAndExecute(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            _amount,\n            false\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    /// @param _depositAllowance If deposit approved amount of token\n    function _processSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount,\n        bool _depositAllowance\n    ) private {\n        uint256 startingBalance;\n        uint256 finalAssetStartingBalance;\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        if (!LibAsset.isNativeAsset(finalAssetId)) {\n            finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId);\n        } else {\n            finalAssetStartingBalance =\n                LibAsset.getOwnBalance(finalAssetId) -\n                msg.value;\n        }\n\n        if (!LibAsset.isNativeAsset(_transferredAssetId)) {\n            startingBalance = LibAsset.getOwnBalance(_transferredAssetId);\n            if (_depositAllowance) {\n                uint256 allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                );\n                LibAsset.depositAsset(_transferredAssetId, allowance);\n            } else {\n                erc20Proxy.transferFrom(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        } else {\n            startingBalance =\n                LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value;\n        }\n\n        _executeSwaps(_transactionId, _swapData, _receiver);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId);\n        if (postSwapBalance > startingBalance) {\n            LibAsset.transferAsset(\n                _transferredAssetId,\n                _receiver,\n                postSwapBalance - startingBalance\n            );\n        }\n\n        uint256 finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        );\n\n        if (finalAssetPostSwapBalance > finalAssetStartingBalance) {\n            LibAsset.transferAsset(\n                finalAssetId,\n                _receiver,\n                finalAssetPostSwapBalance - finalAssetStartingBalance\n            );\n        }\n\n        emit LiFiTransferCompleted(\n            _transactionId,\n            _transferredAssetId,\n            _receiver,\n            finalAssetPostSwapBalance,\n            block.timestamp\n        );\n    }\n\n    /// @dev Executes swaps one after the other\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to receive lefover tokens\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address payable _leftoverReceiver\n    ) private noLeftovers(_swapData, _leftoverReceiver) {\n        uint256 numSwaps = _swapData.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            if (_swapData[i].callTo == address(erc20Proxy)) {\n                revert UnAuthorized(); // Prevent calling ERC20 Proxy directly\n            }\n\n            LibSwap.SwapData calldata currentSwapData = _swapData[i];\n            LibSwap.swap(_transactionId, currentSwapData);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swapData Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swapData\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swapData.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swapData[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n\n    /// @dev required for receiving native assets from destination swaps\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "Executor": {
          "_processSwaps": [],
          "_fetchBalances": []
        }
      },
      "flow_data": {
        "Executor": {
          "_processSwaps": {
            "name": "_processSwaps",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "!LibAsset.isNativeAsset(finalAssetId",
                "line": 5
              },
              {
                "type": "if",
                "condition": "!LibAsset.isNativeAsset(_transferredAssetId",
                "line": 13
              },
              {
                "type": "if",
                "condition": "_depositAllowance",
                "line": 15
              },
              {
                "type": "if",
                "condition": "postSwapBalance > startingBalance",
                "line": 38
              },
              {
                "type": "if",
                "condition": "finalAssetPostSwapBalance > finalAssetStartingBalance",
                "line": 50
              }
            ],
            "state_changes": [
              {
                "variable": "startingBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(_transferredAssetId)",
                "line": 14
              },
              {
                "variable": "startingBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value",
                "line": 30
              },
              {
                "variable": "finalAssetStartingBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(finalAssetId)",
                "line": 6
              },
              {
                "variable": "finalAssetStartingBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(finalAssetId) -\n                msg.value",
                "line": 8
              },
              {
                "variable": "finalAssetId",
                "type": "address",
                "value": "_swapData[_swapData.length - 1]\n            .receivingAssetId",
                "line": 3
              },
              {
                "variable": "allowance",
                "type": "uint256",
                "value": "IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                )",
                "line": 16
              },
              {
                "variable": "postSwapBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(_transferredAssetId)",
                "line": 37
              },
              {
                "variable": "finalAssetPostSwapBalance",
                "type": "uint256",
                "value": "LibAsset.getOwnBalance(\n            finalAssetId\n        )",
                "line": 46
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "if (!LibAsset.isNativeAsset(finalAssetId)",
              "13": "if (!LibAsset.isNativeAsset(_transferredAssetId)",
              "15": "if (_depositAllowance)",
              "38": "if (postSwapBalance > startingBalance)",
              "50": "if (finalAssetPostSwapBalance > finalAssetStartingBalance)",
              "14": "State Change: startingBalance = LibAsset.getOwnBalance(_transferredAssetId)",
              "30": "State Change: startingBalance = LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value",
              "6": "State Change: finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId)",
              "8": "State Change: finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId) -\n                msg.value",
              "3": "State Change: finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId",
              "16": "State Change: allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                )",
              "37": "State Change: postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId)",
              "46": "State Change: finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        )"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "_transferredAssetId"
              },
              {
                "type": "address",
                "name": "_receiver"
              },
              {
                "type": "uint256",
                "name": "_amount"
              },
              {
                "type": "bool",
                "name": "_depositAllowance"
              }
            ],
            "returns": []
          },
          "_fetchBalances": {
            "name": "_fetchBalances",
            "visibility": "private",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < numSwaps;",
                "line": 4
              },
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(asset",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "numSwaps",
                "type": "uint256",
                "value": "_swapData.length",
                "line": 1
              },
              {
                "variable": "asset",
                "type": "address",
                "value": "_swapData[i].receivingAssetId",
                "line": 5
              },
              {
                "variable": "balances",
                "type": "return",
                "value": "new uint256[](numSwaps)",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "for (uint256 i = 0; i < numSwaps;)",
              "8": "if (LibAsset.isNativeAsset(asset)",
              "1": "State Change: numSwaps = _swapData.length",
              "5": "State Change: asset = _swapData[i].receivingAssetId",
              "2": "State Change: balances = new uint256[](numSwaps)"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              }
            ],
            "returns": [
              {
                "type": "uint256[] memory"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "Executor": {
          "_processSwaps": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_fetchBalances": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.271741"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.275513"
      },
      "final_report": {
        "file_id": "Executor.sol",
        "timestamp": "2025-03-11T07:05:51.275539",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "Executor": {
            "functions": 2,
            "state_variables": 13,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "ERC1155Holder",
              "ERC721Holder",
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of Executor.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.275553"
    },
    "FeeCollector.sol": {
      "file_id": "FeeCollector.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "FeeCollector": {
            "name": "FeeCollector",
            "inheritance": [
              "TransferrableOwnership"
            ],
            "functions": {
              "collectTokenFees": {
                "name": "collectTokenFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  },
                  {
                    "type": "uint256",
                    "name": "integratorFee"
                  },
                  {
                    "type": "uint256",
                    "name": "lifiFee"
                  },
                  {
                    "type": "address",
                    "name": "integratorAddress"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibAsset.depositAsset(tokenAddress, integratorFee + lifiFee);\n        _balances[integratorAddress][tokenAddress] += integratorFee;\n        _lifiBalances[tokenAddress] += lifiFee;\n        emit FeesCollected(\n            tokenAddress,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }"
              },
              "collectNativeFees": {
                "name": "collectNativeFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "integratorFee"
                  },
                  {
                    "type": "uint256",
                    "name": "lifiFee"
                  },
                  {
                    "type": "address",
                    "name": "integratorAddress"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "if (msg.value < integratorFee + lifiFee)\n            revert NotEnoughNativeForFees();\n        _balances[integratorAddress][LibAsset.NULL_ADDRESS] += integratorFee;\n        _lifiBalances[LibAsset.NULL_ADDRESS] += lifiFee;\n        uint256 remaining = msg.value - (integratorFee + lifiFee);\n        // Prevent extra native token from being locked in the contract\n        if (remaining > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            SafeTransferLib.safeTransferETH(msg.sender, remaining);\n        }\n        emit FeesCollected(\n            LibAsset.NULL_ADDRESS,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }"
              },
              "withdrawIntegratorFees": {
                "name": "withdrawIntegratorFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 balance = _balances[msg.sender][tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _balances[msg.sender][tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }"
              },
              "batchWithdrawIntegratorFees": {
                "name": "batchWithdrawIntegratorFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address[]",
                    "name": "tokenAddresses"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _balances[msg.sender][tokenAddresses[i]];\n            if (balance != 0) {\n                _balances[msg.sender][tokenAddresses[i]] = 0;\n                LibAsset.transferAsset(\n                    tokenAddresses[i],\n                    payable(msg.sender),\n                    balance\n                );\n                emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }"
              },
              "getTokenBalance": {
                "name": "getTokenBalance",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "integratorAddress"
                  },
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "return _balances[integratorAddress][tokenAddress];\n    }"
              },
              "getLifiTokenBalance": {
                "name": "getLifiTokenBalance",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256"
                  }
                ],
                "modifiers": [],
                "code": "return _lifiBalances[tokenAddress];\n    }"
              }
            },
            "state_variables": {
              "remaining": {
                "name": "remaining",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "msg.value - (integratorFee + lifiFee)"
              },
              "balance": {
                "name": "balance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "length": {
                "name": "length",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenAddresses.length"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/// @title Fee Collector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting integrator fees\n/// @custom:version 1.0.1\ncontract FeeCollector is TransferrableOwnership {\n    /// State ///\n\n    // Integrator -> TokenAddress -> Balance\n    mapping(address => mapping(address => uint256)) private _balances;\n    // TokenAddress -> Balance\n    mapping(address => uint256) private _lifiBalances;\n\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event FeesCollected(\n        address indexed _token,\n        address indexed _integrator,\n        uint256 _integratorFee,\n        uint256 _lifiFee\n    );\n    event FeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n    event LiFiFeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects fees for the integrator\n    /// @param tokenAddress address of the token to collect fees for\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectTokenFees(\n        address tokenAddress,\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external {\n        LibAsset.depositAsset(tokenAddress, integratorFee + lifiFee);\n        _balances[integratorAddress][tokenAddress] += integratorFee;\n        _lifiBalances[tokenAddress] += lifiFee;\n        emit FeesCollected(\n            tokenAddress,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Collects fees for the integrator in native token\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectNativeFees(\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external payable {\n        if (msg.value < integratorFee + lifiFee)\n            revert NotEnoughNativeForFees();\n        _balances[integratorAddress][LibAsset.NULL_ADDRESS] += integratorFee;\n        _lifiBalances[LibAsset.NULL_ADDRESS] += lifiFee;\n        uint256 remaining = msg.value - (integratorFee + lifiFee);\n        // Prevent extra native token from being locked in the contract\n        if (remaining > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            SafeTransferLib.safeTransferETH(msg.sender, remaining);\n        }\n        emit FeesCollected(\n            LibAsset.NULL_ADDRESS,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Withdraw fees and sends to the integrator\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawIntegratorFees(address tokenAddress) external {\n        uint256 balance = _balances[msg.sender][tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _balances[msg.sender][tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraw fees and sends to the integrator\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawIntegratorFees(\n        address[] memory tokenAddresses\n    ) external {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _balances[msg.sender][tokenAddresses[i]];\n            if (balance != 0) {\n                _balances[msg.sender][tokenAddresses[i]] = 0;\n                LibAsset.transferAsset(\n                    tokenAddresses[i],\n                    payable(msg.sender),\n                    balance\n                );\n                emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Withdraws fees and sends to lifi\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawLifiFees(address tokenAddress) external onlyOwner {\n        uint256 balance = _lifiBalances[tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _lifiBalances[tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit LiFiFeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees and sends to lifi\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawLifiFees(\n        address[] memory tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _lifiBalances[tokenAddresses[i]];\n            _lifiBalances[tokenAddresses[i]] = 0;\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit LiFiFeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the balance of the integrator\n    /// @param integratorAddress address of the integrator\n    /// @param tokenAddress address of the token to get the balance of\n    function getTokenBalance(\n        address integratorAddress,\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _balances[integratorAddress][tokenAddress];\n    }\n\n    /// @notice Returns the balance of lifi\n    /// @param tokenAddress address of the token to get the balance of\n    function getLifiTokenBalance(\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _lifiBalances[tokenAddress];\n    }\n}\n"
      },
      "call_graph": {
        "FeeCollector": {
          "collectTokenFees": [],
          "collectNativeFees": [],
          "withdrawIntegratorFees": [],
          "batchWithdrawIntegratorFees": [],
          "getTokenBalance": [],
          "getLifiTokenBalance": []
        }
      },
      "flow_data": {
        "FeeCollector": {
          "collectTokenFees": {
            "name": "collectTokenFees",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              },
              {
                "type": "uint256",
                "name": "integratorFee"
              },
              {
                "type": "uint256",
                "name": "lifiFee"
              },
              {
                "type": "address",
                "name": "integratorAddress"
              }
            ],
            "returns": []
          },
          "collectNativeFees": {
            "name": "collectNativeFees",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "msg.value < integratorFee + lifiFee",
                "line": 1
              },
              {
                "type": "if",
                "condition": "remaining > 0",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "remaining",
                "type": "uint256",
                "value": "msg.value - (integratorFee + lifiFee)",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "if (msg.value < integratorFee + lifiFee)",
              "7": "if (remaining > 0)",
              "5": "State Change: remaining = msg.value - (integratorFee + lifiFee)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "integratorFee"
              },
              {
                "type": "uint256",
                "name": "lifiFee"
              },
              {
                "type": "address",
                "name": "integratorAddress"
              }
            ],
            "returns": []
          },
          "withdrawIntegratorFees": {
            "name": "withdrawIntegratorFees",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "balance == 0",
                "line": 2
              }
            ],
            "state_changes": [
              {
                "variable": "balance",
                "type": "uint256",
                "value": "_balances[msg.sender][tokenAddress]",
                "line": 1
              },
              {
                "variable": "balance",
                "type": "uint256",
                "value": "= 0) {\n            return",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: balance = = 0) {\n            return",
              "1": "State Change: balance = _balances[msg.sender][tokenAddress]"
            },
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              }
            ],
            "returns": []
          },
          "batchWithdrawIntegratorFees": {
            "name": "batchWithdrawIntegratorFees",
            "visibility": "external",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < length;",
                "line": 3
              },
              {
                "type": "if",
                "condition": "balance != 0",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "balance",
                "type": "uint256",
                "value": "_balances[msg.sender][tokenAddresses[i]]",
                "line": 4
              },
              {
                "variable": "length",
                "type": "uint256",
                "value": "tokenAddresses.length",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "for (uint256 i = 0; i < length;)",
              "5": "if (balance != 0)",
              "4": "State Change: balance = _balances[msg.sender][tokenAddresses[i]]",
              "1": "State Change: length = tokenAddresses.length"
            },
            "parameters": [
              {
                "type": "address[]",
                "name": "tokenAddresses"
              }
            ],
            "returns": []
          },
          "getTokenBalance": {
            "name": "getTokenBalance",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "integratorAddress"
              },
              {
                "type": "address",
                "name": "tokenAddress"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          },
          "getLifiTokenBalance": {
            "name": "getLifiTokenBalance",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              }
            ],
            "returns": [
              {
                "type": "uint256"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "FeeCollector": {
          "collectTokenFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "collectNativeFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "withdrawIntegratorFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "batchWithdrawIntegratorFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getTokenBalance": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getLifiTokenBalance": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.272757"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.277062"
      },
      "final_report": {
        "file_id": "FeeCollector.sol",
        "timestamp": "2025-03-11T07:05:51.277087",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "FeeCollector": {
            "functions": 6,
            "state_variables": 3,
            "inheritance": [
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of FeeCollector.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.277101"
    },
    "GasZipPeriphery.sol": {
      "file_id": "GasZipPeriphery.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "GasZipPeriphery": {
            "name": "GasZipPeriphery",
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ],
            "functions": {
              "depositToGasZipERC20": {
                "name": "depositToGasZipERC20",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "LibSwap.SwapData",
                    "name": "_swapData"
                  },
                  {
                    "type": "IGasZip.GasZipData",
                    "name": "_gasZipData"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// deposit ERC20 asset from diamond\n        LibAsset.depositAsset(_swapData.sendingAssetId, _swapData.fromAmount);\n\n        // max approve to DEX, if not already done\n        LibAsset.maxApproveERC20(\n            IERC20(_swapData.sendingAssetId),\n            liFiDEXAggregator,\n            _swapData.fromAmount\n        );\n\n        // execute swap using LiFiDEXAggregator\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = liFiDEXAggregator.call(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n        // extract the swap output amount from the call return value\n        uint256 swapOutputAmount = abi.decode(res, (uint256));\n\n        // deposit native tokens to Gas.zip protocol\n        depositToGasZipNative(_gasZipData, swapOutputAmount);\n    }"
              },
              "depositToGasZipNative": {
                "name": "depositToGasZipNative",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "IGasZip.GasZipData",
                    "name": "_gasZipData"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "// make sure that receiverAddress is not 0\n        if (_gasZipData.receiverAddress == bytes32(0))\n            revert InvalidCallData();\n\n        // We are depositing to a new contract that supports deposits for EVM chains + Solana (therefore 'receiver' address is bytes32)\n        gasZipRouter.deposit{ value: _amount }(\n            _gasZipData.destinationChains,\n            _gasZipData.receiverAddress\n        );\n\n        // return unused native value to msg.sender, if any\n        // this is required due to LI.FI backend-internal requirements (money flow)\n        uint256 remainingNativeBalance = address(this).balance;\n        if (remainingNativeBalance > 0) {\n            msg.sender.safeTransferETH(remainingNativeBalance);\n        }\n    }"
              },
              "getDestinationChainsValue": {
                "name": "getDestinationChainsValue",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint8[]",
                    "name": "_chainIds"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 destinationChains"
                  }
                ],
                "modifiers": [],
                "code": "uint256 length = _chainIds.length;\n\n        if (length > MAX_CHAINID_LENGTH_ALLOWED) revert TooManyChainIds();\n\n        for (uint256 i; i < length; ++i) {\n            // Shift destinationChains left by 8 bits and add the next chainID\n            destinationChains =\n                (destinationChains << 8) |\n                uint256(_chainIds[i]);\n        }\n    }"
              }
            },
            "state_variables": {
              "swapOutputAmount": {
                "name": "swapOutputAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "abi.decode(res, (uint256))"
              },
              "remainingNativeBalance": {
                "name": "remainingNativeBalance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "address(this).balance"
              },
              "length": {
                "name": "length",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "_chainIds.length"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGasZip } from \"../Interfaces/IGasZip.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { InvalidCallData } from \"../Errors/GenericErrors.sol\";\n\n/// @title GasZipPeriphery\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality to swap ERC20 tokens to use the gas.zip protocol as a pre-bridge step (https://www.gas.zip/)\n/// @custom:version 1.0.1\ncontract GasZipPeriphery is ILiFi, WithdrawablePeriphery {\n    using SafeTransferLib for address;\n\n    /// State ///\n    IGasZip public immutable gasZipRouter;\n    address public immutable liFiDEXAggregator;\n    uint256 internal constant MAX_CHAINID_LENGTH_ALLOWED = 32;\n\n    /// Errors ///\n    error TooManyChainIds();\n\n    /// Constructor ///\n    constructor(\n        address _gasZipRouter,\n        address _liFiDEXAggregator,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        gasZipRouter = IGasZip(_gasZipRouter);\n        liFiDEXAggregator = _liFiDEXAggregator;\n    }\n\n    /// @notice Swaps ERC20 tokens to native and deposits these native tokens in the GasZip router contract\n    ///         Swaps are only allowed via the LiFiDEXAggregator\n    /// @dev this function can be used as a LibSwap.SwapData protocol step to combine it with any other bridge\n    /// @param _swapData The swap data that executes the swap from ERC20 to native\n    /// @param _gasZipData contains information about which chains gas should be sent to\n    function depositToGasZipERC20(\n        LibSwap.SwapData calldata _swapData,\n        IGasZip.GasZipData calldata _gasZipData\n    ) public {\n        // deposit ERC20 asset from diamond\n        LibAsset.depositAsset(_swapData.sendingAssetId, _swapData.fromAmount);\n\n        // max approve to DEX, if not already done\n        LibAsset.maxApproveERC20(\n            IERC20(_swapData.sendingAssetId),\n            liFiDEXAggregator,\n            _swapData.fromAmount\n        );\n\n        // execute swap using LiFiDEXAggregator\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = liFiDEXAggregator.call(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n        // extract the swap output amount from the call return value\n        uint256 swapOutputAmount = abi.decode(res, (uint256));\n\n        // deposit native tokens to Gas.zip protocol\n        depositToGasZipNative(_gasZipData, swapOutputAmount);\n    }\n\n    /// @notice Deposits native tokens to the GasZip router contract\n    /// @dev this function can be used as a LibSwap.SwapData protocol step to combine it with any other bridge\n    /// @param _gasZipData contains information which chains and address gas should be sent to\n    /// @param _amount the total amount to be deposited (will be split equally across all chains)\n    function depositToGasZipNative(\n        IGasZip.GasZipData calldata _gasZipData,\n        uint256 _amount\n    ) public payable {\n        // make sure that receiverAddress is not 0\n        if (_gasZipData.receiverAddress == bytes32(0))\n            revert InvalidCallData();\n\n        // We are depositing to a new contract that supports deposits for EVM chains + Solana (therefore 'receiver' address is bytes32)\n        gasZipRouter.deposit{ value: _amount }(\n            _gasZipData.destinationChains,\n            _gasZipData.receiverAddress\n        );\n\n        // return unused native value to msg.sender, if any\n        // this is required due to LI.FI backend-internal requirements (money flow)\n        uint256 remainingNativeBalance = address(this).balance;\n        if (remainingNativeBalance > 0) {\n            msg.sender.safeTransferETH(remainingNativeBalance);\n        }\n    }\n\n    /// @dev Returns a value that signals to Gas.zip to which chains gas should be sent in equal parts\n    /// @param _chainIds a list of Gas.zip-specific chainIds (not the original chainIds), see https://dev.gas.zip/gas/chain-support/outbound\n    function getDestinationChainsValue(\n        uint8[] calldata _chainIds\n    ) external pure returns (uint256 destinationChains) {\n        uint256 length = _chainIds.length;\n\n        if (length > MAX_CHAINID_LENGTH_ALLOWED) revert TooManyChainIds();\n\n        for (uint256 i; i < length; ++i) {\n            // Shift destinationChains left by 8 bits and add the next chainID\n            destinationChains =\n                (destinationChains << 8) |\n                uint256(_chainIds[i]);\n        }\n    }\n\n    // Required to receive ETH from ERC20-to-Native swaps\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "GasZipPeriphery": {
          "depositToGasZipERC20": [
            {
              "contract": "GasZipPeriphery",
              "function": "depositToGasZipNative"
            }
          ],
          "depositToGasZipNative": [],
          "getDestinationChainsValue": []
        }
      },
      "flow_data": {
        "GasZipPeriphery": {
          "depositToGasZipERC20": {
            "name": "depositToGasZipERC20",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "!success",
                "line": 16
              }
            ],
            "state_changes": [
              {
                "variable": "swapOutputAmount",
                "type": "uint256",
                "value": "abi.decode(res, (uint256))",
                "line": 20
              }
            ],
            "external_calls": [
              {
                "target": "liFiDEXAggregator",
                "type": "call",
                "arguments": "_swapData.callData",
                "line": 13
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "16": "if (!success)",
              "20": "State Change: swapOutputAmount = abi.decode(res, (uint256))",
              "13": "External Call: liFiDEXAggregator.call(_swapData.callData)"
            },
            "parameters": [
              {
                "type": "LibSwap.SwapData",
                "name": "_swapData"
              },
              {
                "type": "IGasZip.GasZipData",
                "name": "_gasZipData"
              }
            ],
            "returns": []
          },
          "depositToGasZipNative": {
            "name": "depositToGasZipNative",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "_gasZipData.receiverAddress == bytes32(0",
                "line": 2
              },
              {
                "type": "if",
                "condition": "remainingNativeBalance > 0",
                "line": 14
              }
            ],
            "state_changes": [
              {
                "variable": "remainingNativeBalance",
                "type": "uint256",
                "value": "address(this).balance",
                "line": 13
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "if (_gasZipData.receiverAddress == bytes32(0)",
              "14": "if (remainingNativeBalance > 0)",
              "13": "State Change: remainingNativeBalance = address(this).balance"
            },
            "parameters": [
              {
                "type": "IGasZip.GasZipData",
                "name": "_gasZipData"
              },
              {
                "type": "uint256",
                "name": "_amount"
              }
            ],
            "returns": []
          },
          "getDestinationChainsValue": {
            "name": "getDestinationChainsValue",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "length > MAX_CHAINID_LENGTH_ALLOWED",
                "line": 3
              },
              {
                "type": "for",
                "condition": "uint256 i; i < length; ++i",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "length",
                "type": "uint256",
                "value": "_chainIds.length",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (length > MAX_CHAINID_LENGTH_ALLOWED)",
              "5": "for (uint256 i; i < length; ++i)",
              "1": "State Change: length = _chainIds.length"
            },
            "parameters": [
              {
                "type": "uint8[]",
                "name": "_chainIds"
              }
            ],
            "returns": [
              {
                "type": "uint256 destinationChains"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "GasZipPeriphery": {
          "depositToGasZipERC20": {
            "calls": [
              {
                "contract": "GasZipPeriphery",
                "function": "depositToGasZipNative",
                "state_changes": [
                  {
                    "variable": "remainingNativeBalance",
                    "type": "uint256",
                    "value": "address(this).balance",
                    "line": 13
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "depositToGasZipNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getDestinationChainsValue": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.295495"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.299664"
      },
      "final_report": {
        "file_id": "GasZipPeriphery.sol",
        "timestamp": "2025-03-11T07:05:51.299688",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "GasZipPeriphery": {
            "functions": 3,
            "state_variables": 3,
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of GasZipPeriphery.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.299702"
    },
    "LiFiDEXAggregator.sol": {
      "file_id": "LiFiDEXAggregator.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "LiFiDEXAggregator": {
            "name": "LiFiDEXAggregator",
            "inheritance": [
              "WithdrawablePeriphery"
            ],
            "functions": {
              "processRouteInternal": {
                "name": "processRouteInternal",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  },
                  {
                    "type": "address",
                    "name": "tokenOut"
                  },
                  {
                    "type": "uint256",
                    "name": "amountOutMin"
                  },
                  {
                    "type": "address",
                    "name": "to"
                  },
                  {
                    "type": "bytes",
                    "name": "route"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 amountOut"
                  }
                ],
                "modifiers": [],
                "code": "uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n\n        uint256 realAmountIn = amountIn;\n        {\n            uint256 step = 0;\n            uint256 stream = InputStream.createStream(route);\n            while (stream.isNotEmpty()) {\n                uint8 commandCode = stream.readUint8();\n                if (commandCode == 1) {\n                    uint256 usedAmount = processMyERC20(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 2)\n                    processUserERC20(stream, amountIn);\n                else if (commandCode == 3) {\n                    uint256 usedAmount = processNative(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 4) processOnePool(stream);\n                else if (commandCode == 5) processInsideBento(stream);\n                else if (commandCode == 6) applyPermit(tokenIn, stream);\n                else revert(\"RouteProcessor: Unknown command code\");\n                ++step;\n            }\n        }\n\n        uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        require(\n            balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\"\n        );\n\n        uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n        if (balanceOutFinal < balanceOutInitial + amountOutMin)\n            revert MinimalOutputBalanceViolation(\n                balanceOutFinal - balanceOutInitial\n            );\n\n        amountOut = balanceOutFinal - balanceOutInitial;\n\n        emit Route(\n            msg.sender,\n            to,\n            tokenIn,\n            tokenOut,\n            realAmountIn,\n            amountOutMin,\n            amountOut\n        );\n    }"
              },
              "applyPermit": {
                "name": "applyPermit",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "stream"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 value = stream.readUint();\n        uint256 deadline = stream.readUint();\n        uint8 v = stream.readUint8();\n        bytes32 r = stream.readBytes32();\n        bytes32 s = stream.readBytes32();\n        IERC20Permit(tokenIn).safePermit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }"
              },
              "processNative": {
                "name": "processNative",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 amountTotal"
                  }
                ],
                "modifiers": [],
                "code": "amountTotal = address(this).balance;\n        distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n    }"
              },
              "processMyERC20": {
                "name": "processMyERC20",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 amountTotal"
                  }
                ],
                "modifiers": [],
                "code": "address token = stream.readAddress();\n        amountTotal = IERC20(token).balanceOf(address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }"
              },
              "processUserERC20": {
                "name": "processUserERC20",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "uint256",
                    "name": "amountTotal"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address token = stream.readAddress();\n        distributeAndSwap(stream, msg.sender, token, amountTotal);\n    }"
              },
              "processOnePool": {
                "name": "processOnePool",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address token = stream.readAddress();\n        swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n    }"
              },
              "processInsideBento": {
                "name": "processInsideBento",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address token = stream.readAddress();\n        uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }"
              },
              "distributeAndSwap": {
                "name": "distributeAndSwap",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountTotal"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint8 num = stream.readUint8();\n        unchecked {\n            for (uint256 i = 0; i < num; ++i) {\n                uint16 share = stream.readUint16();\n                uint256 amount = (amountTotal * share) /\n                    type(uint16).max /*65535*/;\n                amountTotal -= amount;\n                swap(stream, from, tokenIn, amount);\n            }\n        }\n    }"
              },
              "swap": {
                "name": "swap",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint8 poolType = stream.readUint8();\n        if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n        else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n        else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n        else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n        else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n        else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n        else revert(\"RouteProcessor: Unknown pool type\");\n    }"
              },
              "wrapNative": {
                "name": "wrapNative",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint8 directionAndFake = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (directionAndFake & 1 == 1) {\n            // wrap native\n            address wrapToken = stream.readAddress();\n            if (directionAndFake & 2 == 0)\n                IWETH(wrapToken).deposit{ value: amountIn }();\n            if (to != address(this))\n                IERC20(wrapToken).safeTransfer(to, amountIn);\n        } else {\n            // unwrap native\n            if (directionAndFake & 2 == 0) {\n                if (from == msg.sender)\n                    IERC20(tokenIn).safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        amountIn\n                    );\n                IWETH(tokenIn).withdraw(amountIn);\n            }\n            SafeTransferLib.safeTransferETH(to, amountIn);\n        }\n    }"
              },
              "bentoBridge": {
                "name": "bentoBridge",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (direction > 0) {\n            // outside to Bento\n            // deposit to arbitrary recipient is possible only from address(bentoBox)\n            if (from == address(this))\n                IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n            else if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(bentoBox),\n                    amountIn\n                );\n            else {\n                // tokens already are at address(bentoBox)\n                amountIn =\n                    IERC20(tokenIn).balanceOf(address(bentoBox)) +\n                    bentoBox.strategyData(tokenIn).balance -\n                    bentoBox.totals(tokenIn).elastic;\n            }\n            bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n        } else {\n            // Bento to outside\n            if (from != INTERNAL_INPUT_SOURCE) {\n                bentoBox.transfer(tokenIn, from, address(this), amountIn);\n            } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n            bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n        }\n    }"
              },
              "swapUniV2": {
                "name": "swapUniV2",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address pool = stream.readAddress();\n        uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n        uint24 fee = stream.readUint24(); // pool fee in 1/1_000_000\n\n        if (from == address(this))\n            IERC20(tokenIn).safeTransfer(pool, amountIn);\n        else if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n        (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n        require(r0 > 0 && r1 > 0, \"Wrong pool reserves\");\n        (uint256 reserveIn, uint256 reserveOut) = direction == 1\n            ? (r0, r1)\n            : (r1, r0);\n        amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn; // tokens already were transferred\n\n        uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n        uint256 amountOut = (amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee);\n        (uint256 amount0Out, uint256 amount1Out) = direction == 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0));\n        IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n    }"
              },
              "swapTrident": {
                "name": "swapTrident",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address pool = stream.readAddress();\n        bytes memory swapData = stream.readBytes();\n\n        if (from != INTERNAL_INPUT_SOURCE) {\n            bentoBox.transfer(tokenIn, from, pool, amountIn);\n        }\n\n        IPool(pool).swap(swapData);\n    }"
              },
              "swapUniV3": {
                "name": "swapUniV3",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address pool = stream.readAddress();\n        bool zeroForOne = stream.readUint8() > 0;\n        address recipient = stream.readAddress();\n\n        if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(\n                msg.sender,\n                address(this),\n                uint256(amountIn)\n            );\n\n        lastCalledPool = pool;\n        IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            int256(amountIn),\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n            abi.encode(tokenIn)\n        );\n        require(\n            lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        ); // Just to be sure\n    }"
              },
              "uniswapV3SwapCallback": {
                "name": "uniswapV3SwapCallback",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "require(\n            msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\"\n        );\n        int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n        require(\n            amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\"\n        );\n\n        lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n        address tokenIn = abi.decode(data, (address));\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n    }"
              },
              "algebraSwapCallback": {
                "name": "algebraSwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "pancakeV3SwapCallback": {
                "name": "pancakeV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "ramsesV2SwapCallback": {
                "name": "ramsesV2SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "xeiV3SwapCallback": {
                "name": "xeiV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "dragonswapV2SwapCallback": {
                "name": "dragonswapV2SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "agniSwapCallback": {
                "name": "agniSwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "fusionXV3SwapCallback": {
                "name": "fusionXV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "vvsV3SwapCallback": {
                "name": "vvsV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "supV3SwapCallback": {
                "name": "supV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "zebraV3SwapCallback": {
                "name": "zebraV3SwapCallback",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "int256",
                    "name": "amount0Delta"
                  },
                  {
                    "type": "int256",
                    "name": "amount1Delta"
                  },
                  {
                    "type": "bytes",
                    "name": "data"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }"
              },
              "swapCurve": {
                "name": "swapCurve",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "stream"
                  },
                  {
                    "type": "address",
                    "name": "from"
                  },
                  {
                    "type": "address",
                    "name": "tokenIn"
                  },
                  {
                    "type": "uint256",
                    "name": "amountIn"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "address pool = stream.readAddress();\n        uint8 poolType = stream.readUint8();\n        int128 fromIndex = int8(stream.readUint8());\n        int128 toIndex = int8(stream.readUint8());\n        address to = stream.readAddress();\n        address tokenOut = stream.readAddress();\n\n        uint256 amountOut;\n        if (tokenIn == NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            );\n        } else {\n            if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amountIn\n                );\n            IERC20(tokenIn).approveSafe(pool, amountIn);\n            if (poolType == 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                );\n            else {\n                uint256 balanceBefore = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n                uint256 balanceAfter = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                amountOut = balanceAfter - balanceBefore;\n            }\n        }\n\n        if (to != address(this)) {\n            if (tokenOut == NATIVE_ADDRESS) {\n                SafeTransferLib.safeTransferETH(to, amountOut);\n            } else {\n                IERC20(tokenOut).safeTransfer(to, amountOut);\n            }\n        }\n    }"
              }
            },
            "state_variables": {
              "lastCalledPool": {
                "name": "lastCalledPool",
                "type": "address",
                "visibility": "private",
                "initial_value": null
              },
              "unlocked": {
                "name": "unlocked",
                "type": "uint8",
                "visibility": "private",
                "initial_value": "NOT_LOCKED"
              },
              "paused": {
                "name": "paused",
                "type": "uint8",
                "visibility": "private",
                "initial_value": "NOT_PAUSED"
              },
              "balanceInInitial": {
                "name": "balanceInInitial",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)"
              },
              "balanceOutInitial": {
                "name": "balanceOutInitial",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)"
              },
              "realAmountIn": {
                "name": "realAmountIn",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "amountIn"
              },
              "step": {
                "name": "step",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "0"
              },
              "stream": {
                "name": "stream",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "InputStream.createStream(route)"
              },
              "commandCode": {
                "name": "commandCode",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "usedAmount": {
                "name": "usedAmount",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "processNative(stream)"
              },
              "balanceInFinal": {
                "name": "balanceInFinal",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)"
              },
              "balanceOutFinal": {
                "name": "balanceOutFinal",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)"
              },
              "value": {
                "name": "value",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "stream.readUint()"
              },
              "deadline": {
                "name": "deadline",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "stream.readUint()"
              },
              "v": {
                "name": "v",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "r": {
                "name": "r",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "stream.readBytes32()"
              },
              "s": {
                "name": "s",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "stream.readBytes32()"
              },
              "token": {
                "name": "token",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "amountTotal": {
                "name": "amountTotal",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "bentoBox.balanceOf(token, address(this))"
              },
              "num": {
                "name": "num",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "share": {
                "name": "share",
                "type": "uint16",
                "visibility": "internal",
                "initial_value": "stream.readUint16()"
              },
              "amount": {
                "name": "amount",
                "type": "int256",
                "visibility": "internal",
                "initial_value": "amount0Delta > 0 ? amount0Delta : amount1Delta"
              },
              "poolType": {
                "name": "poolType",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "directionAndFake": {
                "name": "directionAndFake",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "to": {
                "name": "to",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "wrapToken": {
                "name": "wrapToken",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "direction": {
                "name": "direction",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "stream.readUint8()"
              },
              "pool": {
                "name": "pool",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "fee": {
                "name": "fee",
                "type": "uint24",
                "visibility": "internal",
                "initial_value": "stream.readUint24()"
              },
              "amountInWithFee": {
                "name": "amountInWithFee",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "amountIn * (1_000_000 - fee)"
              },
              "amountOut": {
                "name": "amountOut",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "zeroForOne": {
                "name": "zeroForOne",
                "type": "bool",
                "visibility": "internal",
                "initial_value": "stream.readUint8() > 0"
              },
              "recipient": {
                "name": "recipient",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "tokenIn": {
                "name": "tokenIn",
                "type": "address",
                "visibility": "internal",
                "initial_value": "abi.decode(data, (address))"
              },
              "fromIndex": {
                "name": "fromIndex",
                "type": "int128",
                "visibility": "internal",
                "initial_value": "int8(stream.readUint8())"
              },
              "toIndex": {
                "name": "toIndex",
                "type": "int128",
                "visibility": "internal",
                "initial_value": "int8(stream.readUint8())"
              },
              "tokenOut": {
                "name": "tokenOut",
                "type": "address",
                "visibility": "internal",
                "initial_value": "stream.readAddress()"
              },
              "balanceBefore": {
                "name": "balanceBefore",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )"
              },
              "balanceAfter": {
                "name": "balanceAfter",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.17;\n\nimport { SafeERC20, IERC20, IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\naddress constant NATIVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress constant IMPOSSIBLE_POOL_ADDRESS = 0x0000000000000000000000000000000000000001;\naddress constant INTERNAL_INPUT_SOURCE = 0x0000000000000000000000000000000000000000;\n\nuint8 constant LOCKED = 2;\nuint8 constant NOT_LOCKED = 1;\nuint8 constant PAUSED = 2;\nuint8 constant NOT_PAUSED = 1;\n\n/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\nuint160 constant MIN_SQRT_RATIO = 4295128739;\n/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n/// @title LiFi DEX Aggregator\n/// @author Ilya Lyalin (contract copied from: https://github.com/sushiswap/sushiswap/blob/c8c80dec821003eb72eb77c7e0446ddde8ca9e1e/protocols/route-processor/contracts/RouteProcessor4.sol)\n/// @notice Processes calldata to swap using various DEXs\n/// @custom:version 1.6.0\ncontract LiFiDEXAggregator is WithdrawablePeriphery {\n    using SafeERC20 for IERC20;\n    using Approve for IERC20;\n    using SafeERC20 for IERC20Permit;\n    using InputStream for uint256;\n\n    event Route(\n        address indexed from,\n        address to,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256 amountOut\n    );\n\n    error MinimalOutputBalanceViolation(uint256 amountOut);\n\n    IBentoBoxMinimal public immutable bentoBox;\n    mapping(address => bool) public priviledgedUsers;\n    address private lastCalledPool;\n\n    uint8 private unlocked = NOT_LOCKED;\n    uint8 private paused = NOT_PAUSED;\n    modifier lock() {\n        require(unlocked == NOT_LOCKED, \"RouteProcessor is locked\");\n        require(paused == NOT_PAUSED, \"RouteProcessor is paused\");\n        unlocked = LOCKED;\n        _;\n        unlocked = NOT_LOCKED;\n    }\n\n    modifier onlyOwnerOrPriviledgedUser() {\n        require(\n            msg.sender == owner || priviledgedUsers[msg.sender],\n            \"RP: caller is not the owner or a privileged user\"\n        );\n        _;\n    }\n\n    constructor(\n        address _bentoBox,\n        address[] memory priviledgedUserList,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        bentoBox = IBentoBoxMinimal(_bentoBox);\n        lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n        for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n            priviledgedUsers[priviledgedUserList[i]] = true;\n        }\n    }\n\n    function setPriviledge(address user, bool priviledge) external onlyOwner {\n        priviledgedUsers[user] = priviledge;\n    }\n\n    function pause() external onlyOwnerOrPriviledgedUser {\n        paused = PAUSED;\n    }\n\n    function resume() external onlyOwnerOrPriviledgedUser {\n        paused = NOT_PAUSED;\n    }\n\n    /// @notice For native unwrapping\n    receive() external payable {}\n\n    /// @notice Processes the route generated off-chain. Has a lock\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function processRoute(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) external payable lock returns (uint256 amountOut) {\n        return\n            processRouteInternal(\n                tokenIn,\n                amountIn,\n                tokenOut,\n                amountOutMin,\n                to,\n                route\n            );\n    }\n\n    /// @notice Transfers some value to <transferValueTo> and then processes the route\n    /// @param transferValueTo Address where the value should be transferred\n    /// @param amountValueTransfer How much value to transfer\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function transferValueAndprocessRoute(\n        address payable transferValueTo,\n        uint256 amountValueTransfer,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) external payable lock returns (uint256 amountOut) {\n        SafeTransferLib.safeTransferETH(transferValueTo, amountValueTransfer);\n        return\n            processRouteInternal(\n                tokenIn,\n                amountIn,\n                tokenOut,\n                amountOutMin,\n                to,\n                route\n            );\n    }\n\n    /// @notice Processes the route generated off-chain\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function processRouteInternal(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) private returns (uint256 amountOut) {\n        uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n\n        uint256 realAmountIn = amountIn;\n        {\n            uint256 step = 0;\n            uint256 stream = InputStream.createStream(route);\n            while (stream.isNotEmpty()) {\n                uint8 commandCode = stream.readUint8();\n                if (commandCode == 1) {\n                    uint256 usedAmount = processMyERC20(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 2)\n                    processUserERC20(stream, amountIn);\n                else if (commandCode == 3) {\n                    uint256 usedAmount = processNative(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 4) processOnePool(stream);\n                else if (commandCode == 5) processInsideBento(stream);\n                else if (commandCode == 6) applyPermit(tokenIn, stream);\n                else revert(\"RouteProcessor: Unknown command code\");\n                ++step;\n            }\n        }\n\n        uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        require(\n            balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\"\n        );\n\n        uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n        if (balanceOutFinal < balanceOutInitial + amountOutMin)\n            revert MinimalOutputBalanceViolation(\n                balanceOutFinal - balanceOutInitial\n            );\n\n        amountOut = balanceOutFinal - balanceOutInitial;\n\n        emit Route(\n            msg.sender,\n            to,\n            tokenIn,\n            tokenOut,\n            realAmountIn,\n            amountOutMin,\n            amountOut\n        );\n    }\n\n    /// @notice Applies ERC-2612 permit\n    /// @param tokenIn permitted token\n    /// @param stream Streamed program\n    function applyPermit(address tokenIn, uint256 stream) private {\n        uint256 value = stream.readUint();\n        uint256 deadline = stream.readUint();\n        uint8 v = stream.readUint8();\n        bytes32 r = stream.readBytes32();\n        bytes32 s = stream.readBytes32();\n        IERC20Permit(tokenIn).safePermit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n\n    /// @notice Processes native coin: call swap for all pools that swap from native coin\n    /// @param stream Streamed program\n    function processNative(\n        uint256 stream\n    ) private returns (uint256 amountTotal) {\n        amountTotal = address(this).balance;\n        distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token from this contract balance:\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processMyERC20(\n        uint256 stream\n    ) private returns (uint256 amountTotal) {\n        address token = stream.readAddress();\n        amountTotal = IERC20(token).balanceOf(address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token from msg.sender balance:\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    /// @param amountTotal Amount of tokens to take from msg.sender\n    function processUserERC20(uint256 stream, uint256 amountTotal) private {\n        address token = stream.readAddress();\n        distributeAndSwap(stream, msg.sender, token, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token for cases when the token has only one output pool\n    /// @notice In this case liquidity is already at pool balance. This is an optimization\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processOnePool(uint256 stream) private {\n        address token = stream.readAddress();\n        swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n    }\n\n    /// @notice Processes Bento tokens\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processInsideBento(uint256 stream) private {\n        address token = stream.readAddress();\n        uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }\n\n    /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n    /// @param stream Streamed program\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountTotal Total amount of tokenIn for swaps\n    function distributeAndSwap(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountTotal\n    ) private {\n        uint8 num = stream.readUint8();\n        unchecked {\n            for (uint256 i = 0; i < num; ++i) {\n                uint16 share = stream.readUint16();\n                uint256 amount = (amountTotal * share) /\n                    type(uint16).max /*65535*/;\n                amountTotal -= amount;\n                swap(stream, from, tokenIn, amount);\n            }\n        }\n    }\n\n    /// @notice Makes swap\n    /// @param stream Streamed program\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swap(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 poolType = stream.readUint8();\n        if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n        else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n        else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n        else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n        else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n        else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n        else revert(\"RouteProcessor: Unknown pool type\");\n    }\n\n    /// @notice Wraps/unwraps native token\n    /// @param stream [direction & fake, recipient, wrapToken?]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function wrapNative(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 directionAndFake = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (directionAndFake & 1 == 1) {\n            // wrap native\n            address wrapToken = stream.readAddress();\n            if (directionAndFake & 2 == 0)\n                IWETH(wrapToken).deposit{ value: amountIn }();\n            if (to != address(this))\n                IERC20(wrapToken).safeTransfer(to, amountIn);\n        } else {\n            // unwrap native\n            if (directionAndFake & 2 == 0) {\n                if (from == msg.sender)\n                    IERC20(tokenIn).safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        amountIn\n                    );\n                IWETH(tokenIn).withdraw(amountIn);\n            }\n            SafeTransferLib.safeTransferETH(to, amountIn);\n        }\n    }\n\n    /// @notice Bridge/unbridge tokens to/from Bento\n    /// @param stream [direction, recipient]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function bentoBridge(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (direction > 0) {\n            // outside to Bento\n            // deposit to arbitrary recipient is possible only from address(bentoBox)\n            if (from == address(this))\n                IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n            else if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(bentoBox),\n                    amountIn\n                );\n            else {\n                // tokens already are at address(bentoBox)\n                amountIn =\n                    IERC20(tokenIn).balanceOf(address(bentoBox)) +\n                    bentoBox.strategyData(tokenIn).balance -\n                    bentoBox.totals(tokenIn).elastic;\n            }\n            bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n        } else {\n            // Bento to outside\n            if (from != INTERNAL_INPUT_SOURCE) {\n                bentoBox.transfer(tokenIn, from, address(this), amountIn);\n            } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n            bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n        }\n    }\n\n    /// @notice UniswapV2 pool swap\n    /// @param stream [pool, direction, recipient, fee]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapUniV2(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n        uint24 fee = stream.readUint24(); // pool fee in 1/1_000_000\n\n        if (from == address(this))\n            IERC20(tokenIn).safeTransfer(pool, amountIn);\n        else if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n        (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n        require(r0 > 0 && r1 > 0, \"Wrong pool reserves\");\n        (uint256 reserveIn, uint256 reserveOut) = direction == 1\n            ? (r0, r1)\n            : (r1, r0);\n        amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn; // tokens already were transferred\n\n        uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n        uint256 amountOut = (amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee);\n        (uint256 amount0Out, uint256 amount1Out) = direction == 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0));\n        IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n\n    /// @notice Trident pool swap\n    /// @param stream [pool, swapData]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapTrident(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        bytes memory swapData = stream.readBytes();\n\n        if (from != INTERNAL_INPUT_SOURCE) {\n            bentoBox.transfer(tokenIn, from, pool, amountIn);\n        }\n\n        IPool(pool).swap(swapData);\n    }\n\n    /// @notice UniswapV3 pool swap\n    /// @param stream [pool, direction, recipient]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapUniV3(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        bool zeroForOne = stream.readUint8() > 0;\n        address recipient = stream.readAddress();\n\n        if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(\n                msg.sender,\n                address(this),\n                uint256(amountIn)\n            );\n\n        lastCalledPool = pool;\n        IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            int256(amountIn),\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n            abi.encode(tokenIn)\n        );\n        require(\n            lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        ); // Just to be sure\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) public {\n        require(\n            msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\"\n        );\n        int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n        require(\n            amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\"\n        );\n\n        lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n        address tokenIn = abi.decode(data, (address));\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n    function algebraSwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n    function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via RaExchangeV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the RaExchangeV3#swap call\n    function ramsesV2SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via XeiV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the XeiV3#swap call\n    function xeiV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via DragonSwapV2#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the DragonSwapV2#swap call\n    function dragonswapV2SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via AgniV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the AgniV3#swap call\n    function agniSwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via FusionXV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the FusionXV3#swap call\n    function fusionXV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via VVS FinanceV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the VVS Finance V3#swap call\n    function vvsV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via SupSwapV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the SupSwapV3#swap call\n    function supV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via ZebraV3#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the ZebraV3#swap call\n    function zebraV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Curve pool swap. Legacy pools that don't return amountOut and have native coins are not supported\n    /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapCurve(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        uint8 poolType = stream.readUint8();\n        int128 fromIndex = int8(stream.readUint8());\n        int128 toIndex = int8(stream.readUint8());\n        address to = stream.readAddress();\n        address tokenOut = stream.readAddress();\n\n        uint256 amountOut;\n        if (tokenIn == NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            );\n        } else {\n            if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amountIn\n                );\n            IERC20(tokenIn).approveSafe(pool, amountIn);\n            if (poolType == 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                );\n            else {\n                uint256 balanceBefore = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n                uint256 balanceAfter = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                amountOut = balanceAfter - balanceBefore;\n            }\n        }\n\n        if (to != address(this)) {\n            if (tokenOut == NATIVE_ADDRESS) {\n                SafeTransferLib.safeTransferETH(to, amountOut);\n            } else {\n                IERC20(tokenOut).safeTransfer(to, amountOut);\n            }\n        }\n    }\n}\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(\n        address token\n    ) external view returns (StrategyData memory total);\n\n    /// @dev Approves users' BentoBox assets to a \"master\" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}\n\ninterface ICurve {\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256);\n}\n\ninterface ICurveLegacy {\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable;\n}\n\n/// @notice Trident pool interface.\ninterface IPool {\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(\n        bytes calldata data\n    ) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(\n        bytes calldata data\n    ) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(\n        bytes calldata data\n    ) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(\n        bytes calldata data\n    ) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(\n        bytes calldata data\n    ) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(\n        address indexed recipient,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}\n\ninterface ITridentCLPool {\n    function token0() external returns (address);\n\n    function token1() external returns (address);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bool unwrapBento,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV3Pool {\n    function token0() external returns (address);\n\n    function token1() external returns (address);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\n/** @notice Simple read stream */\nlibrary InputStream {\n    /** @notice Creates stream from data\n     * @param data data\n     */\n    function createStream(\n        bytes memory data\n    ) internal pure returns (uint256 stream) {\n        assembly {\n            stream := mload(0x40)\n            mstore(0x40, add(stream, 64))\n            mstore(stream, data)\n            let length := mload(data)\n            mstore(add(stream, 32), add(data, length))\n        }\n    }\n\n    /** @notice Checks if stream is not empty\n     * @param stream stream\n     */\n    function isNotEmpty(uint256 stream) internal pure returns (bool) {\n        uint256 pos;\n        uint256 finish;\n        assembly {\n            pos := mload(stream)\n            finish := mload(add(stream, 32))\n        }\n        return pos < finish;\n    }\n\n    /** @notice Reads uint8 from the stream\n     * @param stream stream\n     */\n    function readUint8(uint256 stream) internal pure returns (uint8 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 1)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint16 from the stream\n     * @param stream stream\n     */\n    function readUint16(uint256 stream) internal pure returns (uint16 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 2)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint24 from the stream\n     * @param stream stream\n     */\n    function readUint24(uint256 stream) internal pure returns (uint24 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 3)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint32 from the stream\n     * @param stream stream\n     */\n    function readUint32(uint256 stream) internal pure returns (uint32 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 4)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint256 from the stream\n     * @param stream stream\n     */\n    function readUint(uint256 stream) internal pure returns (uint256 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 32)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads bytes32 from the stream\n     * @param stream stream\n     */\n    function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 32)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads address from the stream\n     * @param stream stream\n     */\n    function readAddress(uint256 stream) internal pure returns (address res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 20)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads bytes from the stream\n     * @param stream stream\n     */\n    function readBytes(\n        uint256 stream\n    ) internal pure returns (bytes memory res) {\n        assembly {\n            let pos := mload(stream)\n            res := add(pos, 32)\n            let length := mload(res)\n            mstore(stream, add(res, length))\n        }\n    }\n}\n\nlibrary Approve {\n    /**\n     * @dev ERC20 approve that correct works with token.approve which returns bool or nothing (USDT for example)\n     * @param token The token targeted by the call.\n     * @param spender token spender\n     * @param amount token amount\n     */\n    function approveStable(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(token.approve.selector, spender, amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    /**\n     * @dev ERC20 approve that correct works with token.approve which reverts if amount and\n     *      current allowance are not zero simultaniously (USDT for example).\n     *      In second case it tries to set allowance to 0, and then back to amount.\n     * @param token The token targeted by the call.\n     * @param spender token spender\n     * @param amount token amount\n     */\n    function approveSafe(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            approveStable(token, spender, amount) ||\n            (approveStable(token, spender, 0) &&\n                approveStable(token, spender, amount));\n    }\n}\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\nstruct StrategyData {\n    uint64 strategyStartDate;\n    uint64 targetPercentage;\n    uint128 balance; // the balance of the strategy that BentoBox thinks is in there\n}\n\n/// @notice A rebasing library\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}\n"
      },
      "call_graph": {
        "LiFiDEXAggregator": {
          "processRouteInternal": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "applyPermit"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "processNative"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "processMyERC20"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "processUserERC20"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "processOnePool"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "processInsideBento"
            }
          ],
          "applyPermit": [],
          "processNative": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "distributeAndSwap"
            }
          ],
          "processMyERC20": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "distributeAndSwap"
            }
          ],
          "processUserERC20": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "distributeAndSwap"
            }
          ],
          "processOnePool": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "swap"
            }
          ],
          "processInsideBento": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "distributeAndSwap"
            }
          ],
          "distributeAndSwap": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "swap"
            }
          ],
          "swap": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "wrapNative"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "bentoBridge"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "swapUniV2"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "swapTrident"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "swapUniV3"
            },
            {
              "contract": "LiFiDEXAggregator",
              "function": "swapCurve"
            }
          ],
          "wrapNative": [],
          "bentoBridge": [],
          "swapUniV2": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "swap"
            }
          ],
          "swapTrident": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "swap"
            }
          ],
          "swapUniV3": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "swap"
            }
          ],
          "uniswapV3SwapCallback": [],
          "algebraSwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "pancakeV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "ramsesV2SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "xeiV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "dragonswapV2SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "agniSwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "fusionXV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "vvsV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "supV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "zebraV3SwapCallback": [
            {
              "contract": "LiFiDEXAggregator",
              "function": "uniswapV3SwapCallback"
            }
          ],
          "swapCurve": []
        }
      },
      "flow_data": {
        "LiFiDEXAggregator": {
          "processRouteInternal": {
            "name": "processRouteInternal",
            "visibility": "private",
            "control_structures": [
              {
                "type": "while",
                "condition": "stream.isNotEmpty(",
                "line": 12
              },
              {
                "type": "if",
                "condition": "commandCode == 1",
                "line": 14
              },
              {
                "type": "if",
                "condition": "step == 0",
                "line": 16
              },
              {
                "type": "if",
                "condition": "commandCode == 2",
                "line": 17
              },
              {
                "type": "if",
                "condition": "commandCode == 3",
                "line": 19
              },
              {
                "type": "if",
                "condition": "step == 0",
                "line": 21
              },
              {
                "type": "if",
                "condition": "commandCode == 4",
                "line": 22
              },
              {
                "type": "if",
                "condition": "commandCode == 5",
                "line": 23
              },
              {
                "type": "if",
                "condition": "commandCode == 6",
                "line": 24
              },
              {
                "type": "if",
                "condition": "balanceOutFinal < balanceOutInitial + amountOutMin",
                "line": 41
              }
            ],
            "state_changes": [
              {
                "variable": "balanceInInitial",
                "type": "uint256",
                "value": "tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
                "line": 1
              },
              {
                "variable": "balanceOutInitial",
                "type": "uint256",
                "value": "tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
                "line": 4
              },
              {
                "variable": "realAmountIn",
                "type": "uint256",
                "value": "amountIn",
                "line": 8
              },
              {
                "variable": "realAmountIn",
                "type": "uint256",
                "value": "usedAmount",
                "line": 16
              },
              {
                "variable": "realAmountIn",
                "type": "uint256",
                "value": "usedAmount",
                "line": 21
              },
              {
                "variable": "step",
                "type": "uint256",
                "value": "0",
                "line": 10
              },
              {
                "variable": "step",
                "type": "uint256",
                "value": "= 0) realAmountIn = usedAmount",
                "line": 16
              },
              {
                "variable": "step",
                "type": "uint256",
                "value": "= 0) realAmountIn = usedAmount",
                "line": 21
              },
              {
                "variable": "stream",
                "type": "uint256",
                "value": "InputStream.createStream(route)",
                "line": 11
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 13
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 1) {\n                    uint256 usedAmount = processMyERC20(stream)",
                "line": 14
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 2)\n                    processUserERC20(stream, amountIn)",
                "line": 17
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 3) {\n                    uint256 usedAmount = processNative(stream)",
                "line": 19
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 4) processOnePool(stream)",
                "line": 22
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 5) processInsideBento(stream)",
                "line": 23
              },
              {
                "variable": "commandCode",
                "type": "uint8",
                "value": "= 6) applyPermit(tokenIn, stream)",
                "line": 24
              },
              {
                "variable": "usedAmount",
                "type": "uint256",
                "value": "processMyERC20(stream)",
                "line": 15
              },
              {
                "variable": "usedAmount",
                "type": "uint256",
                "value": "processNative(stream)",
                "line": 20
              },
              {
                "variable": "balanceInFinal",
                "type": "uint256",
                "value": "tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
                "line": 30
              },
              {
                "variable": "balanceOutFinal",
                "type": "uint256",
                "value": "tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
                "line": 38
              },
              {
                "variable": "amountOut",
                "type": "uint256",
                "value": "balanceOutFinal - balanceOutInitial",
                "line": 46
              },
              {
                "variable": "tokenIn",
                "type": "address",
                "value": "= NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
                "line": 1
              },
              {
                "variable": "tokenIn",
                "type": "address",
                "value": "= NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
                "line": 30
              },
              {
                "variable": "tokenOut",
                "type": "address",
                "value": "= NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
                "line": 4
              },
              {
                "variable": "tokenOut",
                "type": "address",
                "value": "= NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
                "line": 38
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\"",
                "line": 33
              }
            ],
            "line_mapping": {
              "12": "while (stream.isNotEmpty()",
              "14": "State Change: commandCode = = 1) {\n                    uint256 usedAmount = processMyERC20(stream)",
              "16": "State Change: step = = 0) realAmountIn = usedAmount",
              "17": "State Change: commandCode = = 2)\n                    processUserERC20(stream, amountIn)",
              "19": "State Change: commandCode = = 3) {\n                    uint256 usedAmount = processNative(stream)",
              "21": "State Change: step = = 0) realAmountIn = usedAmount",
              "22": "State Change: commandCode = = 4) processOnePool(stream)",
              "23": "State Change: commandCode = = 5) processInsideBento(stream)",
              "24": "State Change: commandCode = = 6) applyPermit(tokenIn, stream)",
              "41": "if (balanceOutFinal < balanceOutInitial + amountOutMin)",
              "1": "State Change: tokenIn = = NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
              "4": "State Change: tokenOut = = NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
              "8": "State Change: realAmountIn = amountIn",
              "10": "State Change: step = 0",
              "11": "State Change: stream = InputStream.createStream(route)",
              "13": "State Change: commandCode = stream.readUint8()",
              "15": "State Change: usedAmount = processMyERC20(stream)",
              "20": "State Change: usedAmount = processNative(stream)",
              "30": "State Change: tokenIn = = NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender)",
              "38": "State Change: tokenOut = = NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to)",
              "46": "State Change: amountOut = balanceOutFinal - balanceOutInitial",
              "33": "require(balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\")"
            },
            "parameters": [
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              },
              {
                "type": "address",
                "name": "tokenOut"
              },
              {
                "type": "uint256",
                "name": "amountOutMin"
              },
              {
                "type": "address",
                "name": "to"
              },
              {
                "type": "bytes",
                "name": "route"
              }
            ],
            "returns": [
              {
                "type": "uint256 amountOut"
              }
            ]
          },
          "applyPermit": {
            "name": "applyPermit",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "value",
                "type": "uint256",
                "value": "stream.readUint()",
                "line": 1
              },
              {
                "variable": "deadline",
                "type": "uint256",
                "value": "stream.readUint()",
                "line": 2
              },
              {
                "variable": "v",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 3
              },
              {
                "variable": "r",
                "type": "bytes32",
                "value": "stream.readBytes32()",
                "line": 4
              },
              {
                "variable": "s",
                "type": "bytes32",
                "value": "stream.readBytes32()",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: value = stream.readUint()",
              "2": "State Change: deadline = stream.readUint()",
              "3": "State Change: v = stream.readUint8()",
              "4": "State Change: r = stream.readBytes32()",
              "5": "State Change: s = stream.readBytes32()"
            },
            "parameters": [
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "stream"
              }
            ],
            "returns": []
          },
          "processNative": {
            "name": "processNative",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "amountTotal",
                "type": "uint256",
                "value": "address(this).balance",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: amountTotal = address(this).balance"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              }
            ],
            "returns": [
              {
                "type": "uint256 amountTotal"
              }
            ]
          },
          "processMyERC20": {
            "name": "processMyERC20",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountTotal > 0",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "token",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              },
              {
                "variable": "amountTotal",
                "type": "uint256",
                "value": "IERC20(token).balanceOf(address(this))",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (amountTotal > 0)",
              "1": "State Change: token = stream.readAddress()",
              "2": "State Change: amountTotal = IERC20(token).balanceOf(address(this))"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              }
            ],
            "returns": [
              {
                "type": "uint256 amountTotal"
              }
            ]
          },
          "processUserERC20": {
            "name": "processUserERC20",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "token",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: token = stream.readAddress()"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "uint256",
                "name": "amountTotal"
              }
            ],
            "returns": []
          },
          "processOnePool": {
            "name": "processOnePool",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "token",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: token = stream.readAddress()"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              }
            ],
            "returns": []
          },
          "processInsideBento": {
            "name": "processInsideBento",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountTotal > 0",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "token",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              },
              {
                "variable": "amountTotal",
                "type": "uint256",
                "value": "bentoBox.balanceOf(token, address(this))",
                "line": 2
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (amountTotal > 0)",
              "1": "State Change: token = stream.readAddress()",
              "2": "State Change: amountTotal = bentoBox.balanceOf(token, address(this))"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              }
            ],
            "returns": []
          },
          "distributeAndSwap": {
            "name": "distributeAndSwap",
            "visibility": "private",
            "control_structures": [
              {
                "type": "for",
                "condition": "uint256 i = 0; i < num; ++i",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "num",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 1
              },
              {
                "variable": "share",
                "type": "uint16",
                "value": "stream.readUint16()",
                "line": 4
              },
              {
                "variable": "amount",
                "type": "int256",
                "value": "(amountTotal * share) /\n                    type(uint16).max /*65535*/",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "for (uint256 i = 0; i < num; ++i)",
              "1": "State Change: num = stream.readUint8()",
              "4": "State Change: share = stream.readUint16()",
              "5": "State Change: amount = (amountTotal * share) /\n                    type(uint16).max /*65535*/"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountTotal"
              }
            ],
            "returns": []
          },
          "swap": {
            "name": "swap",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "poolType == 0",
                "line": 2
              },
              {
                "type": "if",
                "condition": "poolType == 1",
                "line": 3
              },
              {
                "type": "if",
                "condition": "poolType == 2",
                "line": 4
              },
              {
                "type": "if",
                "condition": "poolType == 3",
                "line": 5
              },
              {
                "type": "if",
                "condition": "poolType == 4",
                "line": 6
              },
              {
                "type": "if",
                "condition": "poolType == 5",
                "line": 7
              }
            ],
            "state_changes": [
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 1
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                "line": 2
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                "line": 3
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                "line": 4
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                "line": 5
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                "line": 6
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "2": "State Change: poolType = = 0) swapUniV2(stream, from, tokenIn, amountIn)",
              "3": "State Change: poolType = = 1) swapUniV3(stream, from, tokenIn, amountIn)",
              "4": "State Change: poolType = = 2) wrapNative(stream, from, tokenIn, amountIn)",
              "5": "State Change: poolType = = 3) bentoBridge(stream, from, tokenIn, amountIn)",
              "6": "State Change: poolType = = 4) swapTrident(stream, from, tokenIn, amountIn)",
              "7": "State Change: poolType = = 5) swapCurve(stream, from, tokenIn, amountIn)",
              "1": "State Change: poolType = stream.readUint8()"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "wrapNative": {
            "name": "wrapNative",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "directionAndFake & 1 == 1",
                "line": 4
              },
              {
                "type": "if",
                "condition": "directionAndFake & 2 == 0",
                "line": 7
              },
              {
                "type": "if",
                "condition": "to != address(this",
                "line": 9
              },
              {
                "type": "if",
                "condition": "directionAndFake & 2 == 0",
                "line": 13
              },
              {
                "type": "if",
                "condition": "from == msg.sender",
                "line": 14
              }
            ],
            "state_changes": [
              {
                "variable": "directionAndFake",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 1
              },
              {
                "variable": "to",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 2
              },
              {
                "variable": "wrapToken",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (directionAndFake & 1 == 1)",
              "7": "if (directionAndFake & 2 == 0)",
              "9": "if (to != address(this)",
              "13": "if (directionAndFake & 2 == 0)",
              "14": "if (from == msg.sender)",
              "1": "State Change: directionAndFake = stream.readUint8()",
              "2": "State Change: to = stream.readAddress()",
              "6": "State Change: wrapToken = stream.readAddress()"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "bentoBridge": {
            "name": "bentoBridge",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "direction > 0",
                "line": 4
              },
              {
                "type": "if",
                "condition": "from == address(this",
                "line": 7
              },
              {
                "type": "if",
                "condition": "from == msg.sender",
                "line": 9
              },
              {
                "type": "if",
                "condition": "from != INTERNAL_INPUT_SOURCE",
                "line": 25
              }
            ],
            "state_changes": [
              {
                "variable": "to",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 2
              },
              {
                "variable": "direction",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 1
              }
            ],
            "external_calls": [
              {
                "target": "bentoBox",
                "type": "transfer",
                "arguments": "tokenIn, from, address(this",
                "line": 26
              }
            ],
            "value_transfers": [
              {
                "target": "bentoBox",
                "type": "transfer",
                "line": 26
              }
            ],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (direction > 0)",
              "7": "if (from == address(this)",
              "9": "if (from == msg.sender)",
              "25": "if (from != INTERNAL_INPUT_SOURCE)",
              "2": "State Change: to = stream.readAddress()",
              "1": "State Change: direction = stream.readUint8()",
              "26": "External Call: bentoBox.transfer(tokenIn, from, address(this)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "swapUniV2": {
            "name": "swapUniV2",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "from == address(this",
                "line": 6
              },
              {
                "type": "if",
                "condition": "from == msg.sender",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "to",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 3
              },
              {
                "variable": "direction",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 2
              },
              {
                "variable": "direction",
                "type": "uint8",
                "value": "= 1\n            ? (r0, r1)\n            : (r1, r0)",
                "line": 13
              },
              {
                "variable": "direction",
                "type": "uint8",
                "value": "= 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0))",
                "line": 21
              },
              {
                "variable": "pool",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              },
              {
                "variable": "fee",
                "type": "uint24",
                "value": "stream.readUint24()",
                "line": 4
              },
              {
                "variable": "amountInWithFee",
                "type": "uint256",
                "value": "amountIn * (1_000_000 - fee)",
                "line": 18
              },
              {
                "variable": "amountOut",
                "type": "uint256",
                "value": "(amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee)",
                "line": 19
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "r0 > 0 && r1 > 0, \"Wrong pool reserves\"",
                "line": 12
              }
            ],
            "line_mapping": {
              "6": "if (from == address(this)",
              "8": "if (from == msg.sender)",
              "3": "State Change: to = stream.readAddress()",
              "2": "State Change: direction = stream.readUint8()",
              "13": "State Change: direction = = 1\n            ? (r0, r1)\n            : (r1, r0)",
              "21": "State Change: direction = = 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0))",
              "1": "State Change: pool = stream.readAddress()",
              "4": "State Change: fee = stream.readUint24()",
              "18": "State Change: amountInWithFee = amountIn * (1_000_000 - fee)",
              "19": "State Change: amountOut = (amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee)",
              "12": "require(r0 > 0 && r1 > 0, \"Wrong pool reserves\")"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "swapTrident": {
            "name": "swapTrident",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "from != INTERNAL_INPUT_SOURCE",
                "line": 4
              }
            ],
            "state_changes": [
              {
                "variable": "pool",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              }
            ],
            "external_calls": [
              {
                "target": "bentoBox",
                "type": "transfer",
                "arguments": "tokenIn, from, pool, amountIn",
                "line": 5
              }
            ],
            "value_transfers": [
              {
                "target": "bentoBox",
                "type": "transfer",
                "line": 5
              }
            ],
            "condition_checks": [],
            "line_mapping": {
              "4": "if (from != INTERNAL_INPUT_SOURCE)",
              "1": "State Change: pool = stream.readAddress()",
              "5": "External Call: bentoBox.transfer(tokenIn, from, pool, amountIn)"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "swapUniV3": {
            "name": "swapUniV3",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "from == msg.sender",
                "line": 5
              }
            ],
            "state_changes": [
              {
                "variable": "lastCalledPool",
                "type": "address",
                "value": "pool",
                "line": 12
              },
              {
                "variable": "lastCalledPool",
                "type": "address",
                "value": "= IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        )",
                "line": 21
              },
              {
                "variable": "pool",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              },
              {
                "variable": "zeroForOne",
                "type": "bool",
                "value": "stream.readUint8() > 0",
                "line": 2
              },
              {
                "variable": "recipient",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 3
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"",
                "line": 20
              }
            ],
            "line_mapping": {
              "5": "if (from == msg.sender)",
              "12": "State Change: lastCalledPool = pool",
              "21": "State Change: lastCalledPool = = IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        )",
              "1": "State Change: pool = stream.readAddress()",
              "2": "State Change: zeroForOne = stream.readUint8() > 0",
              "3": "State Change: recipient = stream.readAddress()",
              "20": "require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\")"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          },
          "uniswapV3SwapCallback": {
            "name": "uniswapV3SwapCallback",
            "visibility": "public",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "lastCalledPool",
                "type": "address",
                "value": "IMPOSSIBLE_POOL_ADDRESS",
                "line": 11
              },
              {
                "variable": "amount",
                "type": "int256",
                "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                "line": 5
              },
              {
                "variable": "tokenIn",
                "type": "address",
                "value": "abi.decode(data, (address))",
                "line": 12
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [
              {
                "type": "require",
                "condition": "msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\"",
                "line": 1
              },
              {
                "type": "require",
                "condition": "amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\"",
                "line": 6
              }
            ],
            "line_mapping": {
              "11": "State Change: lastCalledPool = IMPOSSIBLE_POOL_ADDRESS",
              "5": "State Change: amount = amount0Delta > 0 ? amount0Delta : amount1Delta",
              "12": "State Change: tokenIn = abi.decode(data, (address))",
              "1": "require(msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\")",
              "6": "require(amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\")"
            },
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "algebraSwapCallback": {
            "name": "algebraSwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "pancakeV3SwapCallback": {
            "name": "pancakeV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "ramsesV2SwapCallback": {
            "name": "ramsesV2SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "xeiV3SwapCallback": {
            "name": "xeiV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "dragonswapV2SwapCallback": {
            "name": "dragonswapV2SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "agniSwapCallback": {
            "name": "agniSwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "fusionXV3SwapCallback": {
            "name": "fusionXV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "vvsV3SwapCallback": {
            "name": "vvsV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "supV3SwapCallback": {
            "name": "supV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "zebraV3SwapCallback": {
            "name": "zebraV3SwapCallback",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "int256",
                "name": "amount0Delta"
              },
              {
                "type": "int256",
                "name": "amount1Delta"
              },
              {
                "type": "bytes",
                "name": "data"
              }
            ],
            "returns": []
          },
          "swapCurve": {
            "name": "swapCurve",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "tokenIn == NATIVE_ADDRESS",
                "line": 9
              },
              {
                "type": "if",
                "condition": "from == msg.sender",
                "line": 17
              },
              {
                "type": "if",
                "condition": "poolType == 0",
                "line": 24
              },
              {
                "type": "if",
                "condition": "to != address(this",
                "line": 43
              },
              {
                "type": "if",
                "condition": "tokenOut == NATIVE_ADDRESS",
                "line": 44
              }
            ],
            "state_changes": [
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "stream.readUint8()",
                "line": 2
              },
              {
                "variable": "poolType",
                "type": "uint8",
                "value": "= 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
                "line": 24
              },
              {
                "variable": "to",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 5
              },
              {
                "variable": "pool",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 1
              },
              {
                "variable": "amountOut",
                "type": "uint256",
                "value": "ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
                "line": 10
              },
              {
                "variable": "amountOut",
                "type": "uint256",
                "value": "ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
                "line": 25
              },
              {
                "variable": "amountOut",
                "type": "uint256",
                "value": "balanceAfter - balanceBefore",
                "line": 39
              },
              {
                "variable": "tokenIn",
                "type": "address",
                "value": "= NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
                "line": 9
              },
              {
                "variable": "fromIndex",
                "type": "int128",
                "value": "int8(stream.readUint8())",
                "line": 3
              },
              {
                "variable": "toIndex",
                "type": "int128",
                "value": "int8(stream.readUint8())",
                "line": 4
              },
              {
                "variable": "tokenOut",
                "type": "address",
                "value": "stream.readAddress()",
                "line": 6
              },
              {
                "variable": "tokenOut",
                "type": "address",
                "value": "= NATIVE_ADDRESS) {\n                SafeTransferLib.safeTransferETH(to, amountOut)",
                "line": 44
              },
              {
                "variable": "balanceBefore",
                "type": "uint256",
                "value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )",
                "line": 32
              },
              {
                "variable": "balanceAfter",
                "type": "uint256",
                "value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )",
                "line": 36
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "9": "State Change: tokenIn = = NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
              "17": "if (from == msg.sender)",
              "24": "State Change: poolType = = 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
              "43": "if (to != address(this)",
              "44": "State Change: tokenOut = = NATIVE_ADDRESS) {\n                SafeTransferLib.safeTransferETH(to, amountOut)",
              "2": "State Change: poolType = stream.readUint8()",
              "5": "State Change: to = stream.readAddress()",
              "1": "State Change: pool = stream.readAddress()",
              "10": "State Change: amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
              "25": "State Change: amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
              "39": "State Change: amountOut = balanceAfter - balanceBefore",
              "3": "State Change: fromIndex = int8(stream.readUint8())",
              "4": "State Change: toIndex = int8(stream.readUint8())",
              "6": "State Change: tokenOut = stream.readAddress()",
              "32": "State Change: balanceBefore = IERC20(tokenOut).balanceOf(\n                    address(this)\n                )",
              "36": "State Change: balanceAfter = IERC20(tokenOut).balanceOf(\n                    address(this)\n                )"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "stream"
              },
              {
                "type": "address",
                "name": "from"
              },
              {
                "type": "address",
                "name": "tokenIn"
              },
              {
                "type": "uint256",
                "name": "amountIn"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "LiFiDEXAggregator": {
          "processRouteInternal": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "applyPermit",
                "state_changes": [
                  {
                    "variable": "value",
                    "type": "uint256",
                    "value": "stream.readUint()",
                    "line": 1
                  },
                  {
                    "variable": "deadline",
                    "type": "uint256",
                    "value": "stream.readUint()",
                    "line": 2
                  },
                  {
                    "variable": "v",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 3
                  },
                  {
                    "variable": "r",
                    "type": "bytes32",
                    "value": "stream.readBytes32()",
                    "line": 4
                  },
                  {
                    "variable": "s",
                    "type": "bytes32",
                    "value": "stream.readBytes32()",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "processNative",
                "state_changes": [
                  {
                    "variable": "amountTotal",
                    "type": "uint256",
                    "value": "address(this).balance",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "processMyERC20",
                "state_changes": [
                  {
                    "variable": "token",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  },
                  {
                    "variable": "amountTotal",
                    "type": "uint256",
                    "value": "IERC20(token).balanceOf(address(this))",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "processUserERC20",
                "state_changes": [
                  {
                    "variable": "token",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "processOnePool",
                "state_changes": [
                  {
                    "variable": "token",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "processInsideBento",
                "state_changes": [
                  {
                    "variable": "token",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  },
                  {
                    "variable": "amountTotal",
                    "type": "uint256",
                    "value": "bentoBox.balanceOf(token, address(this))",
                    "line": 2
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\"",
                "line": 33,
                "type": "require"
              }
            ]
          },
          "applyPermit": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "processNative": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "distributeAndSwap",
                "state_changes": [
                  {
                    "variable": "num",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "share",
                    "type": "uint16",
                    "value": "stream.readUint16()",
                    "line": 4
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "(amountTotal * share) /\n                    type(uint16).max /*65535*/",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "processMyERC20": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "distributeAndSwap",
                "state_changes": [
                  {
                    "variable": "num",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "share",
                    "type": "uint16",
                    "value": "stream.readUint16()",
                    "line": 4
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "(amountTotal * share) /\n                    type(uint16).max /*65535*/",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "processUserERC20": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "distributeAndSwap",
                "state_changes": [
                  {
                    "variable": "num",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "share",
                    "type": "uint16",
                    "value": "stream.readUint16()",
                    "line": 4
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "(amountTotal * share) /\n                    type(uint16).max /*65535*/",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "processOnePool": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swap",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                    "line": 3
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                    "line": 4
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                    "line": 5
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                    "line": 6
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "processInsideBento": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "distributeAndSwap",
                "state_changes": [
                  {
                    "variable": "num",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "share",
                    "type": "uint16",
                    "value": "stream.readUint16()",
                    "line": 4
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "(amountTotal * share) /\n                    type(uint16).max /*65535*/",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "distributeAndSwap": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swap",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                    "line": 3
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                    "line": 4
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                    "line": 5
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                    "line": 6
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "swap": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "wrapNative",
                "state_changes": [
                  {
                    "variable": "directionAndFake",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "to",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 2
                  },
                  {
                    "variable": "wrapToken",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 6
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "bentoBridge",
                "state_changes": [
                  {
                    "variable": "to",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 2
                  },
                  {
                    "variable": "direction",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  }
                ],
                "external_calls": [
                  {
                    "target": "bentoBox",
                    "type": "transfer",
                    "arguments": "tokenIn, from, address(this",
                    "line": 26
                  }
                ],
                "value_transfers": [
                  {
                    "target": "bentoBox",
                    "type": "transfer",
                    "line": 26
                  }
                ]
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapUniV2",
                "state_changes": [
                  {
                    "variable": "to",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 3
                  },
                  {
                    "variable": "direction",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 2
                  },
                  {
                    "variable": "direction",
                    "type": "uint8",
                    "value": "= 1\n            ? (r0, r1)\n            : (r1, r0)",
                    "line": 13
                  },
                  {
                    "variable": "direction",
                    "type": "uint8",
                    "value": "= 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0))",
                    "line": 21
                  },
                  {
                    "variable": "pool",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  },
                  {
                    "variable": "fee",
                    "type": "uint24",
                    "value": "stream.readUint24()",
                    "line": 4
                  },
                  {
                    "variable": "amountInWithFee",
                    "type": "uint256",
                    "value": "amountIn * (1_000_000 - fee)",
                    "line": 18
                  },
                  {
                    "variable": "amountOut",
                    "type": "uint256",
                    "value": "(amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee)",
                    "line": 19
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapTrident",
                "state_changes": [
                  {
                    "variable": "pool",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  }
                ],
                "external_calls": [
                  {
                    "target": "bentoBox",
                    "type": "transfer",
                    "arguments": "tokenIn, from, pool, amountIn",
                    "line": 5
                  }
                ],
                "value_transfers": [
                  {
                    "target": "bentoBox",
                    "type": "transfer",
                    "line": 5
                  }
                ]
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapUniV3",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "pool",
                    "line": 12
                  },
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "= IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        )",
                    "line": 21
                  },
                  {
                    "variable": "pool",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  },
                  {
                    "variable": "zeroForOne",
                    "type": "bool",
                    "value": "stream.readUint8() > 0",
                    "line": 2
                  },
                  {
                    "variable": "recipient",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 3
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapCurve",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
                    "line": 24
                  },
                  {
                    "variable": "to",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 5
                  },
                  {
                    "variable": "pool",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 1
                  },
                  {
                    "variable": "amountOut",
                    "type": "uint256",
                    "value": "ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
                    "line": 10
                  },
                  {
                    "variable": "amountOut",
                    "type": "uint256",
                    "value": "ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                )",
                    "line": 25
                  },
                  {
                    "variable": "amountOut",
                    "type": "uint256",
                    "value": "balanceAfter - balanceBefore",
                    "line": 39
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "= NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            )",
                    "line": 9
                  },
                  {
                    "variable": "fromIndex",
                    "type": "int128",
                    "value": "int8(stream.readUint8())",
                    "line": 3
                  },
                  {
                    "variable": "toIndex",
                    "type": "int128",
                    "value": "int8(stream.readUint8())",
                    "line": 4
                  },
                  {
                    "variable": "tokenOut",
                    "type": "address",
                    "value": "stream.readAddress()",
                    "line": 6
                  },
                  {
                    "variable": "tokenOut",
                    "type": "address",
                    "value": "= NATIVE_ADDRESS) {\n                SafeTransferLib.safeTransferETH(to, amountOut)",
                    "line": 44
                  },
                  {
                    "variable": "balanceBefore",
                    "type": "uint256",
                    "value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )",
                    "line": 32
                  },
                  {
                    "variable": "balanceAfter",
                    "type": "uint256",
                    "value": "IERC20(tokenOut).balanceOf(\n                    address(this)\n                )",
                    "line": 36
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapUniV2"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapTrident"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "swapUniV3"
              }
            ],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "wrapNative": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "bentoBridge": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [
              {
                "from": "LiFiDEXAggregator",
                "to": "bentoBox",
                "via": "bentoBridge",
                "line": 26
              }
            ],
            "path_conditions": []
          },
          "swapUniV2": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swap",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                    "line": 3
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                    "line": 4
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                    "line": 5
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                    "line": 6
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "r0 > 0 && r1 > 0, \"Wrong pool reserves\"",
                "line": 12,
                "type": "require"
              }
            ]
          },
          "swapTrident": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swap",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                    "line": 3
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                    "line": 4
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                    "line": 5
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                    "line": 6
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [
              {
                "from": "LiFiDEXAggregator",
                "to": "bentoBox",
                "via": "swapTrident",
                "line": 5
              }
            ],
            "path_conditions": []
          },
          "swapUniV3": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "swap",
                "state_changes": [
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "stream.readUint8()",
                    "line": 1
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 0) swapUniV2(stream, from, tokenIn, amountIn)",
                    "line": 2
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 1) swapUniV3(stream, from, tokenIn, amountIn)",
                    "line": 3
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 2) wrapNative(stream, from, tokenIn, amountIn)",
                    "line": 4
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 3) bentoBridge(stream, from, tokenIn, amountIn)",
                    "line": 5
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 4) swapTrident(stream, from, tokenIn, amountIn)",
                    "line": 6
                  },
                  {
                    "variable": "poolType",
                    "type": "uint8",
                    "value": "= 5) swapCurve(stream, from, tokenIn, amountIn)",
                    "line": 7
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"",
                "line": 20,
                "type": "require"
              }
            ]
          },
          "swapCurve": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "uniswapV3SwapCallback": {
            "calls": [],
            "caller_of": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "algebraSwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "pancakeV3SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "ramsesV2SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "xeiV3SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "dragonswapV2SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "agniSwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "fusionXV3SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "vvsV3SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "supV3SwapCallback"
              },
              {
                "contract": "LiFiDEXAggregator",
                "function": "zebraV3SwapCallback"
              }
            ],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": [
              {
                "condition": "msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\"",
                "line": 1,
                "type": "require"
              },
              {
                "condition": "amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\"",
                "line": 6,
                "type": "require"
              }
            ]
          },
          "algebraSwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "pancakeV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "ramsesV2SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "xeiV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "dragonswapV2SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "agniSwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "fusionXV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "vvsV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "supV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "zebraV3SwapCallback": {
            "calls": [
              {
                "contract": "LiFiDEXAggregator",
                "function": "uniswapV3SwapCallback",
                "state_changes": [
                  {
                    "variable": "lastCalledPool",
                    "type": "address",
                    "value": "IMPOSSIBLE_POOL_ADDRESS",
                    "line": 11
                  },
                  {
                    "variable": "amount",
                    "type": "int256",
                    "value": "amount0Delta > 0 ? amount0Delta : amount1Delta",
                    "line": 5
                  },
                  {
                    "variable": "tokenIn",
                    "type": "address",
                    "value": "abi.decode(data, (address))",
                    "line": 12
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.295915"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.302005"
      },
      "final_report": {
        "file_id": "LiFiDEXAggregator.sol",
        "timestamp": "2025-03-11T07:05:51.302031",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "LiFiDEXAggregator": {
            "functions": 26,
            "state_variables": 39,
            "inheritance": [
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LiFiDEXAggregator.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.302045"
    },
    "LiFuelFeeCollector.sol": {
      "file_id": "LiFuelFeeCollector.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "LiFuelFeeCollector": {
            "name": "LiFuelFeeCollector",
            "inheritance": [
              "TransferrableOwnership"
            ],
            "functions": {
              "collectTokenGasFees": {
                "name": "collectTokenGasFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  },
                  {
                    "type": "uint256",
                    "name": "feeAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "chainId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit GasFeesCollected(tokenAddress, chainId, receiver, feeAmount);\n    }"
              },
              "collectNativeGasFees": {
                "name": "collectNativeGasFees",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "uint256",
                    "name": "feeAmount"
                  },
                  {
                    "type": "uint256",
                    "name": "chainId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "emit GasFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            chainId,\n            receiver,\n            feeAmount\n        );\n        uint256 amountMinusFees = msg.value - feeAmount;\n        if (amountMinusFees > 0) {\n            SafeTransferLib.safeTransferETH(msg.sender, amountMinusFees);\n        }\n    }"
              }
            },
            "state_variables": {
              "amountMinusFees": {
                "name": "amountMinusFees",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "msg.value - feeAmount"
              },
              "balance": {
                "name": "balance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": null
              },
              "length": {
                "name": "length",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "tokenAddresses.length"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/// @title LiFuelFeeCollector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting fees for LiFuel\n/// @custom:version 1.0.2\ncontract LiFuelFeeCollector is TransferrableOwnership {\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event GasFeesCollected(\n        address indexed token,\n        uint256 indexed chainId,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event FeesWithdrawn(\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects gas fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on the destination chain\n    function collectTokenGasFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit GasFeesCollected(tokenAddress, chainId, receiver, feeAmount);\n    }\n\n    /// @notice Collects gas fees in native token\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on destination chain\n    function collectNativeGasFees(\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external payable {\n        emit GasFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            chainId,\n            receiver,\n            feeAmount\n        );\n        uint256 amountMinusFees = msg.value - feeAmount;\n        if (amountMinusFees > 0) {\n            SafeTransferLib.safeTransferETH(msg.sender, amountMinusFees);\n        }\n    }\n\n    /// @notice Withdraws fees\n    /// @param tokenAddress The address of the token to withdraw fees for\n    function withdrawFees(address tokenAddress) external onlyOwner {\n        uint256 balance = LibAsset.getOwnBalance(tokenAddress);\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees\n    /// @param tokenAddresses The addresses of the tokens to withdraw fees for\n    function batchWithdrawFees(\n        address[] calldata tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = LibAsset.getOwnBalance(tokenAddresses[i]);\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
      },
      "call_graph": {
        "LiFuelFeeCollector": {
          "collectTokenGasFees": [],
          "collectNativeGasFees": []
        }
      },
      "flow_data": {
        "LiFuelFeeCollector": {
          "collectTokenGasFees": {
            "name": "collectTokenGasFees",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              },
              {
                "type": "uint256",
                "name": "feeAmount"
              },
              {
                "type": "uint256",
                "name": "chainId"
              },
              {
                "type": "address",
                "name": "receiver"
              }
            ],
            "returns": []
          },
          "collectNativeGasFees": {
            "name": "collectNativeGasFees",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "amountMinusFees > 0",
                "line": 8
              }
            ],
            "state_changes": [
              {
                "variable": "amountMinusFees",
                "type": "uint256",
                "value": "msg.value - feeAmount",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "8": "if (amountMinusFees > 0)",
              "7": "State Change: amountMinusFees = msg.value - feeAmount"
            },
            "parameters": [
              {
                "type": "uint256",
                "name": "feeAmount"
              },
              {
                "type": "uint256",
                "name": "chainId"
              },
              {
                "type": "address",
                "name": "receiver"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "LiFuelFeeCollector": {
          "collectTokenGasFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "collectNativeGasFees": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.296852"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.304206"
      },
      "final_report": {
        "file_id": "LiFuelFeeCollector.sol",
        "timestamp": "2025-03-11T07:05:51.304226",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "LiFuelFeeCollector": {
            "functions": 2,
            "state_variables": 3,
            "inheritance": [
              "TransferrableOwnership"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LiFuelFeeCollector.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.304239"
    },
    "Permit2Proxy.sol": {
      "file_id": "Permit2Proxy.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "Permit2Proxy": {
            "name": "Permit2Proxy",
            "inheritance": [
              "WithdrawablePeriphery"
            ],
            "functions": {
              "callDiamondWithEIP2612Signature": {
                "name": "callDiamondWithEIP2612Signature",
                "visibility": "public",
                "parameters": [
                  {
                    "type": "address",
                    "name": "tokenAddress"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "uint256",
                    "name": "deadline"
                  },
                  {
                    "type": "uint8",
                    "name": "v"
                  },
                  {
                    "type": "bytes32",
                    "name": "r"
                  },
                  {
                    "type": "bytes32",
                    "name": "s"
                  },
                  {
                    "type": "bytes",
                    "name": "diamondCalldata"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// call permit on token contract to register approval using signature\n        try\n            ERC20Permit(tokenAddress).permit(\n                msg.sender, // Ensure msg.sender is same wallet that signed permit\n                address(this),\n                amount,\n                deadline,\n                v,\n                r,\n                s\n            )\n        {} catch Error(string memory reason) {\n            if (\n                IERC20(tokenAddress).allowance(msg.sender, address(this)) <\n                amount\n            ) {\n                revert(reason);\n            }\n        }\n\n        // deposit assets\n        LibAsset.transferFromERC20(\n            tokenAddress,\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(IERC20(tokenAddress), LIFI_DIAMOND, amount);\n\n        // call our diamond to execute calldata\n        return _executeCalldata(diamondCalldata);\n    }"
              },
              "callDiamondWithPermit2": {
                "name": "callDiamondWithPermit2",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_diamondCalldata"
                  },
                  {
                    "type": "ISignatureTransfer.PermitTransferFrom",
                    "name": "_permit"
                  },
                  {
                    "type": "bytes",
                    "name": "_signature"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "PERMIT2.permitTransferFrom(\n            _permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: _permit.permitted.amount\n            }),\n            msg.sender, // Ensure msg.sender is same wallet that signed permit\n            _signature\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(\n            IERC20(_permit.permitted.token),\n            LIFI_DIAMOND,\n            _permit.permitted.amount\n        );\n\n        return _executeCalldata(_diamondCalldata);\n    }"
              },
              "callDiamondWithPermit2Witness": {
                "name": "callDiamondWithPermit2Witness",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_diamondCalldata"
                  },
                  {
                    "type": "address",
                    "name": "_signer"
                  },
                  {
                    "type": "ISignatureTransfer.PermitTransferFrom",
                    "name": "_permit"
                  },
                  {
                    "type": "bytes",
                    "name": "_signature"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "LiFiCall memory lifiCall = LiFiCall(\n            LIFI_DIAMOND,\n            keccak256(_diamondCalldata)\n        );\n\n        bytes32 witness = keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall));\n\n        PERMIT2.permitWitnessTransferFrom(\n            _permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: _permit.permitted.amount\n            }),\n            _signer,\n            witness,\n            WITNESS_TYPE_STRING,\n            _signature\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(\n            IERC20(_permit.permitted.token),\n            LIFI_DIAMOND,\n            _permit.permitted.amount\n        );\n\n        return _executeCalldata(_diamondCalldata);\n    }"
              },
              "getPermit2MsgHash": {
                "name": "getPermit2MsgHash",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "_diamondCalldata"
                  },
                  {
                    "type": "address",
                    "name": "_assetId"
                  },
                  {
                    "type": "uint256",
                    "name": "_amount"
                  },
                  {
                    "type": "uint256",
                    "name": "_nonce"
                  },
                  {
                    "type": "uint256",
                    "name": "_deadline"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32 msgHash"
                  }
                ],
                "modifiers": [],
                "code": "// Token Permissions\n        ISignatureTransfer.TokenPermissions\n            memory tokenPermissions = ISignatureTransfer.TokenPermissions(\n                _assetId,\n                _amount\n            );\n        bytes32 tokenPermissionsHash = _getTokenPermissionsHash(\n            tokenPermissions\n        );\n\n        // Witness\n        Permit2Proxy.LiFiCall memory lifiCall = LiFiCall(\n            LIFI_DIAMOND,\n            keccak256(_diamondCalldata)\n        );\n        bytes32 witness = _getWitnessHash(lifiCall);\n\n        // PermitTransferWithWitness\n        msgHash = _getPermitWitnessTransferFromHash(\n            PERMIT2.DOMAIN_SEPARATOR(),\n            tokenPermissionsHash,\n            address(this),\n            _nonce,\n            _deadline,\n            witness\n        );\n    }"
              },
              "_getTokenPermissionsHash": {
                "name": "_getTokenPermissionsHash",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "ISignatureTransfer.TokenPermissions",
                    "name": "tokenPermissions"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32"
                  }
                ],
                "modifiers": [],
                "code": "return\n            keccak256(\n                abi.encode(\n                    PermitHash._TOKEN_PERMISSIONS_TYPEHASH,\n                    tokenPermissions.token,\n                    tokenPermissions.amount\n                )\n            );\n    }"
              },
              "_getWitnessHash": {
                "name": "_getWitnessHash",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "Permit2Proxy.LiFiCall",
                    "name": "lifiCall"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32"
                  }
                ],
                "modifiers": [],
                "code": "return keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall));\n    }"
              },
              "_getPermitWitnessTransferFromHash": {
                "name": "_getPermitWitnessTransferFromHash",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "domainSeparator"
                  },
                  {
                    "type": "bytes32",
                    "name": "permit"
                  },
                  {
                    "type": "address",
                    "name": "spender"
                  },
                  {
                    "type": "uint256",
                    "name": "nonce"
                  },
                  {
                    "type": "uint256",
                    "name": "deadline"
                  },
                  {
                    "type": "bytes32",
                    "name": "witness"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes32"
                  }
                ],
                "modifiers": [],
                "code": "bytes32 dataHash = keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        );\n\n        return\n            keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, dataHash));\n    }"
              },
              "_executeCalldata": {
                "name": "_executeCalldata",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "bytes",
                    "name": "diamondCalldata"
                  }
                ],
                "returns": [
                  {
                    "type": "bytes memory"
                  }
                ],
                "modifiers": [],
                "code": "// call diamond with provided calldata\n        SafeTransferLib.safeTransferETH(LIFI_DIAMOND, msg.value);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = LIFI_DIAMOND.call(diamondCalldata);\n        if (!success) {\n            revert CallToDiamondFailed(data);\n        }\n        return data;\n    }"
              },
              "nextNonce": {
                "name": "nextNonce",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "owner"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 nonce"
                  }
                ],
                "modifiers": [],
                "code": "nonce = _nextNonce(owner, 0, 0);\n    }"
              },
              "nextNonceAfter": {
                "name": "nextNonceAfter",
                "visibility": "external",
                "parameters": [
                  {
                    "type": "address",
                    "name": "owner"
                  },
                  {
                    "type": "uint256",
                    "name": "start"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 nonce"
                  }
                ],
                "modifiers": [],
                "code": "uint248 word = uint248(start >> 8);\n        uint8 pos = uint8(start);\n        if (pos == type(uint8).max) {\n            // If the position is 255, we need to move to the next word\n            word++;\n            pos = 0;\n        } else {\n            // Otherwise, we just move to the next position\n            pos++;\n        }\n        nonce = _nextNonce(owner, word, pos);\n    }"
              },
              "_nextNonce": {
                "name": "_nextNonce",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "address",
                    "name": "owner"
                  },
                  {
                    "type": "uint248",
                    "name": "word"
                  },
                  {
                    "type": "uint8",
                    "name": "pos"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 nonce"
                  }
                ],
                "modifiers": [],
                "code": "while (true) {\n            uint256 bitmap = PERMIT2.nonceBitmap(owner, word);\n\n            // Check if the bitmap is completely full\n            if (bitmap == type(uint256).max) {\n                // If so, move to the next word\n                ++word;\n                pos = 0;\n                continue;\n            }\n            if (pos != 0) {\n                // If the position is not 0, we need to shift the bitmap to ignore the bits before position\n                bitmap = bitmap >> pos;\n            }\n            // Find the first zero bit in the bitmap\n            while (bitmap & 1 == 1) {\n                bitmap = bitmap >> 1;\n                ++pos;\n            }\n\n            return _nonceFromWordAndPos(word, pos);\n        }\n    }"
              },
              "_nonceFromWordAndPos": {
                "name": "_nonceFromWordAndPos",
                "visibility": "internal",
                "parameters": [
                  {
                    "type": "uint248",
                    "name": "word"
                  },
                  {
                    "type": "uint8",
                    "name": "pos"
                  }
                ],
                "returns": [
                  {
                    "type": "uint256 nonce"
                  }
                ],
                "modifiers": [],
                "code": "// The last 248 bits of the word are the nonce bits\n        nonce = uint256(word) << 8;\n        // The first 8 bits of the word are the position inside the word\n        nonce |= pos;\n    }"
              }
            },
            "state_variables": {
              "diamondAddress": {
                "name": "diamondAddress",
                "type": "address",
                "visibility": "internal",
                "initial_value": null
              },
              "diamondCalldataHash": {
                "name": "diamondCalldataHash",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": null
              },
              "witness": {
                "name": "witness",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "_getWitnessHash(lifiCall)"
              },
              "tokenPermissions": {
                "name": "tokenPermissions",
                "type": "memory",
                "visibility": "internal",
                "initial_value": "ISignatureTransfer.TokenPermissions(\n                _assetId,\n                _amount\n            )"
              },
              "tokenPermissionsHash": {
                "name": "tokenPermissionsHash",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "_getTokenPermissionsHash(\n            tokenPermissions\n        )"
              },
              "dataHash": {
                "name": "dataHash",
                "type": "bytes32",
                "visibility": "internal",
                "initial_value": "keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        )"
              },
              "data": {
                "name": "data",
                "type": "return",
                "visibility": "internal",
                "initial_value": null
              },
              "word": {
                "name": "word",
                "type": "uint248",
                "visibility": "internal",
                "initial_value": "uint248(start >> 8)"
              },
              "pos": {
                "name": "pos",
                "type": "uint8",
                "visibility": "internal",
                "initial_value": "uint8(start)"
              },
              "bitmap": {
                "name": "bitmap",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "PERMIT2.nonceBitmap(owner, word)"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ISignatureTransfer } from \"permit2/interfaces/ISignatureTransfer.sol\";\nimport { LibAsset, IERC20 } from \"lifi/Libraries/LibAsset.sol\";\nimport { PermitHash } from \"permit2/libraries/PermitHash.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport { WithdrawablePeriphery } from \"lifi/Helpers/WithdrawablePeriphery.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/// @title Permit2Proxy\n/// @author LI.FI (https://li.fi)\n/// @notice Proxy contract allowing gasless calls via Permit2 as well as making\n///         token approvals via ERC20 Permit (EIP-2612) to our diamond contract\n/// @custom:version 1.0.2\ncontract Permit2Proxy is WithdrawablePeriphery {\n    /// Storage ///\n\n    address public immutable LIFI_DIAMOND;\n    ISignatureTransfer public immutable PERMIT2;\n\n    string public constant WITNESS_TYPE_STRING =\n        \"LiFiCall witness)LiFiCall(address diamondAddress,bytes32 diamondCalldataHash)TokenPermissions(address token,uint256 amount)\";\n    bytes32 public constant WITNESS_TYPEHASH =\n        keccak256(\n            \"LiFiCall(address diamondAddress,bytes32 diamondCalldataHash)\"\n        );\n    bytes32 public immutable PERMIT_WITH_WITNESS_TYPEHASH;\n\n    /// Types ///\n\n    // @dev LIFI Specific Witness which verifies the correct calldata and\n    //      diamond address\n    struct LiFiCall {\n        address diamondAddress;\n        bytes32 diamondCalldataHash;\n    }\n\n    /// Errors ///\n\n    error CallToDiamondFailed(bytes);\n\n    /// Constructor ///\n\n    constructor(\n        address _lifiDiamond,\n        ISignatureTransfer _permit2,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        LIFI_DIAMOND = _lifiDiamond;\n        PERMIT2 = _permit2;\n\n        PERMIT_WITH_WITNESS_TYPEHASH = keccak256(\n            abi.encodePacked(\n                PermitHash._PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB,\n                WITNESS_TYPE_STRING\n            )\n        );\n    }\n\n    /// External Functions ///\n\n    /// @notice Allows to bridge tokens through a LI.FI diamond contract using\n    /// an EIP2612 gasless permit (only works with tokenAddresses that\n    /// implement EIP2612)\n    /// The permit signer must be the caller to prevent front-running and ensure\n    /// the calldata cannot be replaced by others.\n    /// Can only be called by the permit signer to prevent front-running.\n    /// @param tokenAddress Address of the token to be bridged\n    /// @param amount Amount of tokens to be bridged\n    /// @param deadline Transaction must be completed before this timestamp\n    /// @param v User signature (recovery ID)\n    /// @param r User signature (ECDSA output)\n    /// @param s User signature (ECDSA output)\n    /// @param diamondCalldata calldata to execute\n    function callDiamondWithEIP2612Signature(\n        address tokenAddress,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes calldata diamondCalldata\n    ) public payable returns (bytes memory) {\n        // call permit on token contract to register approval using signature\n        try\n            ERC20Permit(tokenAddress).permit(\n                msg.sender, // Ensure msg.sender is same wallet that signed permit\n                address(this),\n                amount,\n                deadline,\n                v,\n                r,\n                s\n            )\n        {} catch Error(string memory reason) {\n            if (\n                IERC20(tokenAddress).allowance(msg.sender, address(this)) <\n                amount\n            ) {\n                revert(reason);\n            }\n        }\n\n        // deposit assets\n        LibAsset.transferFromERC20(\n            tokenAddress,\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(IERC20(tokenAddress), LIFI_DIAMOND, amount);\n\n        // call our diamond to execute calldata\n        return _executeCalldata(diamondCalldata);\n    }\n\n    /// @notice Allows to bridge tokens of one type through a LI.FI diamond\n    ///         contract using Uniswap's Permit2 contract and a user signature\n    ///         that verifies allowance. The permit signer must be the caller to prevent front-running and\n    ///         ensure the calldata cannot be replaced by others. Can only be called by the permit signer to prevent\n    ///         front-running.\n    /// @param _diamondCalldata the calldata to execute\n    /// @param _permit the Uniswap Permit2 parameters\n    /// @param _signature the signature giving approval to transfer tokens\n    function callDiamondWithPermit2(\n        bytes calldata _diamondCalldata,\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\n        bytes calldata _signature\n    ) external payable returns (bytes memory) {\n        PERMIT2.permitTransferFrom(\n            _permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: _permit.permitted.amount\n            }),\n            msg.sender, // Ensure msg.sender is same wallet that signed permit\n            _signature\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(\n            IERC20(_permit.permitted.token),\n            LIFI_DIAMOND,\n            _permit.permitted.amount\n        );\n\n        return _executeCalldata(_diamondCalldata);\n    }\n\n    /// @notice Allows to bridge tokens of one type through a LI.FI diamond\n    ///         contract using Uniswap's Permit2 contract and a user signature\n    ///         that verifies allowance, diamondAddress and diamondCalldata\n    /// @param _diamondCalldata the calldata to execute\n    /// @param _signer the signer giving permission to transfer tokens\n    /// @param _permit the Uniswap Permit2 parameters\n    /// @param _signature the signature giving approval to transfer tokens\n    function callDiamondWithPermit2Witness(\n        bytes calldata _diamondCalldata,\n        address _signer,\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\n        bytes calldata _signature\n    ) external payable returns (bytes memory) {\n        LiFiCall memory lifiCall = LiFiCall(\n            LIFI_DIAMOND,\n            keccak256(_diamondCalldata)\n        );\n\n        bytes32 witness = keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall));\n\n        PERMIT2.permitWitnessTransferFrom(\n            _permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: _permit.permitted.amount\n            }),\n            _signer,\n            witness,\n            WITNESS_TYPE_STRING,\n            _signature\n        );\n\n        // maxApprove token to diamond if current allowance is insufficient\n        LibAsset.maxApproveERC20(\n            IERC20(_permit.permitted.token),\n            LIFI_DIAMOND,\n            _permit.permitted.amount\n        );\n\n        return _executeCalldata(_diamondCalldata);\n    }\n\n    /// @notice utitlity method for constructing a valid Permit2 message hash\n    /// @param _diamondCalldata the calldata to execute\n    /// @param _assetId the address of the token to approve\n    /// @param _amount amount of tokens to approve\n    /// @param _nonce the nonce to use\n    /// @param _deadline the expiration deadline\n    function getPermit2MsgHash(\n        bytes calldata _diamondCalldata,\n        address _assetId,\n        uint256 _amount,\n        uint256 _nonce,\n        uint256 _deadline\n    ) external view returns (bytes32 msgHash) {\n        // Token Permissions\n        ISignatureTransfer.TokenPermissions\n            memory tokenPermissions = ISignatureTransfer.TokenPermissions(\n                _assetId,\n                _amount\n            );\n        bytes32 tokenPermissionsHash = _getTokenPermissionsHash(\n            tokenPermissions\n        );\n\n        // Witness\n        Permit2Proxy.LiFiCall memory lifiCall = LiFiCall(\n            LIFI_DIAMOND,\n            keccak256(_diamondCalldata)\n        );\n        bytes32 witness = _getWitnessHash(lifiCall);\n\n        // PermitTransferWithWitness\n        msgHash = _getPermitWitnessTransferFromHash(\n            PERMIT2.DOMAIN_SEPARATOR(),\n            tokenPermissionsHash,\n            address(this),\n            _nonce,\n            _deadline,\n            witness\n        );\n    }\n\n    /// Internal Functions ///\n\n    function _getTokenPermissionsHash(\n        ISignatureTransfer.TokenPermissions memory tokenPermissions\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PermitHash._TOKEN_PERMISSIONS_TYPEHASH,\n                    tokenPermissions.token,\n                    tokenPermissions.amount\n                )\n            );\n    }\n\n    function _getWitnessHash(\n        Permit2Proxy.LiFiCall memory lifiCall\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall));\n    }\n\n    function _getPermitWitnessTransferFromHash(\n        bytes32 domainSeparator,\n        bytes32 permit,\n        address spender,\n        uint256 nonce,\n        uint256 deadline,\n        bytes32 witness\n    ) internal view returns (bytes32) {\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        );\n\n        return\n            keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, dataHash));\n    }\n\n    function _executeCalldata(\n        bytes memory diamondCalldata\n    ) internal returns (bytes memory) {\n        // call diamond with provided calldata\n        SafeTransferLib.safeTransferETH(LIFI_DIAMOND, msg.value);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = LIFI_DIAMOND.call(diamondCalldata);\n        if (!success) {\n            revert CallToDiamondFailed(data);\n        }\n        return data;\n    }\n\n    /// The following code was adapted from https://github.com/flood-protocol/permit2-nonce-finder/blob/7a4ac8a58d0b499308000b75ddb2384834f31fac/src/Permit2NonceFinder.sol\n    /// Provides utility functions for determining the next valid Permit2 nonce\n\n    /// @notice Finds the next valid nonce for a user, starting from 0.\n    /// @param owner The owner of the nonces\n    /// @return nonce The first valid nonce starting from 0\n    function nextNonce(address owner) external view returns (uint256 nonce) {\n        nonce = _nextNonce(owner, 0, 0);\n    }\n\n    /// @notice Finds the next valid nonce for a user, after from a given nonce.\n    /// @dev This can be helpful if you're signing multiple nonces in a row and need the next nonce to sign but the start one is still valid.\n    /// @param owner The owner of the nonces\n    /// @param start The nonce to start from\n    /// @return nonce The first valid nonce after the given nonce\n    function nextNonceAfter(\n        address owner,\n        uint256 start\n    ) external view returns (uint256 nonce) {\n        uint248 word = uint248(start >> 8);\n        uint8 pos = uint8(start);\n        if (pos == type(uint8).max) {\n            // If the position is 255, we need to move to the next word\n            word++;\n            pos = 0;\n        } else {\n            // Otherwise, we just move to the next position\n            pos++;\n        }\n        nonce = _nextNonce(owner, word, pos);\n    }\n\n    /// @notice Finds the next valid nonce for a user, starting from a given word and position.\n    /// @param owner The owner of the nonces\n    /// @param word Word to start looking from\n    /// @param pos Position inside the word to start looking from\n    function _nextNonce(\n        address owner,\n        uint248 word,\n        uint8 pos\n    ) internal view returns (uint256 nonce) {\n        while (true) {\n            uint256 bitmap = PERMIT2.nonceBitmap(owner, word);\n\n            // Check if the bitmap is completely full\n            if (bitmap == type(uint256).max) {\n                // If so, move to the next word\n                ++word;\n                pos = 0;\n                continue;\n            }\n            if (pos != 0) {\n                // If the position is not 0, we need to shift the bitmap to ignore the bits before position\n                bitmap = bitmap >> pos;\n            }\n            // Find the first zero bit in the bitmap\n            while (bitmap & 1 == 1) {\n                bitmap = bitmap >> 1;\n                ++pos;\n            }\n\n            return _nonceFromWordAndPos(word, pos);\n        }\n    }\n\n    /// @notice Constructs a nonce from a word and a position inside the word\n    /// @param word The word containing the nonce\n    /// @param pos The position of the nonce inside the word\n    /// @return nonce The nonce constructed from the word and position\n    function _nonceFromWordAndPos(\n        uint248 word,\n        uint8 pos\n    ) internal pure returns (uint256 nonce) {\n        // The last 248 bits of the word are the nonce bits\n        nonce = uint256(word) << 8;\n        // The first 8 bits of the word are the position inside the word\n        nonce |= pos;\n    }\n\n    // required to be able to receive native token refunds from the diamond\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "Permit2Proxy": {
          "callDiamondWithEIP2612Signature": [
            {
              "contract": "Permit2Proxy",
              "function": "_executeCalldata"
            }
          ],
          "callDiamondWithPermit2": [
            {
              "contract": "Permit2Proxy",
              "function": "_executeCalldata"
            }
          ],
          "callDiamondWithPermit2Witness": [
            {
              "contract": "Permit2Proxy",
              "function": "_executeCalldata"
            }
          ],
          "getPermit2MsgHash": [
            {
              "contract": "Permit2Proxy",
              "function": "_getTokenPermissionsHash"
            },
            {
              "contract": "Permit2Proxy",
              "function": "_getWitnessHash"
            },
            {
              "contract": "Permit2Proxy",
              "function": "_getPermitWitnessTransferFromHash"
            }
          ],
          "_getTokenPermissionsHash": [],
          "_getWitnessHash": [],
          "_getPermitWitnessTransferFromHash": [],
          "_executeCalldata": [],
          "nextNonce": [
            {
              "contract": "Permit2Proxy",
              "function": "_nextNonce"
            }
          ],
          "nextNonceAfter": [
            {
              "contract": "Permit2Proxy",
              "function": "_nextNonce"
            }
          ],
          "_nextNonce": [
            {
              "contract": "Permit2Proxy",
              "function": "_nonceFromWordAndPos"
            }
          ],
          "_nonceFromWordAndPos": []
        }
      },
      "flow_data": {
        "Permit2Proxy": {
          "callDiamondWithEIP2612Signature": {
            "name": "callDiamondWithEIP2612Signature",
            "visibility": "public",
            "control_structures": [
              {
                "type": "if",
                "condition": "IERC20(tokenAddress",
                "line": 13
              }
            ],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "13": "if (IERC20(tokenAddress)"
            },
            "parameters": [
              {
                "type": "address",
                "name": "tokenAddress"
              },
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "uint256",
                "name": "deadline"
              },
              {
                "type": "uint8",
                "name": "v"
              },
              {
                "type": "bytes32",
                "name": "r"
              },
              {
                "type": "bytes32",
                "name": "s"
              },
              {
                "type": "bytes",
                "name": "diamondCalldata"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "callDiamondWithPermit2": {
            "name": "callDiamondWithPermit2",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes",
                "name": "_diamondCalldata"
              },
              {
                "type": "ISignatureTransfer.PermitTransferFrom",
                "name": "_permit"
              },
              {
                "type": "bytes",
                "name": "_signature"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "callDiamondWithPermit2Witness": {
            "name": "callDiamondWithPermit2Witness",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "witness",
                "type": "bytes32",
                "value": "keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall))",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "6": "State Change: witness = keccak256(abi.encode(WITNESS_TYPEHASH, lifiCall))"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_diamondCalldata"
              },
              {
                "type": "address",
                "name": "_signer"
              },
              {
                "type": "ISignatureTransfer.PermitTransferFrom",
                "name": "_permit"
              },
              {
                "type": "bytes",
                "name": "_signature"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "getPermit2MsgHash": {
            "name": "getPermit2MsgHash",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "witness",
                "type": "bytes32",
                "value": "_getWitnessHash(lifiCall)",
                "line": 16
              },
              {
                "variable": "tokenPermissions",
                "type": "memory",
                "value": "ISignatureTransfer.TokenPermissions(\n                _assetId,\n                _amount\n            )",
                "line": 3
              },
              {
                "variable": "tokenPermissionsHash",
                "type": "bytes32",
                "value": "_getTokenPermissionsHash(\n            tokenPermissions\n        )",
                "line": 7
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "16": "State Change: witness = _getWitnessHash(lifiCall)",
              "3": "State Change: tokenPermissions = ISignatureTransfer.TokenPermissions(\n                _assetId,\n                _amount\n            )",
              "7": "State Change: tokenPermissionsHash = _getTokenPermissionsHash(\n            tokenPermissions\n        )"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "_diamondCalldata"
              },
              {
                "type": "address",
                "name": "_assetId"
              },
              {
                "type": "uint256",
                "name": "_amount"
              },
              {
                "type": "uint256",
                "name": "_nonce"
              },
              {
                "type": "uint256",
                "name": "_deadline"
              }
            ],
            "returns": [
              {
                "type": "bytes32 msgHash"
              }
            ]
          },
          "_getTokenPermissionsHash": {
            "name": "_getTokenPermissionsHash",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "ISignatureTransfer.TokenPermissions",
                "name": "tokenPermissions"
              }
            ],
            "returns": [
              {
                "type": "bytes32"
              }
            ]
          },
          "_getWitnessHash": {
            "name": "_getWitnessHash",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "Permit2Proxy.LiFiCall",
                "name": "lifiCall"
              }
            ],
            "returns": [
              {
                "type": "bytes32"
              }
            ]
          },
          "_getPermitWitnessTransferFromHash": {
            "name": "_getPermitWitnessTransferFromHash",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "dataHash",
                "type": "bytes32",
                "value": "keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        )",
                "line": 1
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "State Change: dataHash = keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        )"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "domainSeparator"
              },
              {
                "type": "bytes32",
                "name": "permit"
              },
              {
                "type": "address",
                "name": "spender"
              },
              {
                "type": "uint256",
                "name": "nonce"
              },
              {
                "type": "uint256",
                "name": "deadline"
              },
              {
                "type": "bytes32",
                "name": "witness"
              }
            ],
            "returns": [
              {
                "type": "bytes32"
              }
            ]
          },
          "_executeCalldata": {
            "name": "_executeCalldata",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "if",
                "condition": "!success",
                "line": 5
              }
            ],
            "state_changes": [],
            "external_calls": [
              {
                "target": "LIFI_DIAMOND",
                "type": "call",
                "arguments": "diamondCalldata",
                "line": 4
              }
            ],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "if (!success)",
              "4": "External Call: LIFI_DIAMOND.call(diamondCalldata)"
            },
            "parameters": [
              {
                "type": "bytes",
                "name": "diamondCalldata"
              }
            ],
            "returns": [
              {
                "type": "bytes memory"
              }
            ]
          },
          "nextNonce": {
            "name": "nextNonce",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "address",
                "name": "owner"
              }
            ],
            "returns": [
              {
                "type": "uint256 nonce"
              }
            ]
          },
          "nextNonceAfter": {
            "name": "nextNonceAfter",
            "visibility": "external",
            "control_structures": [
              {
                "type": "if",
                "condition": "pos == type(uint8",
                "line": 3
              }
            ],
            "state_changes": [
              {
                "variable": "word",
                "type": "uint248",
                "value": "uint248(start >> 8)",
                "line": 1
              },
              {
                "variable": "pos",
                "type": "uint8",
                "value": "uint8(start)",
                "line": 2
              },
              {
                "variable": "pos",
                "type": "uint8",
                "value": "= type(uint8).max) {\n            // If the position is 255, we need to move to the next word\n            word++",
                "line": 3
              },
              {
                "variable": "pos",
                "type": "uint8",
                "value": "0",
                "line": 6
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "State Change: pos = = type(uint8).max) {\n            // If the position is 255, we need to move to the next word\n            word++",
              "1": "State Change: word = uint248(start >> 8)",
              "2": "State Change: pos = uint8(start)",
              "6": "State Change: pos = 0"
            },
            "parameters": [
              {
                "type": "address",
                "name": "owner"
              },
              {
                "type": "uint256",
                "name": "start"
              }
            ],
            "returns": [
              {
                "type": "uint256 nonce"
              }
            ]
          },
          "_nextNonce": {
            "name": "_nextNonce",
            "visibility": "internal",
            "control_structures": [
              {
                "type": "while",
                "condition": "true",
                "line": 1
              },
              {
                "type": "if",
                "condition": "bitmap == type(uint256",
                "line": 5
              },
              {
                "type": "if",
                "condition": "pos != 0",
                "line": 11
              },
              {
                "type": "while",
                "condition": "bitmap & 1 == 1",
                "line": 16
              }
            ],
            "state_changes": [
              {
                "variable": "pos",
                "type": "uint8",
                "value": "0",
                "line": 8
              },
              {
                "variable": "bitmap",
                "type": "uint256",
                "value": "PERMIT2.nonceBitmap(owner, word)",
                "line": 2
              },
              {
                "variable": "bitmap",
                "type": "uint256",
                "value": "= type(uint256).max) {\n                // If so, move to the next word\n                ++word",
                "line": 5
              },
              {
                "variable": "bitmap",
                "type": "uint256",
                "value": "bitmap >> pos",
                "line": 13
              },
              {
                "variable": "bitmap",
                "type": "uint256",
                "value": "bitmap >> 1",
                "line": 17
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "1": "while (true)",
              "5": "State Change: bitmap = = type(uint256).max) {\n                // If so, move to the next word\n                ++word",
              "11": "if (pos != 0)",
              "16": "while (bitmap & 1 == 1)",
              "8": "State Change: pos = 0",
              "2": "State Change: bitmap = PERMIT2.nonceBitmap(owner, word)",
              "13": "State Change: bitmap = bitmap >> pos",
              "17": "State Change: bitmap = bitmap >> 1"
            },
            "parameters": [
              {
                "type": "address",
                "name": "owner"
              },
              {
                "type": "uint248",
                "name": "word"
              },
              {
                "type": "uint8",
                "name": "pos"
              }
            ],
            "returns": [
              {
                "type": "uint256 nonce"
              }
            ]
          },
          "_nonceFromWordAndPos": {
            "name": "_nonceFromWordAndPos",
            "visibility": "internal",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "uint248",
                "name": "word"
              },
              {
                "type": "uint8",
                "name": "pos"
              }
            ],
            "returns": [
              {
                "type": "uint256 nonce"
              }
            ]
          }
        }
      },
      "flow_paths": {
        "Permit2Proxy": {
          "callDiamondWithEIP2612Signature": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_executeCalldata",
                "state_changes": [],
                "external_calls": [
                  {
                    "target": "LIFI_DIAMOND",
                    "type": "call",
                    "arguments": "diamondCalldata",
                    "line": 4
                  }
                ],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_executeCalldata": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "callDiamondWithPermit2": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_executeCalldata",
                "state_changes": [],
                "external_calls": [
                  {
                    "target": "LIFI_DIAMOND",
                    "type": "call",
                    "arguments": "diamondCalldata",
                    "line": 4
                  }
                ],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "callDiamondWithPermit2Witness": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_executeCalldata",
                "state_changes": [],
                "external_calls": [
                  {
                    "target": "LIFI_DIAMOND",
                    "type": "call",
                    "arguments": "diamondCalldata",
                    "line": 4
                  }
                ],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "getPermit2MsgHash": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_getTokenPermissionsHash",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "Permit2Proxy",
                "function": "_getWitnessHash",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              },
              {
                "contract": "Permit2Proxy",
                "function": "_getPermitWitnessTransferFromHash",
                "state_changes": [
                  {
                    "variable": "dataHash",
                    "type": "bytes32",
                    "value": "keccak256(\n            abi.encode(\n                PERMIT_WITH_WITNESS_TYPEHASH,\n                permit,\n                spender,\n                nonce,\n                deadline,\n                witness\n            )\n        )",
                    "line": 1
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getTokenPermissionsHash": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getWitnessHash": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_getPermitWitnessTransferFromHash": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "nextNonce": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_nextNonce",
                "state_changes": [
                  {
                    "variable": "pos",
                    "type": "uint8",
                    "value": "0",
                    "line": 8
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "PERMIT2.nonceBitmap(owner, word)",
                    "line": 2
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "= type(uint256).max) {\n                // If so, move to the next word\n                ++word",
                    "line": 5
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "bitmap >> pos",
                    "line": 13
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "bitmap >> 1",
                    "line": 17
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_nextNonce": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_nonceFromWordAndPos",
                "state_changes": [],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "nextNonceAfter": {
            "calls": [
              {
                "contract": "Permit2Proxy",
                "function": "_nextNonce",
                "state_changes": [
                  {
                    "variable": "pos",
                    "type": "uint8",
                    "value": "0",
                    "line": 8
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "PERMIT2.nonceBitmap(owner, word)",
                    "line": 2
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "= type(uint256).max) {\n                // If so, move to the next word\n                ++word",
                    "line": 5
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "bitmap >> pos",
                    "line": 13
                  },
                  {
                    "variable": "bitmap",
                    "type": "uint256",
                    "value": "bitmap >> 1",
                    "line": 17
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "_nonceFromWordAndPos": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.299021"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.305115"
      },
      "final_report": {
        "file_id": "Permit2Proxy.sol",
        "timestamp": "2025-03-11T07:05:51.305138",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "Permit2Proxy": {
            "functions": 12,
            "state_variables": 10,
            "inheritance": [
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of Permit2Proxy.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.305152"
    },
    "Receiver.sol": {
      "file_id": "Receiver.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "Receiver": {
            "name": "Receiver",
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "WithdrawablePeriphery"
            ],
            "functions": {
              "_swapAndCompleteBridgeTokens": {
                "name": "_swapAndCompleteBridgeTokens",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "bool",
                    "name": "reserveRecoverGas"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 _recoverGas = reserveRecoverGas ? recoverGas : 0;\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            uint256 cacheGasLeft = gasleft();\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            uint256 cacheGasLeft = gasleft();\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }"
              }
            },
            "state_variables": {
              "sgRouter": {
                "name": "sgRouter",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "executor": {
                "name": "executor",
                "type": "IExecutor",
                "visibility": "public",
                "initial_value": null
              },
              "recoverGas": {
                "name": "recoverGas",
                "type": "uint256",
                "visibility": "public",
                "initial_value": null
              },
              "amarokRouter": {
                "name": "amarokRouter",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "allowance": {
                "name": "allowance",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "IERC20(assetId).allowance(\n                msg.sender,\n                address(this)\n            )"
              },
              "_recoverGas": {
                "name": "_recoverGas",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "reserveRecoverGas ? recoverGas : 0"
              },
              "cacheGasLeft": {
                "name": "cacheGasLeft",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "gasleft()"
              },
              "token": {
                "name": "token",
                "type": "IERC20",
                "visibility": "internal",
                "initial_value": "IERC20(assetId)"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Receiver\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.1.0\ncontract Receiver is ILiFi, ReentrancyGuard, WithdrawablePeriphery {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n    address public sgRouter;\n    IExecutor public executor;\n    uint256 public recoverGas;\n    address public amarokRouter;\n\n    /// Events ///\n    event StargateRouterSet(address indexed router);\n    event AmarokRouterSet(address indexed router);\n    event ExecutorSet(address indexed executor);\n    event RecoverGasSet(uint256 indexed recoverGas);\n\n    /// Modifiers ///\n    modifier onlySGRouter() {\n        if (msg.sender != sgRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n    modifier onlyAmarokRouter() {\n        if (msg.sender != amarokRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _sgRouter,\n        address _amarokRouter,\n        address _executor,\n        uint256 _recoverGas\n    ) WithdrawablePeriphery(_owner) {\n        sgRouter = _sgRouter;\n        amarokRouter = _amarokRouter;\n        executor = IExecutor(_executor);\n        recoverGas = _recoverGas;\n        emit StargateRouterSet(_sgRouter);\n        emit AmarokRouterSet(_amarokRouter);\n        emit RecoverGasSet(_recoverGas);\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes a cross-chain transaction with calldata via Amarok facet on the receiving chain.\n    /// @dev This function is called from Amarok Router.\n    /// @param _transferId The unique ID of this transaction (assigned by Amarok)\n    /// @param _amount the amount of bridged tokens\n    /// @param _asset the address of the bridged token\n    /// @param * (unused) the sender of the transaction\n    /// @param * (unused) the domain ID of the src chain\n    /// @param _callData The data to execute\n    function xReceive(\n        bytes32 _transferId,\n        uint256 _amount,\n        address _asset,\n        address,\n        uint32,\n        bytes memory _callData\n    ) external nonReentrant onlyAmarokRouter {\n        (LibSwap.SwapData[] memory swapData, address receiver) = abi.decode(\n            _callData,\n            (LibSwap.SwapData[], address)\n        );\n\n        _swapAndCompleteBridgeTokens(\n            _transferId,\n            swapData,\n            _asset,\n            payable(receiver),\n            _amount,\n            false\n        );\n    }\n\n    /// @notice Completes a cross-chain transaction on the receiving chain.\n    /// @dev This function is called from Stargate Router.\n    /// @param * (unused) The remote chainId sending the tokens\n    /// @param * (unused) The remote Bridge address\n    /// @param * (unused) Nonce\n    /// @param _token The token contract on the local chain\n    /// @param _amountLD The amount of tokens received through bridging\n    /// @param _payload The data to execute\n    function sgReceive(\n        uint16, // _srcChainId unused\n        bytes memory, // _srcAddress unused\n        uint256, // _nonce unused\n        address _token,\n        uint256 _amountLD,\n        bytes memory _payload\n    ) external nonReentrant onlySGRouter {\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            ,\n            address receiver\n        ) = abi.decode(\n                _payload,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            swapData.length > 0 ? swapData[0].sendingAssetId : _token, // If swapping assume sent token is the first token in swapData\n            payable(receiver),\n            _amountLD,\n            true\n        );\n    }\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver\n    ) external payable nonReentrant {\n        if (LibAsset.isNativeAsset(assetId)) {\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                msg.value,\n                false\n            );\n        } else {\n            uint256 allowance = IERC20(assetId).allowance(\n                msg.sender,\n                address(this)\n            );\n            LibAsset.depositAsset(assetId, allowance);\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                allowance,\n                false\n            );\n        }\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    /// @param reserveRecoverGas whether we need a gas buffer to recover\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        bool reserveRecoverGas\n    ) private {\n        uint256 _recoverGas = reserveRecoverGas ? recoverGas : 0;\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            uint256 cacheGasLeft = gasleft();\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            uint256 cacheGasLeft = gasleft();\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }\n\n    /// @notice Receive native asset directly.\n    /// @dev Some bridges may send native asset before execute external calls.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "Receiver": {
          "_swapAndCompleteBridgeTokens": []
        }
      },
      "flow_data": {
        "Receiver": {
          "_swapAndCompleteBridgeTokens": {
            "name": "_swapAndCompleteBridgeTokens",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(assetId",
                "line": 3
              },
              {
                "type": "if",
                "condition": "reserveRecoverGas && cacheGasLeft < _recoverGas",
                "line": 6
              },
              {
                "type": "if",
                "condition": "reserveRecoverGas && cacheGasLeft < _recoverGas",
                "line": 44
              }
            ],
            "state_changes": [
              {
                "variable": "_recoverGas",
                "type": "uint256",
                "value": "reserveRecoverGas ? recoverGas : 0",
                "line": 1
              },
              {
                "variable": "cacheGasLeft",
                "type": "uint256",
                "value": "gasleft()",
                "line": 5
              },
              {
                "variable": "cacheGasLeft",
                "type": "uint256",
                "value": "gasleft()",
                "line": 40
              },
              {
                "variable": "token",
                "type": "IERC20",
                "value": "IERC20(assetId)",
                "line": 41
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (LibAsset.isNativeAsset(assetId)",
              "6": "if (reserveRecoverGas && cacheGasLeft < _recoverGas)",
              "44": "if (reserveRecoverGas && cacheGasLeft < _recoverGas)",
              "1": "State Change: _recoverGas = reserveRecoverGas ? recoverGas : 0",
              "5": "State Change: cacheGasLeft = gasleft()",
              "40": "State Change: cacheGasLeft = gasleft()",
              "41": "State Change: token = IERC20(assetId)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "bool",
                "name": "reserveRecoverGas"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "Receiver": {
          "_swapAndCompleteBridgeTokens": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.301220"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.307110"
      },
      "final_report": {
        "file_id": "Receiver.sol",
        "timestamp": "2025-03-11T07:05:51.307131",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "Receiver": {
            "functions": 1,
            "state_variables": 8,
            "inheritance": [
              "ILiFi",
              "ReentrancyGuard",
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of Receiver.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.307143"
    },
    "ReceiverAcrossV3.sol": {
      "file_id": "ReceiverAcrossV3.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ReceiverAcrossV3": {
            "name": "ReceiverAcrossV3",
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ],
            "functions": {
              "_swapAndCompleteBridgeTokens": {
                "name": "_swapAndCompleteBridgeTokens",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "assetId.safeApproveWithRetry(address(executor), amount);\n        try\n            executor.swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver\n            )\n        {} catch {\n            // send the bridged (and unswapped) funds to receiver address\n            assetId.safeTransfer(receiver, amount);\n\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                receiver,\n                amount,\n                block.timestamp\n            );\n        }\n\n        // reset approval to 0\n        assetId.safeApprove(address(executor), 0);\n    }"
              }
            },
            "state_variables": {},
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/// @title ReceiverAcrossV3\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing via AcrossV3\n/// @custom:version 1.1.0\ncontract ReceiverAcrossV3 is ILiFi, WithdrawablePeriphery {\n    using SafeTransferLib for address;\n\n    /// Storage ///\n    IExecutor public immutable executor;\n    address public immutable spokepool;\n\n    /// Modifiers ///\n    modifier onlySpokepool() {\n        if (msg.sender != spokepool) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _executor,\n        address _spokepool\n    ) WithdrawablePeriphery(_owner) {\n        executor = IExecutor(_executor);\n        spokepool = _spokepool;\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes an AcrossV3 cross-chain transaction on the receiving chain\n    /// @dev Token transfer and message execution will happen in one atomic transaction\n    /// @dev This function can only be called the Across SpokePool on this network\n    /// @param tokenSent The address of the token that was received\n    /// @param amount The amount of tokens received\n    /// @param * - unused(relayer) The address of the relayer who is executing this message\n    /// @param message The composed message payload in bytes\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address,\n        bytes memory message\n    ) external onlySpokepool {\n        // decode payload\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver\n        ) = abi.decode(message, (bytes32, LibSwap.SwapData[], address));\n\n        // execute swap(s)\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            tokenSent,\n            payable(receiver),\n            amount\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @notice Since Across will always send wrappedNative to contract, we do not need a native handling here\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId address of the token received from the source chain (not to be confused with StargateV2's assetIds which are uint16 values)\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) private {\n        assetId.safeApproveWithRetry(address(executor), amount);\n        try\n            executor.swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver\n            )\n        {} catch {\n            // send the bridged (and unswapped) funds to receiver address\n            assetId.safeTransfer(receiver, amount);\n\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                receiver,\n                amount,\n                block.timestamp\n            );\n        }\n\n        // reset approval to 0\n        assetId.safeApprove(address(executor), 0);\n    }\n\n    /// @notice Receive native asset directly.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "ReceiverAcrossV3": {
          "_swapAndCompleteBridgeTokens": []
        }
      },
      "flow_data": {
        "ReceiverAcrossV3": {
          "_swapAndCompleteBridgeTokens": {
            "name": "_swapAndCompleteBridgeTokens",
            "visibility": "private",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "amount"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "ReceiverAcrossV3": {
          "_swapAndCompleteBridgeTokens": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.307849"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.310084"
      },
      "final_report": {
        "file_id": "ReceiverAcrossV3.sol",
        "timestamp": "2025-03-11T07:05:51.310107",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ReceiverAcrossV3": {
            "functions": 1,
            "state_variables": 0,
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ReceiverAcrossV3.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.310119"
    },
    "ReceiverStargateV2.sol": {
      "file_id": "ReceiverStargateV2.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "ReceiverStargateV2": {
            "name": "ReceiverStargateV2",
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery",
              "ILayerZeroComposer"
            ],
            "functions": {
              "_swapAndCompleteBridgeTokens": {
                "name": "_swapAndCompleteBridgeTokens",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "uint256 cacheGasLeft = gasleft();\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            if (cacheGasLeft < recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (cacheGasLeft < recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }"
              }
            },
            "state_variables": {
              "bridgedAssetId": {
                "name": "bridgedAssetId",
                "type": "address",
                "visibility": "internal",
                "initial_value": "IPool(_from).token()"
              },
              "cacheGasLeft": {
                "name": "cacheGasLeft",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "gasleft()"
              },
              "token": {
                "name": "token",
                "type": "IERC20",
                "visibility": "internal",
                "initial_value": "IERC20(assetId)"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { OFTComposeMsgCodec } from \"../Libraries/OFTComposeMsgCodec.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\nimport { ITokenMessaging } from \"../Interfaces/IStargate.sol\";\n\ninterface IPool {\n    function token() external view returns (address tokenAddress);\n}\n\ninterface ILayerZeroComposer {\n    /// @notice Composes a LayerZero message from an OApp.\n    /// @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n    /// @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n    /// @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n    /// @param _executor The address of the executor for the composed message.\n    /// @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n\n/// @title ReceiverStargateV2\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing via Stargate V2\n/// @custom:version 1.1.0\ncontract ReceiverStargateV2 is\n    ILiFi,\n    WithdrawablePeriphery,\n    ILayerZeroComposer\n{\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n    IExecutor public immutable executor;\n    ITokenMessaging public immutable tokenMessaging;\n    address public immutable endpointV2;\n    uint256 public immutable recoverGas;\n\n    /// Modifiers ///\n    modifier onlyEndpointV2() {\n        if (msg.sender != endpointV2) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _executor,\n        address _tokenMessaging,\n        address _endpointV2,\n        uint256 _recoverGas\n    ) WithdrawablePeriphery(_owner) {\n        executor = IExecutor(_executor);\n        tokenMessaging = ITokenMessaging(_tokenMessaging);\n        endpointV2 = _endpointV2;\n        recoverGas = _recoverGas;\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes a stargateV2 cross-chain transaction on the receiving chain\n    /// @dev This function is called by Stargate Router via LayerZero endpoint (sendCompose(...) function)\n    /// @param _from The address initiating the composition, typically the OApp where the lzReceive was called\n    /// @param * (unused) The unique identifier for the corresponding LayerZero src/dst tx\n    /// @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive\n    /// @param * (unused) The address of the executor for the composed message\n    /// @param * (unused) Additional arbitrary data in bytes passed by the entity who executes the lzCompose\n    function lzCompose(\n        address _from,\n        bytes32, // _guid (not used)\n        bytes calldata _message,\n        address, // _executor (not used)\n        bytes calldata // _extraData (not used)\n    ) external payable onlyEndpointV2 {\n        // verify that _from address is actually a Stargate pool by checking if Stargate's\n        // TokenMessaging contract has an assetId registered for this address\n        if (tokenMessaging.assetIds(_from) == 0) revert UnAuthorized();\n\n        // get the address of the token that was received from Stargate bridge\n        address bridgedAssetId = IPool(_from).token();\n\n        // decode payload\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver\n        ) = abi.decode(\n                OFTComposeMsgCodec.composeMsg(_message),\n                (bytes32, LibSwap.SwapData[], address)\n            );\n\n        // execute swap(s)\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            bridgedAssetId,\n            payable(receiver),\n            OFTComposeMsgCodec.amountLD(_message)\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId address of the token received from the source chain (not to be confused with StargateV2's assetIds which are uint16 values)\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) private {\n        uint256 cacheGasLeft = gasleft();\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            if (cacheGasLeft < recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                SafeTransferLib.safeTransferETH(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (cacheGasLeft < recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }\n\n    /// @notice Receive native asset directly.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "ReceiverStargateV2": {
          "_swapAndCompleteBridgeTokens": []
        }
      },
      "flow_data": {
        "ReceiverStargateV2": {
          "_swapAndCompleteBridgeTokens": {
            "name": "_swapAndCompleteBridgeTokens",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(assetId",
                "line": 3
              },
              {
                "type": "if",
                "condition": "cacheGasLeft < recoverGas",
                "line": 5
              },
              {
                "type": "if",
                "condition": "cacheGasLeft < recoverGas",
                "line": 42
              }
            ],
            "state_changes": [
              {
                "variable": "cacheGasLeft",
                "type": "uint256",
                "value": "gasleft()",
                "line": 1
              },
              {
                "variable": "token",
                "type": "IERC20",
                "value": "IERC20(assetId)",
                "line": 39
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "3": "if (LibAsset.isNativeAsset(assetId)",
              "5": "if (cacheGasLeft < recoverGas)",
              "42": "if (cacheGasLeft < recoverGas)",
              "1": "State Change: cacheGasLeft = gasleft()",
              "39": "State Change: token = IERC20(assetId)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "amount"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "ReceiverStargateV2": {
          "_swapAndCompleteBridgeTokens": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.308851"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.311407"
      },
      "final_report": {
        "file_id": "ReceiverStargateV2.sol",
        "timestamp": "2025-03-11T07:05:51.311431",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "ReceiverStargateV2": {
            "functions": 1,
            "state_variables": 3,
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery",
              "ILayerZeroComposer"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of ReceiverStargateV2.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.311444"
    },
    "RelayerCelerIM.sol": {
      "file_id": "RelayerCelerIM.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "RelayerCelerIM": {
            "name": "RelayerCelerIM",
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ],
            "functions": {
              "_swapAndCompleteBridgeTokens": {
                "name": "_swapAndCompleteBridgeTokens",
                "visibility": "private",
                "parameters": [
                  {
                    "type": "bytes32",
                    "name": "_transactionId"
                  },
                  {
                    "type": "LibSwap.SwapData[]",
                    "name": "_swapData"
                  },
                  {
                    "type": "address",
                    "name": "assetId"
                  },
                  {
                    "type": "address",
                    "name": "receiver"
                  },
                  {
                    "type": "uint256",
                    "name": "amount"
                  },
                  {
                    "type": "address",
                    "name": "refundAddress"
                  }
                ],
                "returns": [],
                "modifiers": [],
                "code": "bool success;\n        IExecutor executor = IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        );\n        if (LibAsset.isNativeAsset(assetId)) {\n            try\n                executor.swapAndCompleteBridgeTokens{ value: amount }(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                SafeTransferLib.safeTransferETH(refundAddress, amount);\n            }\n        } else {\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n            token.safeIncreaseAllowance(address(executor), amount);\n\n            try\n                executor.swapAndCompleteBridgeTokens(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                token.safeTransfer(refundAddress, amount);\n            }\n            token.safeApprove(address(executor), 0);\n        }\n\n        if (!success) {\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                refundAddress,\n                amount,\n                block.timestamp\n            );\n        }\n    }"
              }
            },
            "state_variables": {
              "cBridgeMessageBus": {
                "name": "cBridgeMessageBus",
                "type": "IMessageBus",
                "visibility": "public",
                "initial_value": null
              },
              "diamondAddress": {
                "name": "diamondAddress",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "success": {
                "name": "success",
                "type": "bool",
                "visibility": "internal",
                "initial_value": null
              },
              "executor": {
                "name": "executor",
                "type": "IExecutor",
                "visibility": "internal",
                "initial_value": "IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        )"
              },
              "token": {
                "name": "token",
                "type": "IERC20",
                "visibility": "internal",
                "initial_value": "IERC20(assetId)"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed, InvalidConfig, UnAuthorized, WithdrawFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { PeripheryRegistryFacet } from \"../Facets/PeripheryRegistryFacet.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { IMessageReceiverApp } from \"celer-network/contracts/message/interfaces/IMessageReceiverApp.sol\";\nimport { CelerIM } from \"lifi/Helpers/CelerIMFacetBase.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus, IOriginalTokenVault, IPeggedTokenBridge, IOriginalTokenVaultV2, IPeggedTokenBridgeV2 } from \"celer-network/contracts/message/libraries/MessageSenderLib.sol\";\nimport { IBridge as ICBridge } from \"celer-network/contracts/interfaces/IBridge.sol\";\n\n/// @title RelayerCelerIM\n/// @author LI.FI (https://li.fi)\n/// @notice Relayer contract for CelerIM that forwards calls and handles refunds on src side and acts receiver on dest\n/// @custom:version 2.1.1\ncontract RelayerCelerIM is ILiFi, WithdrawablePeriphery {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n\n    IMessageBus public cBridgeMessageBus;\n    address public diamondAddress;\n\n    /// Modifiers ///\n\n    modifier onlyCBridgeMessageBus() {\n        if (msg.sender != address(cBridgeMessageBus)) revert UnAuthorized();\n        _;\n    }\n    modifier onlyDiamond() {\n        if (msg.sender != diamondAddress) revert UnAuthorized();\n        _;\n    }\n\n    /// Constructor\n\n    constructor(\n        address _cBridgeMessageBusAddress,\n        address _owner,\n        address _diamondAddress\n    ) WithdrawablePeriphery(_owner) {\n        cBridgeMessageBus = IMessageBus(_cBridgeMessageBusAddress);\n        diamondAddress = _diamondAddress;\n    }\n\n    /// External Methods ///\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The Receiver is guaranteed to have received the right amount of tokens before this function is called.\n     * @param * (unused) The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param * (unused)  The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param * (unused)  Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address,\n        address _token,\n        uint256 _amount,\n        uint64,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        // decode message\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver,\n            address refundAddress\n        ) = abi.decode(\n                _message,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            _token,\n            payable(receiver),\n            _amount,\n            refundAddress\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param * (unused) Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        (bytes32 transactionId, , , address refundAddress) = abi.decode(\n            _message,\n            (bytes32, LibSwap.SwapData[], address, address)\n        );\n\n        // return funds to cBridgeData.refundAddress\n        LibAsset.transferAsset(_token, payable(refundAddress), _amount);\n\n        emit LiFiTransferRecovered(\n            transactionId,\n            _token,\n            refundAddress,\n            _amount,\n            block.timestamp\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Forwards a call to transfer tokens to cBridge (sent via this contract to ensure that potential refunds are sent here)\n     * @param _bridgeData the core information needed for bridging\n     * @param _celerIMData data specific to CelerIM\n     */\n    // solhint-disable-next-line code-complexity\n    function sendTokenTransfer(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        onlyDiamond\n        returns (bytes32 transferId, address bridgeAddress)\n    {\n        // approve to and call correct bridge depending on BridgeSendType\n        // @dev copied and slightly adapted from Celer MessageSenderLib\n        if (_celerIMData.bridgeType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridgeAddress = cBridgeMessageBus.liquidityBridge();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                ICBridge(bridgeAddress).sendNative{\n                    value: _bridgeData.minAmount\n                }(\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            } else {\n                // case: ERC20 asset bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                // solhint-disable-next-line check-send-result\n                ICBridge(bridgeAddress).send(\n                    _bridgeData.receiver,\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            }\n            transferId = MessageSenderLib.computeLiqBridgeTransferId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegDeposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVault();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IOriginalTokenVault(bridgeAddress).deposit(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1DepositId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegBurn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridge();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IPeggedTokenBridge(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1BurnId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Deposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVaultV2();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                transferId = IOriginalTokenVaultV2(bridgeAddress)\n                    .depositNative{ value: _bridgeData.minAmount }(\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            } else {\n                // case: ERC20 bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                transferId = IOriginalTokenVaultV2(bridgeAddress).deposit(\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            }\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Burn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType ==\n            MsgDataTypes.BridgeSendType.PegV2BurnFrom\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burnFrom(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else {\n            revert InvalidConfig();\n        }\n    }\n\n    /**\n     * @notice Forwards a call to the CBridge Messagebus\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function forwardSendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable onlyDiamond {\n        cBridgeMessageBus.sendMessageWithTransfer{ value: msg.value }(\n            _receiver,\n            _dstChainId,\n            _srcBridge,\n            _srcTransferId,\n            _message\n        );\n    }\n\n    // ------------------------------------------------------------------------------------------------\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        address refundAddress\n    ) private {\n        bool success;\n        IExecutor executor = IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        );\n        if (LibAsset.isNativeAsset(assetId)) {\n            try\n                executor.swapAndCompleteBridgeTokens{ value: amount }(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                SafeTransferLib.safeTransferETH(refundAddress, amount);\n            }\n        } else {\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n            token.safeIncreaseAllowance(address(executor), amount);\n\n            try\n                executor.swapAndCompleteBridgeTokens(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                token.safeTransfer(refundAddress, amount);\n            }\n            token.safeApprove(address(executor), 0);\n        }\n\n        if (!success) {\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                refundAddress,\n                amount,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        bool success;\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (\n            cBridgeMessageBus.liquidityBridge() != _callTo &&\n            cBridgeMessageBus.pegBridge() != _callTo &&\n            cBridgeMessageBus.pegBridgeV2() != _callTo &&\n            cBridgeMessageBus.pegVault() != _callTo &&\n            cBridgeMessageBus.pegVaultV2() != _callTo\n        ) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        // forward funds to _to address and emit event, if cBridge refund successful\n        if (success) {\n            address payable sendTo = payable(\n                (LibUtil.isZeroAddress(_to)) ? msg.sender : _to\n            );\n            LibAsset.transferAsset(_assetAddress, sendTo, _amount);\n            emit TokensWithdrawn(_assetAddress, sendTo, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    // required in order to receive native tokens from cBridge facet\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "RelayerCelerIM": {
          "_swapAndCompleteBridgeTokens": []
        }
      },
      "flow_data": {
        "RelayerCelerIM": {
          "_swapAndCompleteBridgeTokens": {
            "name": "_swapAndCompleteBridgeTokens",
            "visibility": "private",
            "control_structures": [
              {
                "type": "if",
                "condition": "LibAsset.isNativeAsset(assetId",
                "line": 7
              },
              {
                "type": "if",
                "condition": "!success",
                "line": 40
              }
            ],
            "state_changes": [
              {
                "variable": "success",
                "type": "bool",
                "value": "true",
                "line": 16
              },
              {
                "variable": "success",
                "type": "bool",
                "value": "true",
                "line": 33
              },
              {
                "variable": "executor",
                "type": "IExecutor",
                "value": "IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        )",
                "line": 2
              },
              {
                "variable": "token",
                "type": "IERC20",
                "value": "IERC20(assetId)",
                "line": 21
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "7": "if (LibAsset.isNativeAsset(assetId)",
              "40": "if (!success)",
              "16": "State Change: success = true",
              "33": "State Change: success = true",
              "2": "State Change: executor = IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        )",
              "21": "State Change: token = IERC20(assetId)"
            },
            "parameters": [
              {
                "type": "bytes32",
                "name": "_transactionId"
              },
              {
                "type": "LibSwap.SwapData[]",
                "name": "_swapData"
              },
              {
                "type": "address",
                "name": "assetId"
              },
              {
                "type": "address",
                "name": "receiver"
              },
              {
                "type": "uint256",
                "name": "amount"
              },
              {
                "type": "address",
                "name": "refundAddress"
              }
            ],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "RelayerCelerIM": {
          "_swapAndCompleteBridgeTokens": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.309772"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.311963"
      },
      "final_report": {
        "file_id": "RelayerCelerIM.sol",
        "timestamp": "2025-03-11T07:05:51.311984",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "RelayerCelerIM": {
            "functions": 1,
            "state_variables": 5,
            "inheritance": [
              "ILiFi",
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of RelayerCelerIM.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.311997"
    },
    "TokenWrapper.sol": {
      "file_id": "TokenWrapper.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "TokenWrapper": {
            "name": "TokenWrapper",
            "inheritance": [
              "WithdrawablePeriphery"
            ],
            "functions": {
              "deposit": {
                "name": "deposit",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "IWrapper(wrappedToken).deposit{ value: msg.value }();\n        IERC20(wrappedToken).transfer(msg.sender, msg.value);\n    }"
              },
              "withdraw": {
                "name": "withdraw",
                "visibility": "external",
                "parameters": [],
                "returns": [],
                "modifiers": [],
                "code": "// While in a general purpose contract it would make sense\n        // to have `wad` equal to the minimum between the balance and the\n        // given allowance, in our specific usecase allowance is always\n        // nearly MAX_UINT256. Using the balance only is a gas optimisation.\n        uint256 wad = IERC20(wrappedToken).balanceOf(msg.sender);\n        IERC20(wrappedToken).transferFrom(msg.sender, address(this), wad);\n        IWrapper(wrappedToken).withdraw(wad);\n        SafeTransferLib.safeTransferETH(msg.sender, wad);\n    }"
              }
            },
            "state_variables": {
              "wrappedToken": {
                "name": "wrappedToken",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              },
              "wad": {
                "name": "wad",
                "type": "uint256",
                "visibility": "internal",
                "initial_value": "IERC20(wrappedToken).balanceOf(msg.sender)"
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/// External wrapper interface\ninterface IWrapper {\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n}\n\n/// @title TokenWrapper\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for wrapping and unwrapping tokens\n/// @custom:version 1.1.0\ncontract TokenWrapper is WithdrawablePeriphery {\n    uint256 private constant MAX_INT = 2 ** 256 - 1;\n    address public wrappedToken;\n\n    /// Errors ///\n    error WithdrawFailure();\n\n    /// Constructor ///\n    // solhint-disable-next-line no-empty-blocks\n    constructor(\n        address _wrappedToken,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        wrappedToken = _wrappedToken;\n        IERC20(wrappedToken).approve(address(this), MAX_INT);\n    }\n\n    /// External Methods ///\n\n    /// @notice Wraps the native token\n    function deposit() external payable {\n        IWrapper(wrappedToken).deposit{ value: msg.value }();\n        IERC20(wrappedToken).transfer(msg.sender, msg.value);\n    }\n\n    /// @notice Unwraps all the caller's balance of wrapped token\n    function withdraw() external {\n        // While in a general purpose contract it would make sense\n        // to have `wad` equal to the minimum between the balance and the\n        // given allowance, in our specific usecase allowance is always\n        // nearly MAX_UINT256. Using the balance only is a gas optimisation.\n        uint256 wad = IERC20(wrappedToken).balanceOf(msg.sender);\n        IERC20(wrappedToken).transferFrom(msg.sender, address(this), wad);\n        IWrapper(wrappedToken).withdraw(wad);\n        SafeTransferLib.safeTransferETH(msg.sender, wad);\n    }\n\n    // Needs to be able to receive native on `withdraw`\n    receive() external payable {}\n}\n"
      },
      "call_graph": {
        "TokenWrapper": {
          "deposit": [],
          "withdraw": [
            {
              "contract": "TokenWrapper",
              "function": "withdraw"
            }
          ]
        }
      },
      "flow_data": {
        "TokenWrapper": {
          "deposit": {
            "name": "deposit",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {},
            "parameters": [],
            "returns": []
          },
          "withdraw": {
            "name": "withdraw",
            "visibility": "external",
            "control_structures": [],
            "state_changes": [
              {
                "variable": "wad",
                "type": "uint256",
                "value": "IERC20(wrappedToken).balanceOf(msg.sender)",
                "line": 5
              }
            ],
            "external_calls": [],
            "value_transfers": [],
            "condition_checks": [],
            "line_mapping": {
              "5": "State Change: wad = IERC20(wrappedToken).balanceOf(msg.sender)"
            },
            "parameters": [],
            "returns": []
          }
        }
      },
      "flow_paths": {
        "TokenWrapper": {
          "deposit": {
            "calls": [],
            "caller_of": [],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          },
          "withdraw": {
            "calls": [
              {
                "contract": "TokenWrapper",
                "function": "withdraw",
                "state_changes": [
                  {
                    "variable": "wad",
                    "type": "uint256",
                    "value": "IERC20(wrappedToken).balanceOf(msg.sender)",
                    "line": 5
                  }
                ],
                "external_calls": [],
                "value_transfers": []
              }
            ],
            "caller_of": [
              {
                "contract": "TokenWrapper",
                "function": "withdraw"
              }
            ],
            "state_dependencies": [],
            "value_flow": [],
            "path_conditions": []
          }
        }
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.316455"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.317620"
      },
      "final_report": {
        "file_id": "TokenWrapper.sol",
        "timestamp": "2025-03-11T07:05:51.317639",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "TokenWrapper": {
            "functions": 2,
            "state_variables": 2,
            "inheritance": [
              "WithdrawablePeriphery"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of TokenWrapper.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.317650"
    },
    "LiFiTimelockController.sol": {
      "file_id": "LiFiTimelockController.sol",
      "project_id": "src",
      "contract_data": {
        "contracts": {
          "LiFiTimelockController": {
            "name": "LiFiTimelockController",
            "inheritance": [
              "TimelockController"
            ],
            "functions": {},
            "state_variables": {
              "diamond": {
                "name": "diamond",
                "type": "address",
                "visibility": "public",
                "initial_value": null
              }
            },
            "modifiers": {},
            "events": {}
          }
        },
        "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { TimelockController } from \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\n/// @title LiFiTimelockController\n/// @author LI.FI (https://li.fi)\n/// @notice Custom version of Openzeppelin TimelockController to add timelock functionality for any diamondCuts on PROD diamonds\n/// @custom:version 1.0.0\n/// @notice Interface for diamond pause functionality\n/// @dev This interface defines the unpauseDiamond function that must be implemented by the diamond contract\ninterface EmergencyPause {\n    /// @notice Unpauses the diamond with specified blacklist\n    /// @param _blacklist Array of addresses to exclude from reactivation\n    function unpauseDiamond(address[] calldata _blacklist) external;\n}\n\ncontract LiFiTimelockController is TimelockController {\n    /// @notice The address of the diamond contract that this timelock controls\n    address public diamond;\n\n    /// @notice Emitted when the diamond address is updated\n    /// @param diamond The new diamond address\n    event DiamondAddressUpdated(address indexed diamond);\n\n    /// @param _minDelay Initial minimum delay for operations\n    /// @param _proposers Accounts to be granted proposer and canceller roles\n    /// @param _executors Accounts to be granted executor role\n    /// @param _admin The address that will be the admin of the TimelockController (= the LI.FI MultiSig SAFE)\n    constructor(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors,\n        address _admin,\n        address _diamond\n    ) TimelockController(_minDelay, _proposers, _executors, _admin) {\n        diamond = _diamond;\n        emit DiamondAddressUpdated(diamond);\n    }\n\n    /// @notice Updates the address of the diamond contract\n    /// @dev Can only be called by admin role or if the role is open (granted to address(0))\n    /// @param _diamond The new diamond address to set\n    function setDiamondAddress(\n        address _diamond\n    ) external onlyRole(TIMELOCK_ADMIN_ROLE) {\n        diamond = _diamond;\n        emit DiamondAddressUpdated(diamond);\n    }\n\n    /// @notice Unpauses the diamond contract by re-adding all facetAddress-to-function-selector mappings to storage\n    ///         This function bypasses the minDelay so that we are able to unpause our diamond without any minDelay\n    ///         The unpause function can only remove existing facets (blacklist), not add new code, therefore we consider this minDelay exception to be safe\n    /// @dev Can only be executed by the TimelockController admin (= the LI.FI MultiSig SAFE)\n    /// @param _blacklist The address(es) of facet(s) that should not be reactivated\n    /// @custom:security This function intentionally bypasses timelock delay for emergency unpausing\n    function unpauseDiamond(\n        address[] calldata _blacklist\n    ) external onlyRole(TIMELOCK_ADMIN_ROLE) {\n        // call the diamond directly (bypassing the minDelay)\n        EmergencyPause(diamond).unpauseDiamond(_blacklist);\n    }\n}\n"
      },
      "call_graph": {
        "LiFiTimelockController": {}
      },
      "flow_data": {
        "LiFiTimelockController": {}
      },
      "flow_paths": {
        "LiFiTimelockController": {}
      },
      "primary_analysis": {
        "raw_analysis": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "findings": [],
        "summary": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "flow_enhanced": true,
        "timestamp": "2025-03-11T07:05:51.315923"
      },
      "secondary_validation": {
        "raw_validation": "Analysis complete. The code contains several security vulnerabilities including reentrancy, missing access control, and unsafe use of tx.origin. Recommended fixes include implementing proper access controls, following the Checks-Effects-Interactions pattern, and using msg.sender instead of tx.origin.",
        "validations": [],
        "confirmation_stats": {
          "confirmed": 0,
          "false_positive": 0,
          "needs_info": 0,
          "total": 0
        },
        "missed_findings": [],
        "flow_enhanced": false,
        "timestamp": "2025-03-11T07:05:51.317307"
      },
      "final_report": {
        "file_id": "LiFiTimelockController.sol",
        "timestamp": "2025-03-11T07:05:51.317332",
        "risk_assessment": "Minimal Risk",
        "risk_text": "No significant security issues were found in the contract.",
        "severity_summary": {},
        "contract_info": {
          "LiFiTimelockController": {
            "functions": 0,
            "state_variables": 1,
            "inheritance": [
              "TimelockController"
            ]
          }
        },
        "findings": [],
        "finding_count": 0,
        "summary": "Analysis of LiFiTimelockController.sol: Minimal Risk. Found 0 validated issues (0 critical, 0 high, 0 medium, 0 low). No significant security issues were found in the contract."
      },
      "timestamp": "2025-03-11T07:05:51.317345"
    }
  },
  "timestamp": "2025-03-11T07:05:51.317716",
  "findings": [],
  "finding_count": 0,
  "severity_summary": {}
}