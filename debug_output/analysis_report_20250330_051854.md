# Smart Contract Analysis Report

Generated: 2025-03-30 05:34:04

## Overview

Analyzed 74 contract(s)

### LiFiDiamond
- File: `examples/src/LiFiDiamond.sol`
- Lines of code: 60

### ERC20Proxy
- File: `examples/src/Periphery/ERC20Proxy.sol`
- Lines of code: 37

### Executor
- File: `examples/src/Periphery/Executor.sol`
- Lines of code: 244

### FeeCollector
- File: `examples/src/Periphery/FeeCollector.sol`
- Lines of code: 174

### GasZipPeriphery
- File: `examples/src/Periphery/GasZipPeriphery.sol`
- Lines of code: 101

### LiFiDEXAggregator
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 727

### InputStream
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 127

### Approve
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 37

### RebaseLibrary
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 25

### LiFuelFeeCollector
- File: `examples/src/Periphery/LiFuelFeeCollector.sol`
- Lines of code: 90

### Permit2Proxy
- File: `examples/src/Periphery/Permit2Proxy.sol`
- Lines of code: 359

### Receiver
- File: `examples/src/Periphery/Receiver.sol`
- Lines of code: 252

### ReceiverAcrossV3
- File: `examples/src/Periphery/ReceiverAcrossV3.sol`
- Lines of code: 102

### ReceiverStargateV2
- File: `examples/src/Periphery/ReceiverStargateV2.sol`
- Lines of code: 173

### RelayerCelerIM
- File: `examples/src/Periphery/RelayerCelerIM.sol`
- Lines of code: 419

### TokenWrapper
- File: `examples/src/Periphery/TokenWrapper.sol`
- Lines of code: 40

### LiFiTimelockController
- File: `examples/src/Security/LiFiTimelockController.sol`
- Lines of code: 46

### CelerIMFacetBase
- File: `examples/src/Helpers/CelerIMFacetBase.sol`
- Lines of code: 216

### ExcessivelySafeCall
- File: `examples/src/Helpers/ExcessivelySafeCall.sol`
- Lines of code: 137

### ReentrancyGuard
- File: `examples/src/Helpers/ReentrancyGuard.sol`
- Lines of code: 45

### SwapperV2
- File: `examples/src/Helpers/SwapperV2.sol`
- Lines of code: 308

### TransferrableOwnership
- File: `examples/src/Helpers/TransferrableOwnership.sol`
- Lines of code: 51

### Validatable
- File: `examples/src/Helpers/Validatable.sol`
- Lines of code: 64

### WithdrawablePeriphery
- File: `examples/src/Helpers/WithdrawablePeriphery.sol`
- Lines of code: 27

### HopFacetPacked
- File: `examples/src/Facets/HopFacetPacked.sol`
- Lines of code: 704

### LIFuelFacet
- File: `examples/src/Facets/LIFuelFacet.sol`
- Lines of code: 104

### MayanFacet
- File: `examples/src/Facets/MayanFacet.sol`
- Lines of code: 291

### OmniBridgeFacet
- File: `examples/src/Facets/OmniBridgeFacet.sol`
- Lines of code: 90

### OptimismBridgeFacet
- File: `examples/src/Facets/OptimismBridgeFacet.sol`
- Lines of code: 193

### OwnershipFacet
- File: `examples/src/Facets/OwnershipFacet.sol`
- Lines of code: 80

### PeripheryRegistryFacet
- File: `examples/src/Facets/PeripheryRegistryFacet.sol`
- Lines of code: 48

### PolygonBridgeFacet
- File: `examples/src/Facets/PolygonBridgeFacet.sol`
- Lines of code: 98

### RelayFacet
- File: `examples/src/Facets/RelayFacet.sol`
- Lines of code: 217

### SquidFacet
- File: `examples/src/Facets/SquidFacet.sol`
- Lines of code: 193

### StandardizedCallFacet
- File: `examples/src/Facets/StandardizedCallFacet.sol`
- Lines of code: 66

### StargateFacet
- File: `examples/src/Facets/StargateFacet.sol`
- Lines of code: 270

### StargateFacetV2
- File: `examples/src/Facets/StargateFacetV2.sol`
- Lines of code: 145

### SymbiosisFacet
- File: `examples/src/Facets/SymbiosisFacet.sol`
- Lines of code: 132

### ThorSwapFacet
- File: `examples/src/Facets/ThorSwapFacet.sol`
- Lines of code: 107

### WithdrawFacet
- File: `examples/src/Facets/WithdrawFacet.sol`
- Lines of code: 78

### HopFacetOptimized
- File: `examples/src/Facets/HopFacetOptimized.sol`
- Lines of code: 258

### AccessManagerFacet
- File: `examples/src/Facets/AccessManagerFacet.sol`
- Lines of code: 41

### AcrossFacet
- File: `examples/src/Facets/AcrossFacet.sol`
- Lines of code: 123

### AcrossFacetPacked
- File: `examples/src/Facets/AcrossFacetPacked.sol`
- Lines of code: 370

### AcrossFacetPackedV3
- File: `examples/src/Facets/AcrossFacetPackedV3.sol`
- Lines of code: 385

### AcrossFacetV3
- File: `examples/src/Facets/AcrossFacetV3.sol`
- Lines of code: 161

### AllBridgeFacet
- File: `examples/src/Facets/AllBridgeFacet.sol`
- Lines of code: 115

### AmarokFacet
- File: `examples/src/Facets/AmarokFacet.sol`
- Lines of code: 148

### AmarokFacetPacked
- File: `examples/src/Facets/AmarokFacetPacked.sol`
- Lines of code: 354

### ArbitrumBridgeFacet
- File: `examples/src/Facets/ArbitrumBridgeFacet.sol`
- Lines of code: 139

### CBridgeFacet
- File: `examples/src/Facets/CBridgeFacet.sol`
- Lines of code: 154

### CBridgeFacetPacked
- File: `examples/src/Facets/CBridgeFacetPacked.sol`
- Lines of code: 315

### CalldataVerificationFacet
- File: `examples/src/Facets/CalldataVerificationFacet.sol`
- Lines of code: 521

### CelerCircleBridgeFacet
- File: `examples/src/Facets/CelerCircleBridgeFacet.sol`
- Lines of code: 95

### CelerIMFacetMutable
- File: `examples/src/Facets/CelerIMFacetMutable.sol`
- Lines of code: 15

### DeBridgeDlnFacet
- File: `examples/src/Facets/DeBridgeDlnFacet.sol`
- Lines of code: 257

### DexManagerFacet
- File: `examples/src/Facets/DexManagerFacet.sol`
- Lines of code: 136

### DiamondCutFacet
- File: `examples/src/Facets/DiamondCutFacet.sol`
- Lines of code: 16

### DiamondLoupeFacet
- File: `examples/src/Facets/DiamondLoupeFacet.sol`
- Lines of code: 78

### EmergencyPauseFacet
- File: `examples/src/Facets/EmergencyPauseFacet.sol`
- Lines of code: 222

### GasZipFacet
- File: `examples/src/Facets/GasZipFacet.sol`
- Lines of code: 126

### GenericSwapFacet
- File: `examples/src/Facets/GenericSwapFacet.sol`
- Lines of code: 44

### GenericSwapFacetV3
- File: `examples/src/Facets/GenericSwapFacetV3.sol`
- Lines of code: 555

### GnosisBridgeFacet
- File: `examples/src/Facets/GnosisBridgeFacet.sol`
- Lines of code: 80

### HopFacet
- File: `examples/src/Facets/HopFacet.sol`
- Lines of code: 181

### LibAccess
- File: `examples/src/Libraries/LibAccess.sol`
- Lines of code: 56

### LibAllowList
- File: `examples/src/Libraries/LibAllowList.sol`
- Lines of code: 100

### LibAsset
- File: `examples/src/Libraries/LibAsset.sol`
- Lines of code: 168

### LibBytes
- File: `examples/src/Libraries/LibBytes.sol`
- Lines of code: 122

### LibDiamond
- File: `examples/src/Libraries/LibDiamond.sol`
- Lines of code: 354

### LibDiamondLoupe
- File: `examples/src/Libraries/LibDiamondLoupe.sol`
- Lines of code: 48

### LibSwap
- File: `examples/src/Libraries/LibSwap.sol`
- Lines of code: 73

### LibUtil
- File: `examples/src/Libraries/LibUtil.sol`
- Lines of code: 27

### OFTComposeMsgCodec
- File: `examples/src/Libraries/OFTComposeMsgCodec.sol`
- Lines of code: 89

## Business Flow Analysis

### LiFiDiamond

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User sends tokens to the contract
- Contract receives tokens
- Contract processes the tokens

**Functions**:

- `receive`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- User sends a request to access the contract
- Contract checks user's permissions
- Contract grants or denies access

**Functions**:

- `fallback`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- User sends a request to update the state
- Contract checks user's permissions
- Contract updates the state

**Functions**:

- `fallback`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- User sends a request to make an external call
- Contract checks user's permissions
- Contract makes the external call

**Functions**:

- `fallback`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- User sends funds to the contract
- Contract receives funds
- Contract manages the funds

**Functions**:

- `receive`

### ERC20Proxy

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring ERC20 tokens from one address to another

**Steps**:

- Check if the sender is authorized
- Validate the token address, sender, receiver, and amount
- Execute the transfer using the ERC20 contract's transferFrom function

**Functions**:

- `transferFrom`

#### Authorization Flow

**Type**: general

**Description**: Flow responsible for setting whether or not a specified caller is authorized to call the contract

**Steps**:

- Check if the caller is the owner
- Update the authorized status for the caller in the mapping
- Emit an event indicating the change in authorization status

**Functions**:

- `setAuthorizedCaller`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the authorized callers state

**Steps**:

- Update the authorizedCallers mapping
- Emit an event indicating the change in authorization status

**Functions**:

- `setAuthorizedCaller`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for calling the ERC20 contract's transferFrom function

**Steps**:

- Check if the sender is authorized
- Call the transferFrom function of the ERC20 contract

**Functions**:

- `transferFrom`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the funds of the authorized callers

**Steps**:

- Check if the sender is authorized
- Transfer tokens from the sender to the receiver using the ERC20 contract

**Functions**:

- `transferFrom`

### Executor

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users and contracts

**Steps**:

- Fetch balances of tokens to be swapped
- Execute swaps one after the other
- Transfer leftover tokens to the receiver
- Transfer tokens to the receiver from the final asset

**Functions**:

- `_fetchBalances`
- `_executeSwaps`
- `LibAsset.transferAsset`
- `LibAsset.transferAsset`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Prevent calling ERC20 Proxy directly
- Check if deposit is approved
- Transfer tokens from sender to contract
- Transfer tokens from contract to receiver

**Functions**:

- `revert UnAuthorized`
- `IERC20(_transferredAssetId).allowance`
- `erc20Proxy.transferFrom`
- `LibAsset.depositAsset`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Update balances of tokens
- Update the final asset's balance
- Update the contract's state with the transaction id

**Functions**:

- `_processSwaps`
- `LibAsset.getOwnBalance`
- `emit LiFiTransferCompleted`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Make external calls to execute swaps
- Make external calls to transfer tokens

**Functions**:

- `LibSwap.swap`
- `LibAsset.transferAsset`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds in the contract

**Steps**:

- Receive funds from users
- Transfer funds to the receiver
- Transfer leftover tokens to the receiver

**Functions**:

- `receive`
- `LibAsset.transferAsset`
- `LibAsset.transferAsset`

### GasZipPeriphery

#### Token Transfer Flow

**Type**: general

**Description**: Transfer ERC20 tokens to native and deposit these native tokens in the GasZip router contract

**Steps**:

- LibAsset.depositAsset(_swapData.sendingAssetId, _swapData.fromAmount);
- LibAsset.maxApproveERC20(IERC20(_swapData.sendingAssetId), liFiDEXAggregator, _swapData.fromAmount);
- liFiDEXAggregator.call(_swapData.callData);
- depositToGasZipNative(_gasZipData, swapOutputAmount);

**Functions**:

- `depositToGasZipERC20`
- `depositToGasZipNative`

### FeeCollector

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens to integrators and Lifi

**Steps**:

- LibAsset.depositAsset(tokenAddress, integratorFee + lifiFee);
- _balances[integratorAddress][tokenAddress] += integratorFee;
- _lifiBalances[tokenAddress] += lifiFee;
- emit FeesCollected(tokenAddress, integratorAddress, integratorFee, lifiFee);

**Functions**:

- `collectTokenFees`
- `collectNativeFees`

### RebaseLibrary

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens based on the rebase calculations.

**Steps**:

- Calculate the base value using the toBase function
- Calculate the elastic value using the toElastic function
- Transfer tokens based on the calculated values

**Functions**:

- `toBase`
- `toElastic`

### InputStream

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- Smart contract receives the transfer request
- Smart contract checks the sender's balance
- Smart contract deducts the transferred amount from the sender's balance
- Smart contract adds the transferred amount to the recipient's balance
- Smart contract updates the token state
- Transaction is confirmed on the blockchain

**Functions**:

- `transfer`

### Approve

#### Token Transfer Approval

**Type**: general

**Description**: Approve the transfer of tokens from the user's account to a specified spender.

**Steps**:

- User calls the approve function with the token contract, spender, and amount.
- The contract checks if the token contract supports the approve function.
- The contract calls the token contract's approve function with the provided parameters.
- The contract checks if the approve function call was successful and returns a boolean value.

**Functions**:

- `approveStable`
- `approveSafe`

### Permit2Proxy

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens through a LI.FI diamond contract using EIP2612 gasless permit

**Steps**:

- Check if the token address implements EIP2612
- Verify the permit signature
- Register approval using the signature
- Deposit assets
- Max approve token to diamond if current allowance is insufficient
- Call the diamond to execute calldata

**Functions**:

- `callDiamondWithEIP2612Signature`

### LiFuelFeeCollector

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens to the contract and collecting gas fees

**Steps**:

- User initiates a token transfer to the contract
- Contract receives the token transfer
- Contract collects gas fees
- Gas fees are forwarded to the destination chain
- Gas fees are deposited into the contract

**Functions**:

- `collectTokenGasFees`
- `collectNativeGasFees`

#### Fee Withdrawal Flow

**Type**: general

**Description**: Flow responsible for withdrawing collected gas fees

**Steps**:

- Owner initiates a fee withdrawal request
- Contract checks the owner's balance
- Contract transfers the fees to the owner
- Owner receives the fees

**Functions**:

- `withdrawFees`
- `batchWithdrawFees`

### Receiver

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one chain to another

**Steps**:

- Receive tokens from Stargate Router
- Perform swap if necessary
- Complete bridge tokens transfer
- Send tokens to receiver address

**Functions**:

- `sgReceive`
- `swapAndCompleteBridgeTokens`
- `xReceive`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to contract functions

**Steps**:

- Check if sender is SG Router
- Check if sender is Amarok Router
- Check if sender has permission to execute the function

**Functions**:

- `onlySGRouter`
- `onlyAmarokRouter`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating contract state

**Steps**:

- Update SG Router address
- Update Amarok Router address
- Update Executor address
- Update recoverGas value

**Functions**:

- `constructor`
- `setRecoverGas`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Make external call to Executor
- Make external call to SafeTransferLib

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `safeTransferETH`
- `safeTransfer`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing contract funds

**Steps**:

- Receive funds from Stargate Router
- Receive funds from Amarok Router
- Send funds to receiver address

**Functions**:

- `sgReceive`
- `xReceive`

### ReceiverStargateV2

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the source chain to the destination chain

**Steps**:

- Verify that the sender address is a Stargate pool
- Decode the payload to get transaction ID, swap data, and receiver address
- Perform the swap and complete the bridge tokens transfer

**Functions**:

- `lzCompose`
- `_swapAndCompleteBridgeTokens`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Check if the sender is the endpointV2 address
- Execute the function if authorized, otherwise revert the transaction

**Functions**:

- `onlyEndpointV2`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state variables

**Steps**:

- Update the executor, tokenMessaging, endpointV2, and recoverGas state variables during contract initialization
- Update the contract's state variables during token transfer flow

**Functions**:

- `constructor`
- `lzCompose`
- `_swapAndCompleteBridgeTokens`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Call the LayerZero endpoint to initiate the cross-chain transaction
- Call the Executor contract to perform the swap and complete the bridge tokens transfer

**Functions**:

- `lzCompose`
- `_swapAndCompleteBridgeTokens`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the contract's funds

**Steps**:

- Receive native assets directly
- Transfer native assets to the receiver address
- Approve the Executor contract to spend the ERC20 tokens

**Functions**:

- `receive`
- `safeTransferETH`
- `safeApprove`

### ReceiverAcrossV3

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens across chains

**Steps**:

- Decoding the message payload to get transactionId, swapData, and receiver
- Executing the swap(s) using the provided swapData
- Completing the bridge tokens transfer to the receiver
- Resetting the approval for the executor

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `handleV3AcrossMessage`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Checking if the sender is the Spokepool
- Granting permission to the Spokepool to call the handleV3AcrossMessage function
- Restricting other actors from calling the handleV3AcrossMessage function

**Functions**:

- `onlySpokepool`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Updating the executor and spokepool addresses in the constructor
- Updating the approval for the executor in the _swapAndCompleteBridgeTokens function
- Resetting the approval for the executor after completing the bridge tokens transfer

**Functions**:

- `constructor`
- `_swapAndCompleteBridgeTokens`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Calling the executor's swapAndCompleteBridgeTokens function to execute the swap(s)
- Calling the assetId's safeTransfer function to send the bridged (and unswapped) funds to the receiver

**Functions**:

- `executor.swapAndCompleteBridgeTokens`
- `assetId.safeTransfer`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds in the contract

**Steps**:

- Receiving native assets directly
- Sending the bridged (and unswapped) funds to the receiver address

**Functions**:

- `receive`

### RelayerCelerIM

#### Token Transfer Execution

**Type**: general

**Description**: Execution of token transfer from the source chain to the destination chain via the Celer bridge

**Steps**:

- Decode the message received from the source app contract
- Execute the token transfer to the receiver address
- Complete the bridge tokens transfer

**Functions**:

- `executeMessageWithTransfer`
- `_swapAndCompleteBridgeTokens`

#### Token Transfer Refund

**Type**: general

**Description**: Refund of the original token transfer from the source chain

**Steps**:

- Decode the message received from the source app contract
- Refund the original transfer to the refund address
- Emit LiFiTransferRecovered event

**Functions**:

- `executeMessageWithTransferRefund`

#### Token Transfer Refund

**Type**: general

**Description**: Refund of the original token transfer from the source chain

**Steps**:

- Decode the message received from the source app contract
- Refund the original transfer to the refund address
- Emit LiFiTransferRecovered event

**Functions**:

- `executeMessageWithTransferRefund`

#### Token Transfer Refund

**Type**: general

**Description**: Refund of the original token transfer from the source chain

**Steps**:

- Decode the message received from the source app contract
- Refund the original transfer to the refund address
- Emit LiFiTransferRecovered event

**Functions**:

- `executeMessageWithTransferRefund`

#### Token Transfer Execution

**Type**: general

**Description**: Execution of token transfer from the source chain to the destination chain via the Celer bridge

**Steps**:

- Decode the message received from the source app contract
- Execute the token transfer to the receiver address
- Complete the bridge tokens transfer
- Emit LiFiTransferRecovered event

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `triggerRefund`

### LiFiTimelockController

#### Diamond Address Update

**Type**: general

**Description**: Update the address of the diamond contract

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role or if the role is open
- Update the diamond address
- Emit the DiamondAddressUpdated event

**Functions**:

- `setDiamondAddress`

#### Emergency Unpause Diamond

**Type**: general

**Description**: Unpause the diamond contract by re-adding facet mappings to storage

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role
- Call the EmergencyPause(diamond).unpauseDiamond function
- Bypass the minDelay for emergency unpausing

**Functions**:

- `unpauseDiamond`

### TokenWrapper

#### Token Deposit Flow

**Type**: general

**Description**: Flow where the user deposits native token to wrap it into the wrapped token.

**Steps**:

- The user sends a certain amount of native token to the contract.
- The contract receives the native token.
- The contract calls the `deposit` function to wrap the native token.
- The wrapped token is transferred back to the user.

**Functions**:

- `deposit`

#### Token Withdrawal Flow

**Type**: general

**Description**: Flow where the user withdraws the wrapped token and native token.

**Steps**:

- The user calls the `withdraw` function.
- The contract transfers the wrapped token from the user's balance to the contract.
- The contract calls the `withdraw` function of the wrapped token contract.
- The native token is transferred to the user.

**Functions**:

- `withdraw`

### CelerIMFacetBase

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the sender to the relayer

**Steps**:

- ERC20 token transfer from sender to relayer
- Relayer receives the transferred tokens

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functionalities

**Steps**:

- Validation of sender's address
- Validation of bridge data
- Validation of swap data

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state during token transfer

**Steps**:

- Updating relayer's balance
- Updating bridge data
- Updating destination call flag

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Forwarding message bus fee
- Calling message bus via relayer

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds during token transfer

**Steps**:

- Refunding excess native
- Sending funds to relayer

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

### ReentrancyGuard

#### Non-Reentrant Function Execution

**Type**: general

**Description**: Ensures that a function is not re-entered after an external call.

**Steps**:

- Check if the function has already been entered
- If entered, revert with ReentrancyError
- If not entered, mark the status as entered
- Execute the function
- Mark the status as not entered

**Functions**:

- `nonReentrant`

### ExcessivelySafeCall

#### Excessively Safe Call

**Type**: general

**Description**: This flow ensures that the called contract does not cause reversion of the caller by limiting the number of bytes that can be copied to the caller's memory.

**Steps**:

- Set up variables for the call
- Dispatch the message to the recipient using assembly call
- Limit the copy to 256 bytes
- Store the length of the copied bytes
- Copy the bytes from returndata

**Functions**:

- `excessivelySafeCall`
- `excessivelySafeStaticCall`

### SwapperV2

#### Token Transfer

**Type**: general

**Description**: Transfer tokens between users and the contract

**Steps**:

- User initiates a token transfer
- Contract receives the tokens
- Contract processes the tokens

**Functions**:

- `_depositAndSwap`
- `_depositAndSwapReserve`

#### Access Control

**Type**: general

**Description**: Control access to contract functions based on allowlists

**Steps**:

- Check if the sender is allowed to call the function
- Check if the receiver is allowed to receive tokens
- Check if the selector is allowed

**Functions**:

- `_executeSwaps`
- `_executeSwapsReserve`

#### State Transition

**Type**: general

**Description**: Update the contract's state after token transfers

**Steps**:

- Update token balances
- Update state variables

**Functions**:

- `_depositAndSwap`
- `_depositAndSwapReserve`

#### External Call

**Type**: general

**Description**: Make external calls to other contracts

**Steps**:

- Make an external call to a DEX
- Swap tokens

**Functions**:

- `_executeSwaps`
- `_executeSwapsReserve`

#### Fund Management

**Type**: general

**Description**: Manage funds received from token transfers

**Steps**:

- Receive funds
- Refund excess funds
- Reserve native tokens for fees

**Functions**:

- `_depositAndSwap`
- `_depositAndSwapReserve`
- `_refundExcessNative`

### WithdrawablePeriphery

#### Token Withdrawal Flow

**Type**: general

**Description**: Flow for withdrawing tokens from the contract

**Steps**:

- Check if the caller is the owner
- Verify if the asset is a native asset or not
- If native asset, call the receiver's address with the specified amount
- If not native asset, transfer the tokens to the receiver
- Emit the TokensWithdrawn event

**Functions**:

- `withdrawToken`

### TransferrableOwnership

#### Ownership Transfer Request

**Type**: general

**Description**: The process of requesting ownership transfer to a new address

**Steps**:

- Check if the sender is the owner
- Check if the new owner is not null
- Check if the new owner is not the sender
- Set the pending owner
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: The process of canceling the pending ownership transfer

**Steps**:

- Check if the sender is the owner
- Check if there is a pending owner
- Set the pending owner to null
- Revert NoPendingOwnershipTransfer error if there is no pending owner

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: The process of confirming the ownership transfer to the calling address

**Steps**:

- Check if the sender is the pending owner
- Set the owner to the pending owner
- Set the pending owner to null
- Emit OwnershipTransferred event

**Functions**:

- `confirmOwnershipTransfer`

### Validatable

#### Token Transfer Validation

**Type**: general

**Description**: Validates the token transfer data before allowing the transfer to proceed.

**Steps**:

- Check if the receiver address is zero
- Check if the minimum amount is zero
- Check if the destination chain ID is the same as the current chain ID

**Functions**:

- `validateBridgeData`

#### Native Asset Disallowance

**Type**: general

**Description**: Disallows the transfer of native assets.

**Steps**:

- Check if the sending asset ID is a native asset
- If yes, revert with an error

**Functions**:

- `noNativeAsset`

#### Source Token Validation

**Type**: general

**Description**: Validates if the sending token is the allowed source token.

**Steps**:

- Check if the sending asset ID matches the allowed source token
- If not, revert with an error

**Functions**:

- `onlyAllowSourceToken`

#### Destination Chain Validation

**Type**: general

**Description**: Validates if the destination chain ID is the allowed chain ID.

**Steps**:

- Check if the destination chain ID matches the allowed chain ID
- If not, revert with an error

**Functions**:

- `onlyAllowDestinationChain`

#### Source Swaps Validation

**Type**: general

**Description**: Validates if the bridge data contains source swaps.

**Steps**:

- Check if the bridge data has source swaps
- If not, revert with an error

**Functions**:

- `containsSourceSwaps`

#### Destination Calls Validation

**Type**: general

**Description**: Validates if the bridge data does not contain destination calls.

**Steps**:

- Check if the bridge data has destination calls
- If yes, revert with an error

**Functions**:

- `doesNotContainDestinationCalls`

### OmniBridgeFacet

#### Token Transfer via OmniBridge

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the OmniBridge

**Steps**:

- User initiates a token transfer request
- Token deposit and validation
- Performing swaps (if required)
- Starting the bridge process
- Relaying tokens via OmniBridge
- Emiting LiFiTransferStarted event

**Functions**:

- `startBridgeTokensViaOmniBridge`
- `swapAndStartBridgeTokensViaOmniBridge`

### OptimismBridgeFacet

#### Token Transfer via Optimism Bridge

**Type**: general

**Description**: Transfer tokens from L1 to L2 using the Optimism Bridge

**Steps**:

- Check if the contract is initialized
- Register the token and bridge if not initialized
- Deposit the required amount of tokens
- Perform any necessary swaps
- Bridge the tokens to L2

**Functions**:

- `initOptimism`
- `registerOptimismBridge`
- `startBridgeTokensViaOptimismBridge`
- `swapAndStartBridgeTokensViaOptimismBridge`

### OwnershipFacet

#### Ownership Transfer Request

**Type**: general

**Description**: Request for ownership transfer to a new address

**Steps**:

- Check if the caller is the contract owner
- Check if the new owner is not the same as the current owner
- Set the new owner address in storage
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: Cancel the pending ownership transfer

**Steps**:

- Check if the caller is the contract owner
- Check if there is a pending owner
- Reset the new owner address in storage

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: Confirm the transfer of ownership to the calling address

**Steps**:

- Check if the caller is the pending owner
- Transfer ownership to the caller
- Emit OwnershipTransferred event
- Set the new owner as the contract owner
- Reset the new owner address in storage

**Functions**:

- `confirmOwnershipTransfer`

#### Get Current Owner

**Type**: general

**Description**: Return the current owner address

**Steps**:

- Return the contract owner address

**Functions**:

- `owner`

### PolygonBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via the Polygon Bridge

**Steps**:

- User initiates a token transfer request
- Token deposit is made to the bridge contract
- Bridge contract performs necessary validations
- Token is bridged to the destination chain

**Functions**:

- `startBridgeTokensViaPolygonBridge`
- `swapAndStartBridgeTokensViaPolygonBridge`

### RelayFacet

#### Token Bridging via Relay

**Type**: general

**Description**: Bridging tokens from the current chain to a non-EVM chain via Relay

**Steps**:

- Validate the bridge data
- Check if the bridge quote is valid
- Perform any necessary swaps
- Deposit the required amount of tokens
- Start the bridging process

**Functions**:

- `startBridgeTokensViaRelay`
- `swapAndStartBridgeTokensViaRelay`

### PeripheryRegistryFacet

#### Register Periphery Contract

**Type**: general

**Description**: Register a periphery contract address with a specified name

**Steps**:

- Check if the caller is the contract owner
- Fetch local storage
- Store the contract address in the storage mapping
- Emit the PeripheryContractRegistered event

**Functions**:

- `registerPeripheryContract`

#### Get Periphery Contract

**Type**: general

**Description**: Return the registered contract address by its name

**Steps**:

- Fetch local storage
- Retrieve the contract address from the storage mapping

**Functions**:

- `getPeripheryContract`

### SquidFacet

#### Token Transfer via Squid Router

**Type**: general

**Description**: Transfer tokens through the Squid Router

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridge process

**Functions**:

- `startBridgeTokensViaSquid`
- `swapAndStartBridgeTokensViaSquid`

### StargateFacet

#### Token Transfer via Stargate Bridge

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Stargate Bridge

**Steps**:

- Validate the BridgeData and StargateData
- Quote the LayerZero fee
- Perform the token transfer
- Execute the destination call
- Refund any excess gas

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`

### StandardizedCallFacet

#### Standardized Call Flow

**Type**: general

**Description**: Flow to make a standardized call to a facet

**Steps**:

- Fetch the facetAddress from the diamond's internal storage
- Execute external function from facet using delegatecall
- Return any return value or error back to the caller

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

#### Token Transfer Flow

**Type**: general

**Description**: Flow to transfer tokens

**Steps**:

- Make a standardized call to transfer tokens
- Delegatecall to the facet to execute the transfer
- Return any return value or error back to the caller

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

### SymbiosisFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the contract for bridging

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _symbiosisData);

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `_startBridge`

#### Swap and Transfer Flow

**Type**: general

**Description**: Perform swaps before transferring tokens for bridging

**Steps**:

- _depositAndSwap(_bridgeData.transactionId, _bridgeData.minAmount, _swapData, payable(msg.sender));
- _startBridge(_bridgeData, _symbiosisData);

**Functions**:

- `swapAndStartBridgeTokensViaSymbiosis`
- `_startBridge`

#### Symbiosis Bridge Flow

**Type**: general

**Description**: Bridge tokens via Symbiosis

**Steps**:

- symbiosisMetaRouter.metaRoute{...}(ISymbiosisMetaRouter.MetaRouteTransaction(...));
- emit LiFiTransferStarted(_bridgeData);

**Functions**:

- `_startBridge`

### ThorSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to ThorSwap contract for bridging

**Steps**:

- Sender sends tokens to ThorSwap contract
- ThorSwap contract receives tokens
- ThorSwap contract processes the tokens for bridging

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### Access Control Flow

**Type**: general

**Description**: Control access to the ThorSwap contract functions

**Steps**:

- ThorSwap contract checks if the sender has enough balance
- ThorSwap contract checks if the bridge data is valid
- ThorSwap contract checks if the bridge data does not contain source swaps
- ThorSwap contract checks if the bridge data does not contain destination calls

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the ThorSwap contract during token bridging

**Steps**:

- ThorSwap contract updates the bridge data
- ThorSwap contract updates the ThorSwap data
- ThorSwap contract emits LiFiTransferStarted event

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts during token bridging

**Steps**:

- ThorSwap contract calls LibAsset to deposit asset
- ThorSwap contract calls LibAsset to approve ERC20 token
- ThorSwap contract calls IThorSwap to depositWithExpiry

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`
- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds received during token bridging

**Steps**:

- ThorSwap contract receives funds from sender
- ThorSwap contract refunds excess native tokens

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

### StargateFacetV2

#### Token Transfer via Stargate

**Type**: general

**Description**: Transfer tokens from the sender to the Stargate Bridge

**Steps**:

- Validate the bridge data
- Deposit the asset
- Start the bridge process

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`

#### Swap and Transfer via Stargate

**Type**: general

**Description**: Perform a swap before transferring tokens via Stargate Bridge

**Steps**:

- Validate the bridge data
- Perform the swap
- Deposit the asset
- Start the bridge process

**Functions**:

- `swapAndStartBridgeTokensViaStargate`

#### Access Control

**Type**: general

**Description**: Control access to the contract's functions

**Steps**:

- Check if the sender has enough balance
- Check if the sender has the required allowance
- Check if the destination call flag is valid
- Check if the receiver addresses match

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`

#### State Transition

**Type**: general

**Description**: Update the contract's state during the token transfer process

**Steps**:

- Update the bridge data
- Update the send params
- Update the state in the Stargate router

**Functions**:

- `_startBridge`

#### External Call

**Type**: general

**Description**: Make external calls to the Stargate router

**Steps**:

- Get the router address
- Execute the call to the Stargate router

**Functions**:

- `_startBridge`

#### Fund Management

**Type**: general

**Description**: Manage the contract's funds during the token transfer process

**Steps**:

- Refund excess native tokens
- Send native tokens to the Stargate router
- Approve the router to spend ERC20 tokens

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`
- `_startBridge`

### AccessManagerFacet

#### Access Control Flow

**Type**: general

**Description**: Manage access control for specific addresses and methods

**Steps**:

- Check if the caller is the contract owner
- Check if the executor is allowed to execute the method
- Add or remove access for the executor
- Emit an event based on the execution status

**Functions**:

- `setCanExecute`
- `addressCanExecuteMethod`

### WithdrawFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the contract to an external address

**Steps**:

- Check if the sender has access control
- Verify if the recipient is a contract
- Execute the provided call data
- Withdraw the specified amount of tokens to the recipient address

**Functions**:

- `executeCallAndWithdraw`
- `withdraw`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for enforcing access control rules

**Steps**:

- Check if the sender is the contract owner
- Enforce access control if the sender is not the contract owner

**Functions**:

- `enforceAccessControl`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract state

**Steps**:

- Update the contract state upon successful token transfer
- Emit a LogWithdraw event with the updated state

**Functions**:

- `_withdrawAsset`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for executing external calls

**Steps**:

- Execute the provided call data on the specified address
- Handle the result of the external call

**Functions**:

- `executeCallAndWithdraw`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the contract's funds

**Steps**:

- Transfer tokens to the recipient address
- Update the contract state accordingly

**Functions**:

- `_withdrawAsset`

### HopFacetOptimized

#### ERC20 Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 1 to Layer 2 using the Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swap (if required)
- Bridge ERC20 tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1ERC20`
- `swapAndStartBridgeTokensViaHopL1ERC20`

#### Native Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging native tokens from Layer 1 to Layer 2 using the Hop Protocol

**Steps**:

- Bridge native tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1Native`
- `swapAndStartBridgeTokensViaHopL1Native`

#### ERC20 Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 2 to Layer 1 using the Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swap (if required)
- Bridge ERC20 tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2ERC20`
- `swapAndStartBridgeTokensViaHopL2ERC20`

#### Native Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging native tokens from Layer 2 to Layer 1 using the Hop Protocol

**Steps**:

- Bridge native tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2Native`
- `swapAndStartBridgeTokensViaHopL2Native`

#### Approval for Hop Bridges

**Type**: general

**Description**: Approving Hop Bridges to spend specified tokens

**Steps**:

- Check if caller is contract owner
- Iterate through the list of Hop Bridges
- Approve each Hop Bridge to spend tokens

**Functions**:

- `setApprovalForBridges`

### AcrossFacetPackedV3

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one chain to another

**Steps**:

- ERC20 tokens are transferred from the sender to the contract
- Contract calls the Across Spoke Pool to bridge the tokens
- Tokens are transferred to the recipient on the destination chain

**Functions**:

- `startBridgeTokensViaAcrossV3ERC20Packed`
- `startBridgeTokensViaAcrossV3NativePacked`
- `startBridgeTokensViaAcrossV3ERC20Min`
- `executeCallAndWithdraw`

### AcrossFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one chain to another using the Across bridge

**Steps**:

- User initiates a token transfer by calling the startBridgeTokensViaAcrossNativePacked or startBridgeTokensViaAcrossERC20Packed function
- The contract extracts the necessary data from the calldata
- The contract deposits the tokens into the Across bridge
- The tokens are bridged to the destination chain
- The tokens are received by the recipient address

**Functions**:

- `startBridgeTokensViaAcrossNativePacked`
- `startBridgeTokensViaAcrossERC20Packed`

### AcrossFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the bridge contract and then to the destination chain.

**Steps**:

- Sender sends tokens to the bridge contract.
- Bridge contract validates the transaction and checks the relayer fee.
- Bridge contract deposits the tokens to the spoke pool on the source chain.
- Spoke pool on the source chain bridges the tokens to the destination chain.
- Tokens are received on the destination chain.

**Functions**:

- `startBridgeTokensViaAcross`
- `swapAndStartBridgeTokensViaAcross`

#### Access Control Flow

**Type**: general

**Description**: Controls access to external methods and ensures only authorized users can perform certain actions.

**Steps**:

- Validation of the bridge data.
- Checking if the transaction contains source swaps.
- Checking if the transaction contains destination calls.
- Ensuring the sender has enough balance to cover the transaction.
- Preventing reentrancy attacks.

**Functions**:

- `startBridgeTokensViaAcross`
- `swapAndStartBridgeTokensViaAcross`

#### State Transition Flow

**Type**: general

**Description**: Updates the state of the contract based on the external method calls.

**Steps**:

- Updating the bridge data with the deposited amount.
- Updating the spoke pool's state after bridging the tokens.
- Updating the state after emitting the LiFiTransferStarted event.

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Makes external calls to other contracts to perform certain actions.

**Steps**:

- Depositing tokens to the spoke pool on the source chain.
- Approving the spoke pool to spend tokens on behalf of the sender.
- Bridging the tokens to the destination chain.

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manages the funds received from the sender and ensures they are used correctly.

**Steps**:

- Refunding excess native tokens to the sender.
- Depositing the tokens to the spoke pool on the source chain.
- Bridging the tokens to the destination chain.

**Functions**:

- `startBridgeTokensViaAcross`
- `swapAndStartBridgeTokensViaAcross`

### AmarokFacet

#### Token Transfer via Amarok

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Amarok bridge

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridge transaction

**Functions**:

- `startBridgeTokensViaAmarok`
- `swapAndStartBridgeTokensViaAmarok`

### AcrossFacetV3

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the source chain to the destination chain via the AcrossFacetV3 contract

**Steps**:

- User initiates a token transfer request
- Contract validates the transfer request
- Contract performs necessary swaps (if required)
- Contract deposits the tokens to the spoke pool
- Spoke pool processes the transfer to the destination chain

**Functions**:

- `startBridgeTokensViaAcrossV3`
- `swapAndStartBridgeTokensViaAcrossV3`

### AllBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via AllBridge

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _allBridgeData);

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`
- `_startBridge`

#### Access Control Flow

**Type**: general

**Description**: Control access to the AllBridge contract functions

**Steps**:

- external payable nonReentrant
- containsSourceSwaps(_bridgeData)
- doesNotContainDestinationCalls(_bridgeData)
- validateBridgeData(_bridgeData)

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the AllBridge contract

**Steps**:

- LibAsset.maxApproveERC20(...);
- allBridge.swapAndBridge(...);
- emit LiFiTransferStarted(_bridgeData);

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts

**Steps**:

- allBridge.swapAndBridge(...);

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds for the AllBridge contract

**Steps**:

- refundExcessNative(payable(msg.sender))
- pay the relayer fee with the sending asset or not

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`
- `_startBridge`

### ArbitrumBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via Arbitrum Bridge

**Steps**:

- User initiates the token transfer by calling startBridgeTokensViaArbitrumBridge or swapAndStartBridgeTokensViaArbitrumBridge
- The contract calculates the cost of the transfer based on the maxSubmissionCost and maxGasPrice
- The contract deposits the required amount of native asset into the bridge
- The contract performs the actual token transfer to the destination chain
- The contract emits the LiFiTransferStarted event to indicate the start of the transfer

**Functions**:

- `startBridgeTokensViaArbitrumBridge`
- `swapAndStartBridgeTokensViaArbitrumBridge`

### AmarokFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Transfer ERC20 tokens from the sender to the contract, then bridge them to another chain

**Steps**:

- Sender sends ERC20 tokens to the contract
- Contract approves the Amarok bridge to spend the tokens
- Contract bridges the tokens to another chain using the Amarok bridge
- Tokens are received by the receiver on the destination chain

**Functions**:

- `setApprovalForBridge`
- `startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset`
- `startBridgeTokensViaAmarokERC20PackedPayFeeWithNative`
- `startBridgeTokensViaAmarokERC20MinPayFeeWithAsset`
- `startBridgeTokensViaAmarokERC20MinPayFeeWithNative`

#### External Call Flow

**Type**: general

**Description**: External call to the Amarok bridge to bridge ERC20 tokens

**Steps**:

- Contract calls the Amarok bridge's xcall function
- Amarok bridge processes the token bridge request

**Functions**:

- `connextHandler.xcall`

### CBridgeFacet

#### Token bridging via CBridge

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via CBridge

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _cBridgeData);

**Functions**:

- `startBridgeTokensViaCBridge`
- `_startBridge`

#### Token bridging with swaps via CBridge

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via CBridge after performing swaps

**Steps**:

- _depositAndSwap(_bridgeData.transactionId, _bridgeData.minAmount, _swapData, payable(msg.sender));
- _startBridge(_bridgeData, _cBridgeData);

**Functions**:

- `swapAndStartBridgeTokensViaCBridge`
- `_startBridge`

#### Triggering CBridge refund

**Type**: general

**Description**: Triggering a refund from CBridge

**Steps**:

- LibAccess.enforceAccessControl();
- cBridge.sendNative{ value: _bridgeData.minAmount }(...);
- emit CBridgeRefund(_assetAddress, sendTo, _amount);

**Functions**:

- `triggerRefund`

### CelerCircleBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via CelerCircleBridge

**Steps**:

- LibAsset.depositAsset(usdc, _bridgeData.minAmount);
- _startBridge(_bridgeData);
- circleBridgeProxy.depositForBurn(...);

**Functions**:

- `startBridgeTokensViaCelerCircleBridge`
- `swapAndStartBridgeTokensViaCelerCircleBridge`
- `_startBridge`

### CBridgeFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- ERC20 token transfer from sender to contract
- Contract receives tokens and triggers a cBridge transfer
- cBridge transfers tokens to the destination address

**Functions**:

- `ERC20(sendingAssetId).safeTransferFrom`
- `cBridge.send`

#### Approval Flow

**Type**: general

**Description**: Flow responsible for setting approval for the CBridge Router to spend the specified token

**Steps**:

- Owner calls setApprovalForBridge function
- Function iterates through tokensToApprove array
- LibAsset.maxApproveERC20 sets approval for each token

**Functions**:

- `setApprovalForBridge`

#### Refund Flow

**Type**: general

**Description**: Flow responsible for triggering a cBridge refund

**Steps**:

- Owner calls triggerRefund function
- Function checks if _callTo is a valid cBridge address
- Contract calls _callTo with _callData
- If call is successful, contract refunds the funds and emits an event

**Functions**:

- `triggerRefund`

#### Bridge Native Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging native tokens via cBridge

**Steps**:

- Owner calls startBridgeTokensViaCBridgeNativePacked function
- Function sends native tokens to cBridge
- cBridge bridges native tokens to the destination chain

**Functions**:

- `startBridgeTokensViaCBridgeNativePacked`

#### Bridge ERC20 Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging ERC20 tokens via cBridge

**Steps**:

- Owner calls startBridgeTokensViaCBridgeERC20Packed function
- Function deposits ERC20 tokens to the contract
- Contract bridges ERC20 tokens to the destination chain

**Functions**:

- `startBridgeTokensViaCBridgeERC20Packed`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds received by the contract

**Steps**:

- Contract receives funds through the receive() external payable function
- Funds can be used for refunds or bridging

**Functions**:

- `receive()`

### CelerIMFacetMutable

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- RelayerCelerIM contract receives the request
- RelayerCelerIM contract verifies the request
- RelayerCelerIM contract executes the transfer
- CelerIMFacetMutable contract updates the state

**Functions**:

- `transfer`

### DeBridgeDlnFacet

#### Token bridging via DeBridgeDLN

**Type**: general

**Description**: Bridging tokens from one chain to another using DeBridgeDLN

**Steps**:

- Validate bridge data
- Perform swap (if necessary)
- Deposit asset
- Create DLN order
- Execute bridge

**Functions**:

- `startBridgeTokensViaDeBridgeDln`
- `swapAndStartBridgeTokensViaDeBridgeDln`

### DexManagerFacet

#### Add DEX to allowlist

**Type**: general

**Description**: Add a DEX contract address to the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add the DEX contract address to the allowlist
- Emit the DexAdded event

**Functions**:

- `addDex`

#### Batch add DEXs to allowlist

**Type**: general

**Description**: Batch add multiple DEX contract addresses to the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of DEX contract addresses
- For each address, check if it is the contract itself, if so, revert
- If not, check if it is already in the allowlist, if so, continue
- If not, add the DEX contract address to the allowlist
- Emit the DexAdded event for each added address

**Functions**:

- `batchAddDex`

#### Remove DEX from allowlist

**Type**: general

**Description**: Remove a DEX contract address from the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Remove the DEX contract address from the allowlist
- Emit the DexRemoved event

**Functions**:

- `removeDex`

#### Batch remove DEXs from allowlist

**Type**: general

**Description**: Batch remove multiple DEX contract addresses from the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of DEX contract addresses
- For each address, remove it from the allowlist
- Emit the DexRemoved event for each removed address

**Functions**:

- `batchRemoveDex`

#### Set function approval

**Type**: general

**Description**: Add or remove a specific function signature to/from the allowlist

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add or remove the function signature to/from the allowlist based on approval
- Emit the FunctionSignatureApprovalChanged event

**Functions**:

- `setFunctionApprovalBySignature`

#### Batch set function approval

**Type**: general

**Description**: Batch add or remove multiple function signatures to/from the allowlist

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of function signatures
- For each signature, add or remove it to/from the allowlist based on approval
- Emit the FunctionSignatureApprovalChanged event for each signature

**Functions**:

- `batchSetFunctionApprovalBySignature`

#### Check function approval

**Type**: general

**Description**: Check if a specific function signature is approved

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Return whether the function signature is approved

**Functions**:

- `isFunctionApproved`

#### Get approved DEXs

**Type**: general

**Description**: Return a list of all approved DEX contract addresses

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Return the list of all approved DEX contract addresses

**Functions**:

- `approvedDexs`

### DiamondCutFacet

#### Diamond Cut Facet Execution

**Type**: general

**Description**: Execution of the diamond cut operation, which allows adding, replacing, or removing functions and optionally executing a function with delegatecall.

**Steps**:

- LibDiamond.enforceIsContractOwner();
- LibDiamond.diamondCut(_diamondCut, _init, _calldata);

**Functions**:

- `diamondCut`

### EmergencyPauseFacet

#### Emergency Pause Flow

**Type**: general

**Description**: Flow that allows pausing the diamond contract by redirecting all function selectors to the EmergencyPauseFacet.

**Steps**:

- The pauser or owner calls the `pauseDiamond()` function.
- The `pauseDiamond()` function redirects all function selectors to the EmergencyPauseFacet.
- Third parties trying to call the diamond will receive a meaningful error message.

**Functions**:

- `pauseDiamond`

#### Facet Removal Flow

**Type**: general

**Description**: Flow that allows removing a facet from the diamond.

**Steps**:

- The pauser or owner calls the `removeFacet()` function with the address of the facet to be removed.
- The `removeFacet()` function removes the facet and its function selectors from the diamond.
- The removed facet can be reactivated later.

**Functions**:

- `removeFacet`

#### Diamond Unpause Flow

**Type**: general

**Description**: Flow that allows unpawning the diamond contract by reactivating all facets.

**Steps**:

- The owner calls the `unpauseDiamond()` function with the addresses of the facets to be blacklisted.
- The `unpauseDiamond()` function reactivates all facets except the ones in the blacklist.
- The diamond contract is now unpawned and all facets are reactivated.

**Functions**:

- `unpauseDiamond`

### DiamondLoupeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request and verifies the sender's balance
- Smart contract deducts the transferred amount from the sender's balance
- Smart contract adds the transferred amount to the recipient's balance
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to different functions based on user roles

**Steps**:

- User sends a request to access a specific function
- Smart contract checks the user's role and permissions
- Smart contract grants or denies access based on the user's role and permissions
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `supportsInterface`
- `facetAddress`
- `facets`
- `facetFunctionSelectors`
- `facetAddresses`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's internal state

**Steps**:

- User sends a request to update the contract's state
- Smart contract validates the request and checks for any conditions
- Smart contract updates the contract's state
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `supportsInterface`
- `facetAddress`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Smart contract receives a request to make an external call
- Smart contract verifies the target contract and function
- Smart contract executes the external call
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `facetAddress`
- `facets`
- `facetFunctionSelectors`
- `facetAddresses`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds within the contract

**Steps**:

- User sends funds to the contract
- Smart contract receives the funds and updates the contract's balance
- Smart contract allocates funds for various purposes
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

### GasZipFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens via the GasZipFacet

**Steps**:

- Check if the asset is native
- Validate the bridge data
- Deposit native to Gas.zip
- Start bridging process

**Functions**:

- `startBridgeTokensViaGasZip`
- `swapAndStartBridgeTokensViaGasZip`
- `_startBridge`

### GenericSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to the contract and then to the receiver after performing swaps

**Steps**:

- Sender sends tokens to the contract
- Contract checks if the receiver address is valid
- Contract performs swaps using the provided swap data
- Contract transfers the post-swap balance to the receiver
- Contract emits an event indicating the completion of the swap

**Functions**:

- `swapTokensGeneric`

#### Access Control Flow

**Type**: general

**Description**: Ensure that only authorized actors can perform the swap operation

**Steps**:

- Sender sends a request to perform a swap
- Contract checks if the sender is authorized
- Contract checks if the receiver address is valid
- Contract performs the swap operation if authorized

**Functions**:

- `swapTokensGeneric`

#### State Transition Flow

**Type**: general

**Description**: Update the contract state after performing the swap operation

**Steps**:

- Sender sends a request to perform a swap
- Contract checks if the sender is authorized
- Contract updates the state after performing the swap
- Contract emits an event indicating the completion of the swap

**Functions**:

- `swapTokensGeneric`

#### External Call Flow

**Type**: general

**Description**: Perform external calls to perform swaps

**Steps**:

- Sender sends a request to perform a swap
- Contract checks if the sender is authorized
- Contract performs external calls to perform swaps
- Contract updates the state after performing the swap

**Functions**:

- `swapTokensGeneric`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds received from sender and transfer excess funds to the receiver

**Steps**:

- Sender sends tokens to the contract
- Contract checks if the receiver address is valid
- Contract transfers excess funds to the receiver
- Contract emits an event indicating the completion of the swap

**Functions**:

- `swapTokensGeneric`

### GnosisBridgeFacet

#### Token bridging flow

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via XDaiBridge

**Steps**:

- Validate bridge data
- Check destination chain
- Deposit source token
- Perform swap (if required)
- Relay tokens via XDaiBridge
- Start bridging process

**Functions**:

- `startBridgeTokensViaXDaiBridge`
- `swapAndStartBridgeTokensViaXDaiBridge`

### LibAccess

#### Granting Access

**Type**: general

**Description**: Granting permission to an address to execute a specific method

**Steps**:

- Fetch the local storage
- Check if the executor is the contract itself
- Add permission to execute the method
- Emit the AccessGranted event

**Functions**:

- `addAccess`

#### Revoking Access

**Type**: general

**Description**: Revoking permission from an address to execute a specific method

**Steps**:

- Fetch the local storage
- Remove permission to execute the method
- Emit the AccessRevoked event

**Functions**:

- `removeAccess`

#### Enforcing Access Control

**Type**: general

**Description**: Revert if the sender does not have permission to execute the method

**Steps**:

- Fetch the local storage
- Check if the sender has permission to execute the method
- Revert if permission is not granted

**Functions**:

- `enforceAccessControl`

### HopFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens via Hop Protocol

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _hopData);

**Functions**:

- `startBridgeTokensViaHop`
- `_startBridge`

#### Swap and Transfer Flow

**Type**: general

**Description**: Flow responsible for performing swaps before transferring tokens via Hop Protocol

**Steps**:

- _bridgeData.minAmount = _depositAndSwap(_bridgeData.transactionId, _bridgeData.minAmount, _swapData, payable(msg.sender), _hopData.nativeFee);
- _startBridge(_bridgeData, _hopData);

**Functions**:

- `swapAndStartBridgeTokensViaHop`
- `_startBridge`

#### Bridge Registration Flow

**Type**: general

**Description**: Flow responsible for registering token and bridge

**Steps**:

- LibDiamond.enforceIsContractOwner();
- s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);
- emit HopBridgeRegistered(assetId, bridge);

**Functions**:

- `initHop`
- `registerBridge`

### LibBytes

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract validates the request
- Token transfer is executed

**Functions**:

- `transfer`

### LibAllowList

#### Add Contract to Allow List

**Type**: general

**Description**: Add a contract address to the allow list

**Steps**:

- Check if the contract address is valid
- Check if the contract address is already in the allow list
- Add the contract address to the allow list

**Functions**:

- `addAllowedContract`

#### Remove Contract from Allow List

**Type**: general

**Description**: Remove a contract address from the allow list

**Steps**:

- Check if the contract address is in the allow list
- Remove the contract address from the allow list

**Functions**:

- `removeAllowedContract`

#### Add Selector to Allow List

**Type**: general

**Description**: Add a selector to the allow list

**Steps**:

- Add the selector to the allow list

**Functions**:

- `addAllowedSelector`

#### Remove Selector from Allow List

**Type**: general

**Description**: Remove a selector from the allow list

**Steps**:

- Remove the selector from the allow list

**Functions**:

- `removeAllowedSelector`

#### Check if Contract is Allowed

**Type**: general

**Description**: Check if a contract address has been added to the allow list

**Steps**:

- Check if the contract address is in the allow list

**Functions**:

- `contractIsAllowed`

#### Get All Allowed Contracts

**Type**: general

**Description**: Fetch contract addresses from the allow list

**Steps**:

- Return the list of allowed contracts

**Functions**:

- `getAllowedContracts`

### LibAsset

#### Token Transfer

**Type**: general

**Description**: Transfer tokens from the contract to a recipient

**Steps**:

- Check if the recipient address is NULL_ADDRESS
- Check if the amount exceeds the contract's balance
- Transfer the tokens using the recipient's address and the specified amount

**Functions**:

- `transferERC20`
- `transferNativeAsset`

#### Access Control

**Type**: general

**Description**: Control the access to the contract's functions

**Steps**:

- Check if the sender is NULL_ADDRESS
- Check if the recipient is NULL_ADDRESS
- Check if the amount exceeds the contract's balance

**Functions**:

- `transferERC20`
- `transferNativeAsset`
- `maxApproveERC20`

#### State Transition

**Type**: general

**Description**: Update the contract's state variables

**Steps**:

- Update the balance of the contract
- Update the allowance for a spender
- Update the state variables for the deposited assets

**Functions**:

- `depositAsset`
- `depositAssets`
- `maxApproveERC20`

#### External Call

**Type**: general

**Description**: Make external calls to other contracts

**Steps**:

- Check if the recipient is a contract
- Make the external call to the recipient's address

**Functions**:

- `transferNativeAsset`

#### Fund Management

**Type**: general

**Description**: Manage the contract's funds

**Steps**:

- Transfer funds to the contract
- Transfer funds from the contract

**Functions**:

- `depositAsset`
- `depositAssets`
- `transferERC20`
- `transferNativeAsset`

### LibSwap

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- Check if the provided address is a contract
- Get the balance of the sending asset
- Check if the balance is sufficient for the transfer
- Approve the transfer if necessary
- Execute the transfer
- Update the balances of the involved assets
- Emit the AssetSwapped event

**Functions**:

- `swap`

### LibDiamondLoupe

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens within the system

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request and verifies the sender's permissions
- Smart contract updates the token balances and state
- Token transfer is executed

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to different functions and resources

**Steps**:

- User requests access to a specific function or resource
- Smart contract verifies the user's permissions and identity
- Access is granted or denied based on the verification results

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the state of the smart contract

**Steps**:

- User initiates a state update request
- Smart contract verifies the request and the sender's permissions
- Smart contract updates the state accordingly
- State update is executed

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Smart contract receives a request to make an external call
- Smart contract verifies the request and the sender's permissions
- Smart contract makes the external call
- External call result is processed

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds within the system

**Steps**:

- User deposits or withdraws funds
- Smart contract updates the balances and state accordingly
- Funds are transferred to or from the smart contract

**Functions**:

- `transfer`

### LibDiamond

#### Diamond Facet Addition

**Type**: general

**Description**: Add a new facet to the diamond

**Steps**:

- Check if the facet address is zero
- Add the facet address to the facet addresses array
- Add the facet address position to the facetFunctionSelectors array
- Add the facet address to the selectorToFacetAndPosition mapping

**Functions**:

- `addFacet`
- `addFunction`

#### Diamond Facet Replacement

**Type**: general

**Description**: Replace an existing facet with a new one

**Steps**:

- Check if the facet address is zero
- Remove the functions from the old facet
- Add the functions from the new facet
- Add the new facet address to the facet addresses array
- Add the new facet address position to the facetFunctionSelectors array
- Add the new facet address to the selectorToFacetAndPosition mapping

**Functions**:

- `replaceFunctions`
- `addFacet`
- `addFunction`

#### Diamond Facet Removal

**Type**: general

**Description**: Remove a facet from the diamond

**Steps**:

- Check if the facet address is not zero
- Remove the functions from the facet
- Remove the facet address from the facet addresses array
- Remove the facet address position from the facetFunctionSelectors array
- Remove the facet address from the selectorToFacetAndPosition mapping

**Functions**:

- `removeFunctions`
- `removeFunction`

#### Diamond Initialization

**Type**: general

**Description**: Initialize the diamond with a new facet

**Steps**:

- Check if the init address is zero
- Delegatecall to the init address with the calldata
- Update the contract owner if necessary

**Functions**:

- `initializeDiamondCut`
- `setContractOwner`

#### Ownership Transfer

**Type**: general

**Description**: Transfer ownership of the contract

**Steps**:

- Check if the new owner is not zero
- Update the contract owner
- Emit the OwnershipTransferred event

**Functions**:

- `setContractOwner`

### OFTComposeMsgCodec

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request
- Smart contract validates the request
- Smart contract executes the transfer
- Transfer is confirmed

**Functions**:

- `encode`
- `nonce`
- `srcEid`
- `amountLD`
- `composeFrom`
- `composeMsg`

### LibUtil

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- Token transfer request received
- Validation of sender and recipient addresses
- Token transfer execution
- Revert message generation and handling

**Functions**:

- `revertWith`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- Access request received
- Validation of sender address
- Access grant or deny decision
- Revert message generation and handling

**Functions**:

- `isZeroAddress`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract state

**Steps**:

- State update request received
- Validation of sender address
- State update execution
- Revert message generation and handling

**Functions**:

- `revertWith`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- External call request received
- Validation of sender address
- External call execution
- Revert message generation and handling

**Functions**:

- `revertWith`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- Fund management request received
- Validation of sender address
- Fund management execution
- Revert message generation and handling

**Functions**:

- `revertWith`

## Cognitive Bias Analysis

### GasZipPeriphery

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LiFiDEXAggregator

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### Permit2Proxy

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### RelayerCelerIM

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### TransferrableOwnership

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### WithdrawFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPackedV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### GenericSwapFacetV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LibDiamond

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

## Recommendations

Based on the analysis, consider the following recommendations:

- No specific recommendations available from the analysis

## Debug Information

This report was generated as part of the debugging process.
- Pipeline executed at: 2025-03-30 05:34:04
- Input directory: examples/src
- Output directory: debug_output