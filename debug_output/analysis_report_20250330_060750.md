# Smart Contract Analysis Report

Generated: 2025-03-30 06:23:00

## Overview

Analyzed 74 contract(s)

### LiFiDiamond
- File: `examples/src/LiFiDiamond.sol`
- Lines of code: 60

### ERC20Proxy
- File: `examples/src/Periphery/ERC20Proxy.sol`
- Lines of code: 37

### Executor
- File: `examples/src/Periphery/Executor.sol`
- Lines of code: 244

### FeeCollector
- File: `examples/src/Periphery/FeeCollector.sol`
- Lines of code: 174

### GasZipPeriphery
- File: `examples/src/Periphery/GasZipPeriphery.sol`
- Lines of code: 101

### LiFiDEXAggregator
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 727

### InputStream
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 127

### Approve
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 37

### RebaseLibrary
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 25

### LiFuelFeeCollector
- File: `examples/src/Periphery/LiFuelFeeCollector.sol`
- Lines of code: 90

### Permit2Proxy
- File: `examples/src/Periphery/Permit2Proxy.sol`
- Lines of code: 359

### Receiver
- File: `examples/src/Periphery/Receiver.sol`
- Lines of code: 252

### ReceiverAcrossV3
- File: `examples/src/Periphery/ReceiverAcrossV3.sol`
- Lines of code: 102

### ReceiverStargateV2
- File: `examples/src/Periphery/ReceiverStargateV2.sol`
- Lines of code: 173

### RelayerCelerIM
- File: `examples/src/Periphery/RelayerCelerIM.sol`
- Lines of code: 419

### TokenWrapper
- File: `examples/src/Periphery/TokenWrapper.sol`
- Lines of code: 40

### LiFiTimelockController
- File: `examples/src/Security/LiFiTimelockController.sol`
- Lines of code: 46

### CelerIMFacetBase
- File: `examples/src/Helpers/CelerIMFacetBase.sol`
- Lines of code: 216

### ExcessivelySafeCall
- File: `examples/src/Helpers/ExcessivelySafeCall.sol`
- Lines of code: 137

### ReentrancyGuard
- File: `examples/src/Helpers/ReentrancyGuard.sol`
- Lines of code: 45

### SwapperV2
- File: `examples/src/Helpers/SwapperV2.sol`
- Lines of code: 308

### TransferrableOwnership
- File: `examples/src/Helpers/TransferrableOwnership.sol`
- Lines of code: 51

### Validatable
- File: `examples/src/Helpers/Validatable.sol`
- Lines of code: 64

### WithdrawablePeriphery
- File: `examples/src/Helpers/WithdrawablePeriphery.sol`
- Lines of code: 27

### HopFacetPacked
- File: `examples/src/Facets/HopFacetPacked.sol`
- Lines of code: 704

### LIFuelFacet
- File: `examples/src/Facets/LIFuelFacet.sol`
- Lines of code: 104

### MayanFacet
- File: `examples/src/Facets/MayanFacet.sol`
- Lines of code: 291

### OmniBridgeFacet
- File: `examples/src/Facets/OmniBridgeFacet.sol`
- Lines of code: 90

### OptimismBridgeFacet
- File: `examples/src/Facets/OptimismBridgeFacet.sol`
- Lines of code: 193

### OwnershipFacet
- File: `examples/src/Facets/OwnershipFacet.sol`
- Lines of code: 80

### PeripheryRegistryFacet
- File: `examples/src/Facets/PeripheryRegistryFacet.sol`
- Lines of code: 48

### PolygonBridgeFacet
- File: `examples/src/Facets/PolygonBridgeFacet.sol`
- Lines of code: 98

### RelayFacet
- File: `examples/src/Facets/RelayFacet.sol`
- Lines of code: 217

### SquidFacet
- File: `examples/src/Facets/SquidFacet.sol`
- Lines of code: 193

### StandardizedCallFacet
- File: `examples/src/Facets/StandardizedCallFacet.sol`
- Lines of code: 66

### StargateFacet
- File: `examples/src/Facets/StargateFacet.sol`
- Lines of code: 270

### StargateFacetV2
- File: `examples/src/Facets/StargateFacetV2.sol`
- Lines of code: 145

### SymbiosisFacet
- File: `examples/src/Facets/SymbiosisFacet.sol`
- Lines of code: 132

### ThorSwapFacet
- File: `examples/src/Facets/ThorSwapFacet.sol`
- Lines of code: 107

### WithdrawFacet
- File: `examples/src/Facets/WithdrawFacet.sol`
- Lines of code: 78

### HopFacetOptimized
- File: `examples/src/Facets/HopFacetOptimized.sol`
- Lines of code: 258

### AccessManagerFacet
- File: `examples/src/Facets/AccessManagerFacet.sol`
- Lines of code: 41

### AcrossFacet
- File: `examples/src/Facets/AcrossFacet.sol`
- Lines of code: 123

### AcrossFacetPacked
- File: `examples/src/Facets/AcrossFacetPacked.sol`
- Lines of code: 370

### AcrossFacetPackedV3
- File: `examples/src/Facets/AcrossFacetPackedV3.sol`
- Lines of code: 385

### AcrossFacetV3
- File: `examples/src/Facets/AcrossFacetV3.sol`
- Lines of code: 161

### AllBridgeFacet
- File: `examples/src/Facets/AllBridgeFacet.sol`
- Lines of code: 115

### AmarokFacet
- File: `examples/src/Facets/AmarokFacet.sol`
- Lines of code: 148

### AmarokFacetPacked
- File: `examples/src/Facets/AmarokFacetPacked.sol`
- Lines of code: 354

### ArbitrumBridgeFacet
- File: `examples/src/Facets/ArbitrumBridgeFacet.sol`
- Lines of code: 139

### CBridgeFacet
- File: `examples/src/Facets/CBridgeFacet.sol`
- Lines of code: 154

### CBridgeFacetPacked
- File: `examples/src/Facets/CBridgeFacetPacked.sol`
- Lines of code: 315

### CalldataVerificationFacet
- File: `examples/src/Facets/CalldataVerificationFacet.sol`
- Lines of code: 521

### CelerCircleBridgeFacet
- File: `examples/src/Facets/CelerCircleBridgeFacet.sol`
- Lines of code: 95

### CelerIMFacetMutable
- File: `examples/src/Facets/CelerIMFacetMutable.sol`
- Lines of code: 15

### DeBridgeDlnFacet
- File: `examples/src/Facets/DeBridgeDlnFacet.sol`
- Lines of code: 257

### DexManagerFacet
- File: `examples/src/Facets/DexManagerFacet.sol`
- Lines of code: 136

### DiamondCutFacet
- File: `examples/src/Facets/DiamondCutFacet.sol`
- Lines of code: 16

### DiamondLoupeFacet
- File: `examples/src/Facets/DiamondLoupeFacet.sol`
- Lines of code: 78

### EmergencyPauseFacet
- File: `examples/src/Facets/EmergencyPauseFacet.sol`
- Lines of code: 222

### GasZipFacet
- File: `examples/src/Facets/GasZipFacet.sol`
- Lines of code: 126

### GenericSwapFacet
- File: `examples/src/Facets/GenericSwapFacet.sol`
- Lines of code: 44

### GenericSwapFacetV3
- File: `examples/src/Facets/GenericSwapFacetV3.sol`
- Lines of code: 555

### GnosisBridgeFacet
- File: `examples/src/Facets/GnosisBridgeFacet.sol`
- Lines of code: 80

### HopFacet
- File: `examples/src/Facets/HopFacet.sol`
- Lines of code: 181

### LibAccess
- File: `examples/src/Libraries/LibAccess.sol`
- Lines of code: 56

### LibAllowList
- File: `examples/src/Libraries/LibAllowList.sol`
- Lines of code: 100

### LibAsset
- File: `examples/src/Libraries/LibAsset.sol`
- Lines of code: 168

### LibBytes
- File: `examples/src/Libraries/LibBytes.sol`
- Lines of code: 122

### LibDiamond
- File: `examples/src/Libraries/LibDiamond.sol`
- Lines of code: 354

### LibDiamondLoupe
- File: `examples/src/Libraries/LibDiamondLoupe.sol`
- Lines of code: 48

### LibSwap
- File: `examples/src/Libraries/LibSwap.sol`
- Lines of code: 73

### LibUtil
- File: `examples/src/Libraries/LibUtil.sol`
- Lines of code: 27

### OFTComposeMsgCodec
- File: `examples/src/Libraries/OFTComposeMsgCodec.sol`
- Lines of code: 89

## Business Flow Analysis

### Executor

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users and contracts

**Steps**:

- Fetch balances of tokens to be swapped
- Execute swaps one after the other
- Transfer leftover tokens to the receiver
- Transfer tokens to the receiver from the final asset

**Functions**:

- `_fetchBalances`
- `_executeSwaps`
- `LibAsset.transferAsset`
- `LibAsset.transferAsset`

### LiFiDiamond

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User sends tokens to the contract
- Contract receives tokens
- Contract processes the tokens

**Functions**:

- `receive`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- User sends a request to access the contract
- Contract checks user's permissions
- Contract grants or denies access

**Functions**:

- `fallback`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- User sends a request to update the state
- Contract checks user's permissions
- Contract updates the state

**Functions**:

- `fallback`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- User sends a request to make an external call
- Contract checks user's permissions
- Contract makes the external call

**Functions**:

- `fallback`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- User sends funds to the contract
- Contract receives funds
- Contract manages the funds

**Functions**:

- `receive`

### ERC20Proxy

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring ERC20 tokens from one address to another

**Steps**:

- Check if the sender is authorized
- Validate the token address, sender, receiver, and amount
- Transfer tokens using the ERC20 contract's transferFrom function

**Functions**:

- `transferFrom`

#### Authorization Flow

**Type**: general

**Description**: Flow responsible for setting whether or not a specified caller is authorized

**Steps**:

- Check if the caller is the owner
- Set the authorized status for the caller
- Emit the AuthorizationChanged event

**Functions**:

- `setAuthorizedCaller`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the authorized callers mapping

**Steps**:

- Check if the caller is the owner
- Update the authorized status for the caller
- Emit the AuthorizationChanged event

**Functions**:

- `setAuthorizedCaller`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for calling the ERC20 contract's transferFrom function

**Steps**:

- Check if the sender is authorized
- Call the transferFrom function of the ERC20 contract

**Functions**:

- `transferFrom`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the authorized callers

**Steps**:

- Set the authorized status for the caller
- Manage the authorized callers mapping

**Functions**:

- `setAuthorizedCaller`

### GasZipPeriphery

#### Token Transfer Flow

**Type**: general

**Description**: Transfer ERC20 tokens to native and deposit these native tokens in the GasZip router contract

**Steps**:

- Deposit ERC20 asset from diamond
- Max approve ERC20 to DEX
- Execute swap using LiFiDEXAggregator
- Deposit native tokens to Gas.zip protocol

**Functions**:

- `depositToGasZipERC20`
- `depositToGasZipNative`

### FeeCollector

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens to integrators and lifi

**Steps**:

- Collecting fees for the integrator
- Collecting fees for lifi
- Withdrawing fees from integrator
- Withdrawing fees from lifi

**Functions**:

- `collectTokenFees`
- `collectNativeFees`
- `withdrawIntegratorFees`
- `batchWithdrawIntegratorFees`
- `withdrawLifiFees`
- `batchWithdrawLifiFees`

### RebaseLibrary

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens between users

**Steps**:

- User A sends tokens to User B
- Smart contract receives the transaction
- Smart contract processes the transfer

**Functions**:

- `toBase`
- `toElastic`

### Approve

#### Token Transfer Approval

**Type**: general

**Description**: Approve the transfer of tokens from the user's account to a specified spender.

**Steps**:

- User calls the approve function with the token contract, spender, and amount.
- The contract checks if the token contract supports the approve function.
- The contract calls the token contract's approve function with the provided parameters.
- The contract checks if the approve function call was successful and returns a boolean value.

**Functions**:

- `approveStable`
- `approveSafe`

### InputStream

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- Smart contract receives the transfer request
- Smart contract checks if the sender has enough tokens
- Smart contract deducts the tokens from the sender's balance
- Smart contract adds the tokens to the recipient's balance
- Transaction is confirmed and tokens are transferred

**Functions**:

- `transfer`

### ReceiverStargateV2

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the source chain to the destination chain

**Steps**:

- Verify that the sender address is a Stargate pool
- Decode the payload to get transaction ID, swap data, and receiver address
- Execute swaps
- Complete the cross-chain transaction

**Functions**:

- `lzCompose`
- `_swapAndCompleteBridgeTokens`

### ReceiverAcrossV3

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens across chains

**Steps**:

- Decoding the message payload
- Executing swaps
- Transferring tokens to the receiver address

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `handleV3AcrossMessage`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- Checking if the sender is the Spokepool
- Executing the function if authorized
- Reverting the transaction if unauthorized

**Functions**:

- `onlySpokepool`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Updating the executor and Spokepool addresses
- Resetting the approval for the executor

**Functions**:

- `constructor`
- `_swapAndCompleteBridgeTokens`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Approving the executor to spend tokens
- Swapping tokens and completing the bridge transaction
- Transferring tokens to the receiver address

**Functions**:

- `executor.swapAndCompleteBridgeTokens`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- Receiving native assets directly
- Transferring bridged and unswapped funds to the receiver address

**Functions**:

- `receive`

### RelayerCelerIM

#### Token Transfer Execution

**Type**: general

**Description**: Execution of token transfer from the source chain to the destination chain via the Celer bridge

**Steps**:

- Decode the message received from the source app contract
- Execute the token transfer to the receiver address
- Complete the bridge tokens transfer

**Functions**:

- `executeMessageWithTransfer`
- `_swapAndCompleteBridgeTokens`

### LiFiTimelockController

#### Diamond Address Update

**Type**: general

**Description**: Update the address of the diamond contract

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role or if the role is open
- Update the diamond address
- Emit the DiamondAddressUpdated event

**Functions**:

- `setDiamondAddress`

#### Unpause Diamond

**Type**: general

**Description**: Unpause the diamond contract by re-adding facetAddress-to-function-selector mappings

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role
- Call the EmergencyPause(diamond).unpauseDiamond function
- Bypass the minDelay for emergency unpausing

**Functions**:

- `unpauseDiamond`

### TokenWrapper

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users and the contract

**Steps**:

- User deposits native token into the contract
- Contract wraps the native token
- Contract transfers wrapped token to the user
- User withdraws wrapped token from the contract

**Functions**:

- `deposit()`
- `withdraw()`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Contract checks if the caller has permission to execute the function
- Contract allows or denies the function execution based on access control rules

**Functions**:

- `deposit()`
- `withdraw()`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Contract receives a deposit or withdraw request
- Contract updates its internal state accordingly
- Contract reflects the state changes externally

**Functions**:

- `deposit()`
- `withdraw()`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Contract calls the external contract to wrap or unwrap tokens
- External contract performs the requested action
- Contract receives the result of the external call

**Functions**:

- `deposit()`
- `withdraw()`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the contract's funds

**Steps**:

- Contract receives native tokens from users
- Contract wraps the received tokens
- Contract transfers wrapped tokens to users
- Contract transfers wrapped tokens to other contracts

**Functions**:

- `deposit()`
- `withdraw()`

### CelerIMFacetBase

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the sender to the relayer

**Steps**:

- ERC20 token transfer from sender to relayer
- Relayer receives the transferred tokens

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functionalities

**Steps**:

- Validation of sender's address
- Validation of bridge data
- Validation of swap data

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Updating relayer address
- Updating bridge data
- Updating token balances

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Forwarding message bus fee
- Calling message bus via relayer

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- Refunding excess native
- Forwarding native asset amount

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`

### ReentrancyGuard

#### Non-Reentrant Function Execution

**Type**: general

**Description**: Ensures that a function is not called recursively

**Steps**:

- Check if the function has already been entered
- If entered, revert with ReentrancyError
- If not entered, mark the status as entered
- Execute the function
- Mark the status as not entered

**Functions**:

- `nonReentrant`

### ExcessivelySafeCall

#### Excessively Safe Call

**Type**: general

**Description**: A secure call function that limits the number of bytes that the callee can cause to be copied to caller memory.

**Steps**:

- Check the maximum number of bytes to copy
- Call the target contract using assembly
- Copy the return data to a new bytes memory
- Limit the number of bytes copied to the maximum allowed
- Return the success and the limited return data

**Functions**:

- `excessivelySafeCall`

#### Excessively Safe Static Call

**Type**: general

**Description**: A secure static call function that limits the number of bytes that the callee can cause to be copied to caller memory.

**Steps**:

- Check the maximum number of bytes to copy
- Call the target contract using assembly
- Copy the return data to a new bytes memory
- Limit the number of bytes copied to the maximum allowed
- Return the success and the limited return data

**Functions**:

- `excessivelySafeStaticCall`

#### Swap Selector

**Type**: general

**Description**: A function that swaps out the first 4 bytes of a contract call buffer with a new selector.

**Steps**:

- Check the length of the buffer
- Create a mask to isolate the first word
- Apply the new selector to the first word
- Store the modified buffer

**Functions**:

- `swapSelector`

### SwapperV2

#### Token Transfer

**Type**: general

**Description**: Transfer of tokens between users and the contract

**Steps**:

- User initiates a swap
- Contract receives tokens
- Contract executes swaps
- Contract transfers leftover tokens back to user

**Functions**:

- `_depositAndSwap`
- `_executeSwaps`

#### Access Control

**Type**: general

**Description**: Control over which contracts and functions can be used

**Steps**:

- Check if contract is allowed
- Check if selector is allowed
- Execute function

**Functions**:

- `_executeSwaps`

#### State Transition

**Type**: general

**Description**: Update of contract state after token transfer

**Steps**:

- Update token balances
- Update swap data
- Update leftover receiver

**Functions**:

- `_executeSwaps`

#### External Call

**Type**: general

**Description**: Interaction with external contracts

**Steps**:

- Check if external call is allowed
- Execute external call
- Handle external call result

**Functions**:

- `_executeSwaps`

#### Fund Management

**Type**: general

**Description**: Management of funds received by the contract

**Steps**:

- Receive funds
- Execute swaps
- Refund excess funds

**Functions**:

- `_depositAndSwap`
- `_executeSwaps`
- `refundExcessNative`

### WithdrawablePeriphery

#### Token Withdrawal Flow

**Type**: general

**Description**: Flow for withdrawing tokens from the contract

**Steps**:

- Check if the caller is the owner
- Verify if the asset is a native asset or not
- If native asset, call the receiver's address with the specified amount
- If not a native asset, transfer the tokens to the receiver
- Emit the TokensWithdrawn event

**Functions**:

- `withdrawToken`

### TransferrableOwnership

#### Ownership Transfer Request

**Type**: general

**Description**: The process of requesting ownership transfer to a new address

**Steps**:

- Check if the sender is the owner
- Check if the new owner is not null
- Check if the new owner is not the sender
- Set the pending owner
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: The process of canceling the pending ownership transfer

**Steps**:

- Check if the sender is the owner
- Check if there is a pending owner
- Set the pending owner to null
- Revert NoPendingOwnershipTransfer error if there is no pending owner

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: The process of confirming the ownership transfer to the calling address

**Steps**:

- Check if the sender is the pending owner
- Set the owner to the pending owner
- Set the pending owner to null
- Emit OwnershipTransferred event

**Functions**:

- `confirmOwnershipTransfer`

### Validatable

#### Token Transfer Validation

**Type**: general

**Description**: Validates the token transfer data before allowing the transfer to proceed.

**Steps**:

- Check if the receiver address is zero
- Check if the minimum amount is zero
- Check if the destination chain ID is the same as the current chain ID

**Functions**:

- `validateBridgeData`

#### Native Asset Validation

**Type**: general

**Description**: Checks if the sending asset is a native asset and prevents its use in the transfer.

**Steps**:

- Check if the sending asset is a native asset
- If yes, revert the transaction with an error message

**Functions**:

- `noNativeAsset`

#### Source Token Validation

**Type**: general

**Description**: Ensures that the sending token matches the specified token.

**Steps**:

- Check if the sending asset ID matches the specified token
- If not, revert the transaction with an error message

**Functions**:

- `onlyAllowSourceToken`

#### Destination Chain Validation

**Type**: general

**Description**: Verifies that the destination chain ID matches the specified chain ID.

**Steps**:

- Check if the destination chain ID matches the specified chain ID
- If not, revert the transaction with an error message

**Functions**:

- `onlyAllowDestinationChain`

#### Source Swaps Validation

**Type**: general

**Description**: Checks if the bridge data contains source swaps.

**Steps**:

- Check if the bridge data has source swaps
- If not, revert the transaction with an error message

**Functions**:

- `containsSourceSwaps`

#### Destination Calls Validation

**Type**: general

**Description**: Ensures that the bridge data does not contain destination calls.

**Steps**:

- Check if the bridge data has destination calls
- If yes, revert the transaction with an error message

**Functions**:

- `doesNotContainDestinationCalls`

### OmniBridgeFacet

#### Token bridging via OmniBridge

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via OmniBridge

**Steps**:

- User initiates the bridging process
- Contract checks if the user has sufficient funds
- Contract deposits the required amount of tokens
- Contract performs any necessary swaps
- Contract starts the bridging process via OmniBridge
- OmniBridge relays the tokens to the destination chain

**Functions**:

- `startBridgeTokensViaOmniBridge`
- `swapAndStartBridgeTokensViaOmniBridge`

### OptimismBridgeFacet

#### Token Transfer via Optimism Bridge

**Type**: general

**Description**: Transfer tokens from L1 to L2 using the Optimism Bridge

**Steps**:

- Check if the contract is initialized
- Register the token and bridge if not initialized
- Deposit the required amount of tokens to the bridge
- Perform any necessary swaps before bridging
- Execute the bridging process via Optimism Bridge

**Functions**:

- `initOptimism`
- `registerOptimismBridge`
- `startBridgeTokensViaOptimismBridge`
- `swapAndStartBridgeTokensViaOptimismBridge`

### OwnershipFacet

#### Ownership Transfer Request

**Type**: general

**Description**: Request for ownership transfer to a new address

**Steps**:

- Check if the caller is the contract owner
- Check if the new owner is not the same as the current owner
- Set the new owner address in storage
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: Cancel the pending ownership transfer

**Steps**:

- Check if the caller is the contract owner
- Check if there is a pending owner
- Reset the new owner address in storage

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: Confirm the ownership transfer to the calling address

**Steps**:

- Check if the caller is the pending owner
- Transfer ownership to the caller
- Set the new owner as the contract owner
- Reset the new owner address in storage
- Emit OwnershipTransferred event

**Functions**:

- `confirmOwnershipTransfer`

#### Get Current Owner

**Type**: general

**Description**: Return the current owner address

**Steps**:

- Return the contract owner address

**Functions**:

- `owner`

### RelayFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens via the relay

**Steps**:

- Validate the bridge data
- Check if the sending asset is native or ERC20
- Send native tokens to the relay receiver or transfer ERC20 tokens to the relay solver
- Mark the request ID as consumed

**Functions**:

- `startBridgeTokensViaRelay`
- `swapAndStartBridgeTokensViaRelay`

### PolygonBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via Polygon Bridge

**Steps**:

- User initiates a token transfer request
- Token deposit is made to the contract
- Swap (if required) and validate the transfer data
- Bridge logic is executed to transfer tokens

**Functions**:

- `startBridgeTokensViaPolygonBridge`
- `swapAndStartBridgeTokensViaPolygonBridge`

### PeripheryRegistryFacet

#### Register Periphery Contract

**Type**: general

**Description**: Register a periphery contract address with a specified name

**Steps**:

- LibDiamond.enforceIsContractOwner();
- Storage storage s = getStorage();
- s.contracts[_name] = _contractAddress;
- emit PeripheryContractRegistered(_name, _contractAddress);

**Functions**:

- `registerPeripheryContract`

#### Get Periphery Contract

**Type**: general

**Description**: Returns the registered contract address by its name

**Steps**:

- return getStorage().contracts[_name];

**Functions**:

- `getPeripheryContract`

### StargateFacet

#### Token Transfer via Stargate Bridge

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Stargate Bridge

**Steps**:

- Validate the BridgeData and StargateData
- Quote the LayerZero fee
- Perform the token transfer via Stargate Bridge
- Execute the external call to the destination chain
- Refund any excess gas to the refund address

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`
- `quoteLayerZeroFee`

### StandardizedCallFacet

#### Standardized Call Flow

**Type**: general

**Description**: Flow to make a standardized call to a facet

**Steps**:

- Fetch the facetAddress from the diamond's internal storage
- Execute external function from facet using delegatecall
- Return any return value or error back to the caller

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

#### Token Transfer Flow

**Type**: general

**Description**: Flow to transfer tokens

**Steps**:

- Make a standardized call to transfer tokens
- Delegatecall to the facet to execute the transfer
- Return any return value or error back to the caller

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

### SquidFacet

#### Token Transfer via Squid Router

**Type**: general

**Description**: Transfer tokens through the Squid Router

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridging process

**Functions**:

- `startBridgeTokensViaSquid`
- `swapAndStartBridgeTokensViaSquid`

#### Access Control

**Type**: general

**Description**: Control access to the contract's functions

**Steps**:

- Check route type
- Ensure max approval for non-native assets
- Make external calls based on route type

**Functions**:

- `_startBridge`
- `_bridgeCall`
- `_callBridge`
- `_callBridgeCall`

#### State Transition

**Type**: general

**Description**: Update contract state during token transfer

**Steps**:

- Update bridge data
- Calculate msgValue
- Update SquidData

**Functions**:

- `_startBridge`
- `_calculateMsgValue`

#### External Call

**Type**: general

**Description**: Make external calls to other contracts

**Steps**:

- Make call to Squid Router
- Make call to IERC20
- Make call to LibAsset

**Functions**:

- `_bridgeCall`
- `_callBridge`
- `_callBridgeCall`

#### Fund Management

**Type**: general

**Description**: Manage funds during token transfer

**Steps**:

- Refund excess native
- Deposit asset
- Pay fee

**Functions**:

- `startBridgeTokensViaSquid`
- `swapAndStartBridgeTokensViaSquid`
- `_depositAndSwap`

### StargateFacetV2

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens via Stargate Bridge

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridging process

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`

### ThorSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to ThorSwap contract for bridging

**Steps**:

- Sender sends tokens to ThorSwap contract
- ThorSwap contract receives tokens
- ThorSwap contract processes bridge request

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### Access Control Flow

**Type**: general

**Description**: Ensure only authorized actors can perform certain actions

**Steps**:

- Check if sender is authorized
- Check if bridge data is valid
- Check if bridge data does not contain source swaps
- Check if bridge data does not contain destination calls

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### State Transition Flow

**Type**: general

**Description**: Update contract state after processing bridge requests

**Steps**:

- Update bridge data with deposited tokens
- Update ThorSwap data with vault address, memo, and expiration
- Update ThorSwap contract state with deposited tokens

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts for token bridging

**Steps**:

- Call LibAsset to deposit tokens
- Call ThorSwap contract to deposit tokens with expiry
- Call Thorchain Router to bridge tokens

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`
- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds deposited by sender for token bridging

**Steps**:

- Refund excess native tokens
- Deposit tokens for bridge request
- Manage approved ERC20 tokens

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`
- `_startBridge`

### SymbiosisFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the SymbiosisFacet contract for bridging

**Steps**:

- Sender sends tokens to the SymbiosisFacet contract
- SymbiosisFacet contract receives tokens
- SymbiosisFacet contract processes the tokens for bridging

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `swapAndStartBridgeTokensViaSymbiosis`

#### Access Control Flow

**Type**: general

**Description**: Control access to the SymbiosisFacet contract's functions

**Steps**:

- Sender sends a request to access a function
- SymbiosisFacet contract checks access permissions
- SymbiosisFacet contract grants or denies access

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `swapAndStartBridgeTokensViaSymbiosis`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the SymbiosisFacet contract during token bridging

**Steps**:

- SymbiosisFacet contract receives tokens
- SymbiosisFacet contract updates its state
- SymbiosisFacet contract processes the tokens for bridging

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `swapAndStartBridgeTokensViaSymbiosis`
- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts during token bridging

**Steps**:

- SymbiosisFacet contract makes an external call
- External contract processes the request
- SymbiosisFacet contract receives the response

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds received by the SymbiosisFacet contract

**Steps**:

- Sender sends tokens to the SymbiosisFacet contract
- SymbiosisFacet contract receives tokens
- SymbiosisFacet contract manages the funds

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `swapAndStartBridgeTokensViaSymbiosis`

### AccessManagerFacet

#### Access Control Flow

**Type**: general

**Description**: This flow handles setting and checking access permissions for specific addresses and methods.

**Steps**:

- Check if the caller is the contract owner
- Check if the executor is allowed to execute the method
- Add or remove access for the executor
- Emit an event indicating whether access was allowed or denied

**Functions**:

- `setCanExecute`
- `addressCanExecuteMethod`

### WithdrawFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the contract to an external address

**Steps**:

- Check if the sender has access control
- Verify if the recipient is a contract
- Execute the provided calldata on the recipient contract
- Withdraw the specified amount of tokens from the contract
- Send the tokens to the recipient address

**Functions**:

- `executeCallAndWithdraw`
- `withdraw`

### HopFacetOptimized

#### ERC20 Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 1 to Layer 2 using the Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swaps (if required) before bridging
- Bridge ERC20 tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1ERC20`
- `swapAndStartBridgeTokensViaHopL1ERC20`

#### Native Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging native tokens from Layer 1 to Layer 2 using the Hop Protocol

**Steps**:

- Bridge native tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1Native`
- `swapAndStartBridgeTokensViaHopL1Native`

#### ERC20 Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 2 to Layer 1 using the Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swaps (if required) before bridging
- Bridge ERC20 tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2ERC20`
- `swapAndStartBridgeTokensViaHopL2ERC20`

#### Native Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging native tokens from Layer 2 to Layer 1 using the Hop Protocol

**Steps**:

- Bridge native tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2Native`
- `swapAndStartBridgeTokensViaHopL2Native`

#### Approval for Hop Bridges

**Type**: general

**Description**: Approving Hop Bridges to spend specified tokens

**Steps**:

- Owner enforces contract owner check
- Iterate through the list of Hop Bridges
- Approve each Hop Bridge to spend tokens

**Functions**:

- `setApprovalForBridges`

### AcrossFacet

#### Token bridging via Across

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via the AcrossFacet contract

**Steps**:

- The user initiates a token bridging request
- The contract validates the bridging data
- The contract performs a swap (if required)
- The contract deposits the tokens into the spoke pool
- The contract emits a LiFiTransferStarted event

**Functions**:

- `startBridgeTokensViaAcross`
- `swapAndStartBridgeTokensViaAcross`

### AcrossFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring ERC20 tokens from the contract to the receiving wallet

**Steps**:

- ERC20 tokens are deposited into the contract
- Contract approves the Across spoke pool to pull tokens
- Tokens are transferred to the receiving wallet via the Across bridge

**Functions**:

- `startBridgeTokensViaAcrossERC20Packed`
- `startBridgeTokensViaAcrossERC20Min`
- `executeCallAndWithdraw`

### AmarokFacet

#### Token Transfer via Amarok

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Amarok bridge

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridge transaction

**Functions**:

- `startBridgeTokensViaAmarok`
- `swapAndStartBridgeTokensViaAmarok`

### AcrossFacetV3

#### Token bridging via Across

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain using the AcrossFacetV3 contract

**Steps**:

- Validate bridge data
- Check if source chain swaps are allowed
- Perform deposit and swap (if applicable)
- Start bridging process

**Functions**:

- `startBridgeTokensViaAcrossV3`
- `swapAndStartBridgeTokensViaAcrossV3`

#### Token bridging with destination call

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain with a destination call using the AcrossFacetV3 contract

**Steps**:

- Validate bridge data
- Check if source chain swaps are allowed
- Perform deposit and swap (if applicable)
- Start bridging process with destination call

**Functions**:

- `startBridgeTokensViaAcrossV3`
- `swapAndStartBridgeTokensViaAcrossV3`

### AllBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the AllBridge contract and then bridge them to another chain.

**Steps**:

- Sender sends tokens to the AllBridge contract.
- AllBridge contract receives the tokens.
- AllBridge contract bridges the tokens to another chain.

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`

#### Access Control Flow

**Type**: general

**Description**: Ensure that only authorized actors can interact with the AllBridge contract.

**Steps**:

- Sender provides authentication credentials.
- AllBridge contract verifies the sender's credentials.
- AllBridge contract grants access to the sender.

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the AllBridge contract after bridging tokens.

**Steps**:

- AllBridge contract receives the tokens.
- AllBridge contract updates its state to reflect the bridged tokens.
- AllBridge contract emits an event to indicate the state change.

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts during the bridging process.

**Steps**:

- AllBridge contract calls the swap function of the SwapperV2 contract.
- AllBridge contract calls the bridge function of the AllBridge contract.

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage the funds received during the bridging process.

**Steps**:

- Sender sends tokens to the AllBridge contract.
- AllBridge contract deposits the received tokens.
- AllBridge contract pays the fees to the relayer.

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`

### ArbitrumBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the source chain to the destination chain via Arbitrum Bridge

**Steps**:

- User initiates the token transfer by calling `startBridgeTokensViaArbitrumBridge` or `swapAndStartBridgeTokensViaArbitrumBridge`
- The contract calculates the cost of the transfer based on the provided ArbitrumData
- The contract deposits the required amount of native asset into the bridge
- The contract performs any necessary swaps before bridging
- The contract initiates the bridging process by calling the `inbox.unsafeCreateRetryableTicket` method
- The contract emits the `LiFiTransferStarted` event

**Functions**:

- `startBridgeTokensViaArbitrumBridge`
- `swapAndStartBridgeTokensViaArbitrumBridge`

### CBridgeFacet

#### Token bridging via CBridge

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain using CBridge

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _cBridgeData);

**Functions**:

- `startBridgeTokensViaCBridge`
- `_startBridge`

### CalldataVerificationFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow to transfer tokens from one address to another

**Steps**:

- Step 1: Extract bridge data from the transaction
- Step 2: Verify the extracted data
- Step 3: Execute the transfer

**Functions**:

- `_extractBridgeData`
- `_verifyData`
- `_executeTransfer`

### CelerCircleBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via CelerCircleBridge

**Steps**:

- LibAsset.depositAsset(usdc, _bridgeData.minAmount);
- _startBridge(_bridgeData);
- circleBridgeProxy.depositForBurn(...);

**Functions**:

- `startBridgeTokensViaCelerCircleBridge`
- `swapAndStartBridgeTokensViaCelerCircleBridge`
- `_startBridge`

### CBridgeFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- ERC20 token transfer from sender to contract
- Contract receives tokens and triggers a cBridge transfer
- cBridge transfers tokens to the destination address

**Functions**:

- `ERC20(sendingAssetId).safeTransferFrom`
- `cBridge.send`

#### Approval Flow

**Type**: general

**Description**: Flow responsible for setting approval for the CBridge Router to spend the specified token

**Steps**:

- Owner calls setApprovalForBridge function
- Function sets approval for CBridge Router to bridge tokens

**Functions**:

- `setApprovalForBridge`

#### Refund Flow

**Type**: general

**Description**: Flow responsible for triggering a cBridge refund

**Steps**:

- Owner calls triggerRefund function
- Function checks if callTo address is valid
- Function executes external call and checks success
- Contract refunds the sender and emits an event

**Functions**:

- `triggerRefund`

#### Bridge Native Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging native tokens via cBridge

**Steps**:

- Owner calls startBridgeTokensViaCBridgeNativePacked function
- Function sends native tokens to cBridge
- cBridge bridges native tokens to the destination chain

**Functions**:

- `startBridgeTokensViaCBridgeNativePacked`

#### Bridge ERC20 Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging ERC20 tokens via cBridge

**Steps**:

- Owner calls startBridgeTokensViaCBridgeERC20Packed function
- Function deposits ERC20 tokens to the contract
- Function bridges ERC20 tokens to the destination chain

**Functions**:

- `startBridgeTokensViaCBridgeERC20Packed`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds received by the contract

**Steps**:

- Contract receives native tokens via receive() external payable function
- Contract refunds sender if necessary

**Functions**:

- `receive()`

### CelerIMFacetMutable

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users

**Steps**:

- User initiates a token transfer request
- RelayerCelerIM contract receives the request
- RelayerCelerIM contract processes the request
- Tokens are transferred from sender to recipient

**Functions**:

- `transfer`

### DeBridgeDlnFacet

#### Token Transfer via DeBridgeDLN

**Type**: general

**Description**: Transfer tokens from one chain to another using DeBridgeDLN

**Steps**:

- User initiates a token transfer request
- Token approval is obtained if necessary
- DLN order is created
- Token transfer is initiated on the destination chain

**Functions**:

- `startBridgeTokensViaDeBridgeDln`
- `swapAndStartBridgeTokensViaDeBridgeDln`

### DexManagerFacet

#### Add DEX to Allowlist

**Type**: general

**Description**: Add a DEX contract address to the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add the DEX contract address to the allowlist
- Emit the DexAdded event

**Functions**:

- `addDex`

#### Remove DEX from Allowlist

**Type**: general

**Description**: Remove a DEX contract address from the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Remove the DEX contract address from the allowlist
- Emit the DexRemoved event

**Functions**:

- `removeDex`

#### Set Function Approval

**Type**: general

**Description**: Add or remove a specific function signature to/from the allowlist

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add or remove the function signature to/from the allowlist
- Emit the FunctionSignatureApprovalChanged event

**Functions**:

- `setFunctionApprovalBySignature`
- `batchSetFunctionApprovalBySignature`

#### Check Function Approval

**Type**: general

**Description**: Check if a function signature is approved

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Return whether the function signature is approved

**Functions**:

- `isFunctionApproved`

#### Get Approved DEXs

**Type**: general

**Description**: Get a list of all approved DEX contract addresses

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Return the list of approved DEX contract addresses

**Functions**:

- `approvedDexs`

### DiamondCutFacet

#### DiamondCutFacet Flow

**Type**: general

**Description**: This flow handles the addition, replacement, or removal of functions in the diamond contract.

**Steps**:

- The contract owner calls the `diamondCut` function.
- The `diamondCut` function checks if the caller is the contract owner.
- If the caller is the contract owner, the function executes the delegatecall with the provided calldata on the specified init address.

**Functions**:

- `diamondCut`

### EmergencyPauseFacet

#### Emergency Pause Flow

**Type**: general

**Description**: Flow that allows pausing the diamond contract by redirecting all function selectors to the EmergencyPauseFacet

**Steps**:

- The pauserWallet or owner calls the pauseDiamond function
- The function redirects all function selectors to the EmergencyPauseFacet
- Third parties trying to call the diamond contract will receive a meaningful error message

**Functions**:

- `pauseDiamond`

#### Facet Removal Flow

**Type**: general

**Description**: Flow that allows removing a facet from the diamond contract

**Steps**:

- The pauserWallet or owner calls the removeFacet function
- The function removes the facet and its function selectors from the diamond
- The removed facet can be reactivated later on

**Functions**:

- `removeFacet`

#### Diamond Unpause Flow

**Type**: general

**Description**: Flow that allows unpausing the diamond contract by re-adding all facetAddress-to-function-selector mappings to storage

**Steps**:

- The owner calls the unpauseDiamond function
- The function re-instates all facets and their function selectors
- Facets that are in the blacklist are removed from the diamond

**Functions**:

- `unpauseDiamond`

### DiamondLoupeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens within the system

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request and verifies the sender's permissions
- Smart contract deducts the tokens from the sender's balance
- Smart contract adds the tokens to the recipient's balance
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the smart contract's functionalities

**Steps**:

- User sends a request to perform an action
- Smart contract checks the user's role or permissions
- Smart contract grants or denies access based on the user's role or permissions
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `supportsInterface`
- `facetAddress`
- `facets`
- `facetFunctionSelectors`
- `facetAddresses`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the smart contract's state

**Steps**:

- User sends a request to update the state
- Smart contract verifies the request and checks the user's permissions
- Smart contract updates the state
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `selectorToFacetAndPosition`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Smart contract receives a request to make an external call
- Smart contract verifies the request and checks the user's permissions
- Smart contract makes the external call
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `facetAddress`
- `facets`
- `facetFunctionSelectors`
- `facetAddresses`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds within the system

**Steps**:

- User sends a request to deposit or withdraw funds
- Smart contract verifies the request and checks the user's permissions
- Smart contract updates the user's balance
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

### GasZipFacet

#### Token bridging flow

**Type**: general

**Description**: Bridging tokens from one network to another using the gas.zip protocol

**Steps**:

- Check if the sending asset is a native asset
- Validate the bridge data
- Deposit native tokens to Gas.zip
- Start bridging process

**Functions**:

- `startBridgeTokensViaGasZip`
- `swapAndStartBridgeTokensViaGasZip`
- `_startBridge`

### GenericSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to the contract and then to the receiver after performing swaps

**Steps**:

- Sender sends tokens to the contract
- Contract checks if the receiver address is valid
- Contract performs swaps using the provided swap data
- Contract transfers the final swapped tokens to the receiver

**Functions**:

- `swapTokensGeneric`

#### Access Control Flow

**Type**: general

**Description**: Ensure that only authorized users can perform the swap operation

**Steps**:

- Sender sends a request to perform a swap
- Contract checks if the sender is authorized
- Contract performs the swap operation if authorized

**Functions**:

- `swapTokensGeneric`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the contract after performing the swap operation

**Steps**:

- Contract performs the swap operation
- Contract updates the state with the new balance and swap data

**Functions**:

- `swapTokensGeneric`

#### External Call Flow

**Type**: general

**Description**: Make external calls to perform swaps and transfer assets

**Steps**:

- Contract makes an external call to perform swaps
- Contract makes an external call to transfer assets

**Functions**:

- `swapTokensGeneric`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds received from sender and distribute them after performing swaps

**Steps**:

- Sender sends funds to the contract
- Contract manages the funds received
- Contract distributes the funds after performing swaps

**Functions**:

- `swapTokensGeneric`

### GnosisBridgeFacet

#### Token Bridging Flow

**Type**: general

**Description**: Bridging tokens from the source chain to the Gnosis chain via the xdai bridge

**Steps**:

- Validate bridge data
- Perform swap (if required)
- Deposit tokens
- Relay tokens via xdai bridge
- Start bridging process

**Functions**:

- `startBridgeTokensViaXDaiBridge`
- `swapAndStartBridgeTokensViaXDaiBridge`

### LibAccess

#### Access Control Flow

**Type**: general

**Description**: This flow handles the granting and revoking of permissions for different methods in the contract.

**Steps**:

- Fetch the local storage using the accessStorage function
- Check if the executor is trying to grant permission to themselves
- Grant permission to the executor for a specific method selector
- Emit the AccessGranted event
- Fetch the local storage using the accessStorage function
- Check if the executor is trying to revoke permission from themselves
- Revoke permission from the executor for a specific method selector
- Emit the AccessRevoked event

**Functions**:

- `addAccess`
- `removeAccess`

#### Enforce Access Control Flow

**Type**: general

**Description**: This flow enforces access control by reverting if the sender has not been given permission to execute a specific method.

**Steps**:

- Fetch the local storage using the accessStorage function
- Check if the sender has permission to execute the current method
- Revert the transaction if the sender does not have permission

**Functions**:

- `enforceAccessControl`

### HopFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens via Hop Protocol

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _hopData);

**Functions**:

- `startBridgeTokensViaHop`
- `_startBridge`

#### Swap and Transfer Flow

**Type**: general

**Description**: Flow responsible for performing swaps before transferring tokens via Hop Protocol

**Steps**:

- _bridgeData.minAmount = _depositAndSwap(_bridgeData.transactionId, _bridgeData.minAmount, _swapData, payable(msg.sender), _hopData.nativeFee);
- _startBridge(_bridgeData, _hopData);

**Functions**:

- `swapAndStartBridgeTokensViaHop`
- `_startBridge`

#### Bridge Registration Flow

**Type**: general

**Description**: Flow responsible for registering token and bridge

**Steps**:

- LibDiamond.enforceIsContractOwner();
- s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);
- emit HopBridgeRegistered(assetId, bridge);

**Functions**:

- `initHop`
- `registerBridge`

### LibAsset

#### Token Transfer

**Type**: general

**Description**: Transfer tokens from the contract to a recipient

**Steps**:

- Check if the recipient address is null
- Check if the amount exceeds the contract's balance
- Transfer the tokens to the recipient

**Functions**:

- `transferERC20`
- `transferNativeAsset`

#### Access Control

**Type**: general

**Description**: Control the transfer of tokens based on the sender's balance

**Steps**:

- Check if the sender's balance is sufficient
- Transfer tokens from the sender to the contract

**Functions**:

- `depositAsset`
- `depositAssets`

#### State Transition

**Type**: general

**Description**: Update the contract's state based on the deposited tokens

**Steps**:

- Update the sender's balance
- Update the contract's balance

**Functions**:

- `depositAsset`
- `depositAssets`

#### External Call

**Type**: general

**Description**: Make external calls to transfer tokens

**Steps**:

- Make an external call to transfer tokens
- Check the success of the external call

**Functions**:

- `transferNativeAsset`

#### Fund Management

**Type**: general

**Description**: Manage the contract's funds

**Steps**:

- Transfer tokens to the contract
- Transfer tokens from the contract

**Functions**:

- `depositAsset`
- `transferERC20`
- `transferNativeAsset`

### LibBytes

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract validates the request
- Token transfer is executed

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to contract functionalities

**Steps**:

- User requests access to a specific functionality
- Smart contract checks user permissions
- Access is granted or denied

**Functions**:

- `slice`
- `toAddress`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating contract state

**Steps**:

- User submits a state update request
- Smart contract validates the request
- Contract state is updated

**Functions**:

- `slice`
- `toAddress`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- User requests an external call
- Smart contract validates the request
- External call is executed

**Functions**:

- `slice`
- `toAddress`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing contract funds

**Steps**:

- User deposits or withdraws funds
- Smart contract validates the request
- Funds are deposited or withdrawn

**Functions**:

- `transfer`

### LibAllowList

#### Add Contract to Allow List

**Type**: general

**Description**: Add a contract address to the allow list

**Steps**:

- Check if the contract address is valid
- Check if the contract address is already in the allow list
- Add the contract address to the allow list

**Functions**:

- `addAllowedContract`

#### Remove Contract from Allow List

**Type**: general

**Description**: Remove a contract address from the allow list

**Steps**:

- Check if the contract address is in the allow list
- Remove the contract address from the allow list

**Functions**:

- `removeAllowedContract`

#### Add Selector to Allow List

**Type**: general

**Description**: Add a selector to the allow list

**Steps**:

- Add the selector to the allow list

**Functions**:

- `addAllowedSelector`

#### Remove Selector from Allow List

**Type**: general

**Description**: Remove a selector from the allow list

**Steps**:

- Remove the selector from the allow list

**Functions**:

- `removeAllowedSelector`

#### Check if Contract is Allowed

**Type**: general

**Description**: Check if a contract address has been added to the allow list

**Steps**:

- Check if the contract address is in the allow list

**Functions**:

- `contractIsAllowed`

#### Get All Allowed Contracts

**Type**: general

**Description**: Fetch contract addresses from the allow list

**Steps**:

- Return the list of allowed contracts

**Functions**:

- `getAllowedContracts`

### LibSwap

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to receiver through a decentralized exchange (DEX) contract.

**Steps**:

- Sender initiates a swap request with the DEX contract.
- The DEX contract checks if the sender has sufficient balance.
- The DEX contract approves the transfer of tokens if necessary.
- The DEX contract executes the swap by calling the external contract specified in the swap data.
- The DEX contract updates the balances of the sender and receiver.
- The DEX contract emits an event to log the swap details.

**Functions**:

- `swap`

### LibDiamondLoupe

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens within the system

**Steps**:

- User initiates a token transfer request
- Smart contract verifies user's permissions
- Token transfer is executed
- Token transfer status is updated

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to different functionalities

**Steps**:

- User requests access to a specific functionality
- Smart contract verifies user's permissions
- Access is granted or denied based on permissions

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the state of the contract

**Steps**:

- User interacts with the contract
- Smart contract processes the interaction
- State is updated based on the interaction

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Smart contract receives a request for an external call
- Smart contract makes the external call
- External call result is processed

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds within the contract

**Steps**:

- User deposits or withdraws funds
- Smart contract processes the transaction
- Funds are updated based on the transaction

**Functions**:

- `transfer`

### LibDiamond

#### Ownership Transfer

**Type**: general

**Description**: Transfer ownership of the contract to a new owner

**Steps**:

- Check if the new owner is valid
- Update the contract owner
- Emit the OwnershipTransferred event

**Functions**:

- `setContractOwner`

#### Diamond Cut

**Type**: general

**Description**: Add, replace, or remove functions in the diamond

**Steps**:

- Validate the FacetCut array
- Update the diamond storage
- Emit the DiamondCut event
- Initialize the diamond cut

**Functions**:

- `diamondCut`

#### Function Addition

**Type**: general

**Description**: Add new functions to a facet

**Steps**:

- Check if the facet address is valid
- Update the facet function selectors
- Update the selector to facet mapping

**Functions**:

- `addFunctions`

#### Function Replacement

**Type**: general

**Description**: Replace existing functions in a facet

**Steps**:

- Check if the facet address is valid
- Update the facet function selectors
- Update the selector to facet mapping

**Functions**:

- `replaceFunctions`

#### Function Removal

**Type**: general

**Description**: Remove functions from a facet

**Steps**:

- Check if the facet address is valid
- Update the facet function selectors
- Update the selector to facet mapping

**Functions**:

- `removeFunctions`

#### Facet Addition

**Type**: general

**Description**: Add a new facet to the diamond

**Steps**:

- Check if the facet address is valid
- Update the facet addresses array
- Update the facet function selectors

**Functions**:

- `addFacet`

#### External Call

**Type**: general

**Description**: Delegatecall to an external contract

**Steps**:

- Check if the init address is valid
- Delegatecall to the external contract
- Handle any errors

**Functions**:

- `initializeDiamondCut`

### LibUtil

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract validates the request
- Token transfer is executed
- Transfer success or failure message is returned

**Functions**:

- `revertWith`

### OFTComposeMsgCodec

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request
- Smart contract verifies the request
- Smart contract executes the transfer
- Transfer is confirmed

**Functions**:

- `encode`
- `nonce`
- `srcEid`
- `amountLD`
- `composeFrom`
- `composeMsg`

## Cognitive Bias Analysis

### GasZipPeriphery

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LiFiDEXAggregator

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### Permit2Proxy

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### RelayerCelerIM

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### TransferrableOwnership

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### WithdrawFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPackedV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### GenericSwapFacetV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LibDiamond

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

## Recommendations

Based on the analysis, consider the following recommendations:

- No specific recommendations available from the analysis

## Debug Information

This report was generated as part of the debugging process.
- Pipeline executed at: 2025-03-30 06:23:00
- Input directory: examples/src
- Output directory: debug_output