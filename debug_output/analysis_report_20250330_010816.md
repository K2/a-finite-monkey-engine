# Smart Contract Analysis Report

Generated: 2025-03-30 01:18:22

## Overview

Analyzed 74 contract(s)

### LiFiDiamond
- File: `examples/src/LiFiDiamond.sol`
- Lines of code: 60

### ERC20Proxy
- File: `examples/src/Periphery/ERC20Proxy.sol`
- Lines of code: 37

### Executor
- File: `examples/src/Periphery/Executor.sol`
- Lines of code: 244

### FeeCollector
- File: `examples/src/Periphery/FeeCollector.sol`
- Lines of code: 174

### GasZipPeriphery
- File: `examples/src/Periphery/GasZipPeriphery.sol`
- Lines of code: 101

### LiFiDEXAggregator
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 727

### InputStream
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 127

### Approve
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 37

### RebaseLibrary
- File: `examples/src/Periphery/LiFiDEXAggregator.sol`
- Lines of code: 25

### LiFuelFeeCollector
- File: `examples/src/Periphery/LiFuelFeeCollector.sol`
- Lines of code: 90

### Permit2Proxy
- File: `examples/src/Periphery/Permit2Proxy.sol`
- Lines of code: 359

### Receiver
- File: `examples/src/Periphery/Receiver.sol`
- Lines of code: 252

### ReceiverAcrossV3
- File: `examples/src/Periphery/ReceiverAcrossV3.sol`
- Lines of code: 102

### ReceiverStargateV2
- File: `examples/src/Periphery/ReceiverStargateV2.sol`
- Lines of code: 173

### RelayerCelerIM
- File: `examples/src/Periphery/RelayerCelerIM.sol`
- Lines of code: 419

### TokenWrapper
- File: `examples/src/Periphery/TokenWrapper.sol`
- Lines of code: 40

### LiFiTimelockController
- File: `examples/src/Security/LiFiTimelockController.sol`
- Lines of code: 46

### CelerIMFacetBase
- File: `examples/src/Helpers/CelerIMFacetBase.sol`
- Lines of code: 216

### ExcessivelySafeCall
- File: `examples/src/Helpers/ExcessivelySafeCall.sol`
- Lines of code: 137

### ReentrancyGuard
- File: `examples/src/Helpers/ReentrancyGuard.sol`
- Lines of code: 45

### SwapperV2
- File: `examples/src/Helpers/SwapperV2.sol`
- Lines of code: 308

### TransferrableOwnership
- File: `examples/src/Helpers/TransferrableOwnership.sol`
- Lines of code: 51

### Validatable
- File: `examples/src/Helpers/Validatable.sol`
- Lines of code: 64

### WithdrawablePeriphery
- File: `examples/src/Helpers/WithdrawablePeriphery.sol`
- Lines of code: 27

### HopFacetPacked
- File: `examples/src/Facets/HopFacetPacked.sol`
- Lines of code: 704

### LIFuelFacet
- File: `examples/src/Facets/LIFuelFacet.sol`
- Lines of code: 104

### MayanFacet
- File: `examples/src/Facets/MayanFacet.sol`
- Lines of code: 291

### OmniBridgeFacet
- File: `examples/src/Facets/OmniBridgeFacet.sol`
- Lines of code: 90

### OptimismBridgeFacet
- File: `examples/src/Facets/OptimismBridgeFacet.sol`
- Lines of code: 193

### OwnershipFacet
- File: `examples/src/Facets/OwnershipFacet.sol`
- Lines of code: 80

### PeripheryRegistryFacet
- File: `examples/src/Facets/PeripheryRegistryFacet.sol`
- Lines of code: 48

### PolygonBridgeFacet
- File: `examples/src/Facets/PolygonBridgeFacet.sol`
- Lines of code: 98

### RelayFacet
- File: `examples/src/Facets/RelayFacet.sol`
- Lines of code: 217

### SquidFacet
- File: `examples/src/Facets/SquidFacet.sol`
- Lines of code: 193

### StandardizedCallFacet
- File: `examples/src/Facets/StandardizedCallFacet.sol`
- Lines of code: 66

### StargateFacet
- File: `examples/src/Facets/StargateFacet.sol`
- Lines of code: 270

### StargateFacetV2
- File: `examples/src/Facets/StargateFacetV2.sol`
- Lines of code: 145

### SymbiosisFacet
- File: `examples/src/Facets/SymbiosisFacet.sol`
- Lines of code: 132

### ThorSwapFacet
- File: `examples/src/Facets/ThorSwapFacet.sol`
- Lines of code: 107

### WithdrawFacet
- File: `examples/src/Facets/WithdrawFacet.sol`
- Lines of code: 78

### HopFacetOptimized
- File: `examples/src/Facets/HopFacetOptimized.sol`
- Lines of code: 258

### AccessManagerFacet
- File: `examples/src/Facets/AccessManagerFacet.sol`
- Lines of code: 41

### AcrossFacet
- File: `examples/src/Facets/AcrossFacet.sol`
- Lines of code: 123

### AcrossFacetPacked
- File: `examples/src/Facets/AcrossFacetPacked.sol`
- Lines of code: 370

### AcrossFacetPackedV3
- File: `examples/src/Facets/AcrossFacetPackedV3.sol`
- Lines of code: 385

### AcrossFacetV3
- File: `examples/src/Facets/AcrossFacetV3.sol`
- Lines of code: 161

### AllBridgeFacet
- File: `examples/src/Facets/AllBridgeFacet.sol`
- Lines of code: 115

### AmarokFacet
- File: `examples/src/Facets/AmarokFacet.sol`
- Lines of code: 148

### AmarokFacetPacked
- File: `examples/src/Facets/AmarokFacetPacked.sol`
- Lines of code: 354

### ArbitrumBridgeFacet
- File: `examples/src/Facets/ArbitrumBridgeFacet.sol`
- Lines of code: 139

### CBridgeFacet
- File: `examples/src/Facets/CBridgeFacet.sol`
- Lines of code: 154

### CBridgeFacetPacked
- File: `examples/src/Facets/CBridgeFacetPacked.sol`
- Lines of code: 315

### CalldataVerificationFacet
- File: `examples/src/Facets/CalldataVerificationFacet.sol`
- Lines of code: 521

### CelerCircleBridgeFacet
- File: `examples/src/Facets/CelerCircleBridgeFacet.sol`
- Lines of code: 95

### CelerIMFacetMutable
- File: `examples/src/Facets/CelerIMFacetMutable.sol`
- Lines of code: 15

### DeBridgeDlnFacet
- File: `examples/src/Facets/DeBridgeDlnFacet.sol`
- Lines of code: 257

### DexManagerFacet
- File: `examples/src/Facets/DexManagerFacet.sol`
- Lines of code: 136

### DiamondCutFacet
- File: `examples/src/Facets/DiamondCutFacet.sol`
- Lines of code: 16

### DiamondLoupeFacet
- File: `examples/src/Facets/DiamondLoupeFacet.sol`
- Lines of code: 78

### EmergencyPauseFacet
- File: `examples/src/Facets/EmergencyPauseFacet.sol`
- Lines of code: 222

### GasZipFacet
- File: `examples/src/Facets/GasZipFacet.sol`
- Lines of code: 126

### GenericSwapFacet
- File: `examples/src/Facets/GenericSwapFacet.sol`
- Lines of code: 44

### GenericSwapFacetV3
- File: `examples/src/Facets/GenericSwapFacetV3.sol`
- Lines of code: 555

### GnosisBridgeFacet
- File: `examples/src/Facets/GnosisBridgeFacet.sol`
- Lines of code: 80

### HopFacet
- File: `examples/src/Facets/HopFacet.sol`
- Lines of code: 181

### LibAccess
- File: `examples/src/Libraries/LibAccess.sol`
- Lines of code: 56

### LibAllowList
- File: `examples/src/Libraries/LibAllowList.sol`
- Lines of code: 100

### LibAsset
- File: `examples/src/Libraries/LibAsset.sol`
- Lines of code: 168

### LibBytes
- File: `examples/src/Libraries/LibBytes.sol`
- Lines of code: 122

### LibDiamond
- File: `examples/src/Libraries/LibDiamond.sol`
- Lines of code: 354

### LibDiamondLoupe
- File: `examples/src/Libraries/LibDiamondLoupe.sol`
- Lines of code: 48

### LibSwap
- File: `examples/src/Libraries/LibSwap.sol`
- Lines of code: 73

### LibUtil
- File: `examples/src/Libraries/LibUtil.sol`
- Lines of code: 27

### OFTComposeMsgCodec
- File: `examples/src/Libraries/OFTComposeMsgCodec.sol`
- Lines of code: 89

## Business Flow Analysis

### ERC20Proxy

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens from one address to another

**Steps**:

- Check if the sender is authorized
- Transfer tokens from the sender to the recipient
- Update the token balance of the sender and recipient

**Functions**:

- `transferFrom`

### Executor

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users and contracts

**Steps**:

- Fetch balances of tokens to be swapped
- Execute swaps one after the other
- Transfer leftover tokens to the receiver
- Transfer tokens to the receiver from the final asset

**Functions**:

- `_fetchBalances`
- `_executeSwaps`
- `LibAsset.transferAsset`
- `LibAsset.transferAsset`

### LiFiDiamond

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User sends tokens to the contract
- Contract receives tokens
- Contract processes the tokens

**Functions**:

- `receive`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- User sends a request to access the contract
- Contract checks user's permissions
- Contract grants or denies access

**Functions**:

- `fallback`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- User sends a request to update the state
- Contract checks the request
- Contract updates the state

**Functions**:

- `fallback`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Contract receives a request to make an external call
- Contract checks the request
- Contract makes the external call

**Functions**:

- `fallback`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- User sends funds to the contract
- Contract receives funds
- Contract manages the funds

**Functions**:

- `receive`

### FeeCollector

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens to integrators and Lifi

**Steps**:

- Collecting fees for the integrator
- Collecting fees for Lifi
- Withdrawing fees from integrators
- Withdrawing fees from Lifi

**Functions**:

- `collectTokenFees`
- `collectNativeFees`
- `withdrawIntegratorFees`
- `batchWithdrawIntegratorFees`
- `withdrawLifiFees`
- `batchWithdrawLifiFees`

### GasZipPeriphery

#### Token Transfer Flow

**Type**: general

**Description**: Transfer ERC20 tokens to native and deposit these native tokens in the GasZip router contract

**Steps**:

- LibAsset.depositAsset(_swapData.sendingAssetId, _swapData.fromAmount);
- LibAsset.maxApproveERC20(IERC20(_swapData.sendingAssetId), liFiDEXAggregator, _swapData.fromAmount);
- liFiDEXAggregator.call(_swapData.callData);
- depositToGasZipNative(_gasZipData, swapOutputAmount);

**Functions**:

- `depositToGasZipERC20`
- `depositToGasZipNative`

### RebaseLibrary

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users

**Steps**:

- User A sends a request to transfer tokens to User B
- The smart contract verifies the request and checks the user's balance
- The smart contract deducts the transferred amount from User A's balance
- The smart contract adds the transferred amount to User B's balance
- The transaction is confirmed and the transfer is completed

**Functions**:

- `transfer`

### Approve

#### Token Transfer Approval

**Type**: general

**Description**: Approve the transfer of tokens from the user's account to a specified spender.

**Steps**:

- User calls the approve function with the token contract, spender, and amount.
- The contract checks if the token contract supports the approve function.
- The contract calls the token contract's approve function with the provided parameters.
- The contract checks if the approve function call was successful and returns a boolean value.

**Functions**:

- `approveStable`
- `approveSafe`

### InputStream

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- Token owner calls the transfer function
- Token contract verifies sender and recipient
- Token contract deducts tokens from sender and adds to recipient

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to different functions

**Steps**:

- User calls a function
- Access control checks user permissions
- Function executes or throws an error

**Functions**:

- `createStream`
- `isNotEmpty`
- `readUint8`
- `readUint16`
- `readUint24`
- `readUint32`
- `readUint`
- `readBytes32`
- `readAddress`
- `readBytes`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the state of the contract

**Steps**:

- User calls a function
- Function performs operations on the state
- State is updated

**Functions**:

- `createStream`
- `isNotEmpty`
- `readUint8`
- `readUint16`
- `readUint24`
- `readUint32`
- `readUint`
- `readBytes32`
- `readAddress`
- `readBytes`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Contract calls an external function
- External function executes
- Contract receives response

**Functions**:

- `createStream`
- `isNotEmpty`
- `readUint8`
- `readUint16`
- `readUint24`
- `readUint32`
- `readUint`
- `readBytes32`
- `readAddress`
- `readBytes`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- User deposits or withdraws funds
- Contract updates balances
- User receives or pays tokens

**Functions**:

- `transfer`

### Permit2Proxy

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens through a LI.FI diamond contract using EIP2612 gasless permit

**Steps**:

- Check if the token address implements EIP2612
- Verify the permit signature
- Register approval using the signature
- Deposit assets
- Max approve token to diamond if current allowance is insufficient
- Call the diamond to execute calldata

**Functions**:

- `callDiamondWithEIP2612Signature`

### Receiver

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one chain to another

**Steps**:

- Receive tokens from Stargate Router
- Perform swap if necessary
- Complete bridge tokens transfer

**Functions**:

- `sgReceive`
- `swapAndCompleteBridgeTokens`
- `_swapAndCompleteBridgeTokens`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Check if sender is SG Router
- Check if sender is Amarok Router
- Apply modifiers to restrict access

**Functions**:

- `onlySGRouter`
- `onlyAmarokRouter`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Update SG Router address
- Update Amarok Router address
- Update Executor address
- Update recoverGas value

**Functions**:

- `constructor`
- `setSGRouter`
- `setAmarokRouter`
- `setExecutor`
- `setRecoverGas`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Make external call to Executor
- Make external call to SafeTransferLib

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `executor.swapAndCompleteBridgeTokens`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- Receive native asset directly
- Transfer tokens to receiver
- Transfer ETH to receiver

**Functions**:

- `receive`
- `safeTransfer`
- `safeTransferETH`

### LiFuelFeeCollector

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring gas fees from users to the contract and then to the receiver

**Steps**:

- User calls collectTokenGasFees function
- Contract deposits the token into its balance
- Contract emits GasFeesCollected event
- Contract transfers the token to the receiver

**Functions**:

- `collectTokenGasFees`

#### Native Token Transfer Flow

**Type**: general

**Description**: Flow responsible for collecting gas fees in native token and transferring it to the user

**Steps**:

- User calls collectNativeGasFees function
- Contract emits GasFeesCollected event
- Contract subtracts the fee amount from the msg.value
- Contract transfers the remaining amount to the user

**Functions**:

- `collectNativeGasFees`

#### Fees Withdrawal Flow

**Type**: general

**Description**: Flow responsible for withdrawing gas fees from the contract to the owner

**Steps**:

- Owner calls withdrawFees function
- Contract retrieves the balance of the token
- Contract transfers the balance to the owner
- Contract emits FeesWithdrawn event

**Functions**:

- `withdrawFees`

#### Batch Fees Withdrawal Flow

**Type**: general

**Description**: Flow responsible for batch withdrawing gas fees from the contract to the owner

**Steps**:

- Owner calls batchWithdrawFees function
- Contract retrieves the balance of each token
- Contract transfers the balance to the owner
- Contract emits FeesWithdrawn event for each token

**Functions**:

- `batchWithdrawFees`

#### Gas Fees Collection Flow

**Type**: general

**Description**: Flow responsible for collecting gas fees in different ways

**Steps**:

- User calls collectTokenGasFees function
- Contract collects the token fees
- Contract emits GasFeesCollected event
- Contract collects native token fees
- Contract emits GasFeesCollected event
- Contract transfers the remaining native token to the user

**Functions**:

- `collectTokenGasFees`
- `collectNativeGasFees`

### RelayerCelerIM

#### Token Transfer Execution

**Type**: general

**Description**: Execution of token transfer from the source chain to the destination chain via the cBridge

**Steps**:

- Decode the message received from the source app contract
- Execute the swap and complete the bridge tokens
- Transfer the tokens to the receiver address

**Functions**:

- `executeMessageWithTransfer`
- `_swapAndCompleteBridgeTokens`

#### Token Transfer Refund

**Type**: general

**Description**: Refund of the original transfer from the contract

**Steps**:

- Decode the message received from the source app contract
- Return the funds to the refund address

**Functions**:

- `executeMessageWithTransferRefund`

#### Token Transfer to CelerIM

**Type**: general

**Description**: Forwarding of token transfer to CelerIM

**Steps**:

- Decode the message received from the source app contract
- Send the tokens to the CelerIM contract

**Functions**:

- `sendTokenTransfer`

### ReceiverAcrossV3

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens across chains

**Steps**:

- Decoding the message payload to get transactionId, swapData, and receiver
- Executing swaps using the provided swapData
- Completing the bridge tokens transfer to the receiver
- Resetting the approval for the executor

**Functions**:

- `_swapAndCompleteBridgeTokens`
- `handleV3AcrossMessage`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract

**Steps**:

- Checking if the sender is the Spokepool
- Executing the function if authorized, otherwise reverting
- Granting and revoking permissions as needed

**Functions**:

- `onlySpokepool`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Updating the contract's storage variables
- Executing external calls to update the state
- Updating the contract's state upon token transfers

**Functions**:

- `constructor`
- `handleV3AcrossMessage`
- `_swapAndCompleteBridgeTokens`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls

**Steps**:

- Calling the executor's swapAndCompleteBridgeTokens function
- Approving the executor to spend tokens
- Sending tokens to the receiver

**Functions**:

- `_swapAndCompleteBridgeTokens`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds

**Steps**:

- Receiving native assets directly
- Managing token balances
- Handling recovered funds

**Functions**:

- `receive`

### ReceiverStargateV2

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the source chain to the destination chain

**Steps**:

- Verify that the sender address is a Stargate pool
- Decode the payload to get transaction ID, swap data, and receiver address
- Execute swaps and complete the cross-chain transaction

**Functions**:

- `lzCompose`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the contract's functions

**Steps**:

- Check if the sender is the endpointV2 address
- Execute the requested function if authorized

**Functions**:

- `onlyEndpointV2`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Update the executor, tokenMessaging, endpointV2, and recoverGas variables during contract initialization
- Update the contract's state during token transfer flow

**Functions**:

- `constructor`
- `_swapAndCompleteBridgeTokens`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Call the LayerZero endpoint to initiate the cross-chain transaction
- Call the Executor contract to execute swaps and complete the bridge transaction

**Functions**:

- `lzCompose`
- `executor.swapAndCompleteBridgeTokens`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the contract's funds

**Steps**:

- Receive native assets directly
- Transfer native assets to the receiver address

**Functions**:

- `receive`

### LiFiTimelockController

#### Diamond Address Update

**Type**: general

**Description**: Update the address of the diamond contract

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role or if the role is open
- Update the diamond address
- Emit the DiamondAddressUpdated event

**Functions**:

- `setDiamondAddress`

#### Emergency Unpause Diamond

**Type**: general

**Description**: Unpause the diamond contract bypassing the minDelay

**Steps**:

- Check if the caller has the TIMELOCK_ADMIN_ROLE role
- Call the EmergencyPause(diamond).unpauseDiamond function directly
- Unpause the diamond contract

**Functions**:

- `unpauseDiamond`

### CelerIMFacetBase

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the sender to the relayer

**Steps**:

- Check if the sending asset is a native asset
- If not, transfer ERC20 tokens directly to the relayer
- Deposit ERC20 token to the relayer
- Verify the amount of ERC20 token deposited
- Send the native asset or ERC20 token to the relayer

**Functions**:

- `_getRightAsset`
- `SafeERC20.safeTransferFrom`
- `relayer.sendTokenTransfer`

#### Bridge Flow

**Type**: general

**Description**: Flow responsible for bridging tokens via CBridge

**Steps**:

- Validate the bridge data
- Perform a swap before bridging if necessary
- Determine the correct amount of native asset to be forwarded
- Send the native asset or ERC20 token to the relayer
- Call the message bus via the relayer
- Emit LiFiTransferStarted event

**Functions**:

- `startBridgeTokensViaCelerIM`
- `swapAndStartBridgeTokensViaCelerIM`
- `_startBridge`

### TokenWrapper

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users and the contract

**Steps**:

- User deposits native token into the contract
- Contract wraps the native token
- Contract transfers wrapped token to the user

**Functions**:

- `deposit`

#### Withdrawal Flow

**Type**: general

**Description**: Flow responsible for withdrawing wrapped tokens from the contract

**Steps**:

- User requests withdrawal
- Contract transfers wrapped token from user to itself
- Contract unwraps the wrapped token
- Contract transfers native token to the user

**Functions**:

- `withdraw`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Contract calls IWrapper(wrappedToken).deposit()
- Contract calls IERC20(wrappedToken).transfer()
- Contract calls SafeTransferLib.safeTransferETH()

**Functions**:

- `deposit`
- `withdraw`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to contract functions

**Steps**:

- Contract checks if the caller has the necessary permissions
- Contract allows or denies access to the requested function

**Functions**:

- `deposit`
- `withdraw`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the contract's state

**Steps**:

- Contract updates the wrapped token balance
- Contract updates the user's token balance
- Contract updates the user's native token balance

**Functions**:

- `deposit`
- `withdraw`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing the contract's funds

**Steps**:

- Contract receives native token deposits
- Contract transfers native token to other contracts
- Contract transfers wrapped tokens to users

**Functions**:

- `deposit`
- `withdraw`

### ExcessivelySafeCall

#### Excessively Safe Call

**Type**: general

**Description**: A secure call function that limits the number of bytes that the callee can cause to be copied to caller memory.

**Steps**:

- Check the maximum number of bytes to copy
- Call the target contract using assembly
- Copy the return data to a new bytes memory
- Limit the copied bytes to the maximum allowed
- Return the success and the limited return data

**Functions**:

- `excessivelySafeCall`

#### Excessively Safe Static Call

**Type**: general

**Description**: A secure static call function that limits the number of bytes that the callee can cause to be copied to caller memory.

**Steps**:

- Check the maximum number of bytes to copy
- Call the target contract using assembly
- Copy the return data to a new bytes memory
- Limit the copied bytes to the maximum allowed
- Return the success and the limited return data

**Functions**:

- `excessivelySafeStaticCall`

#### Swap Selector

**Type**: general

**Description**: A function that swaps out the first 4 bytes of a contract call buffer with a new selector.

**Steps**:

- Check the length of the buffer
- Create a mask to isolate the first word
- Apply the new selector to the first word
- Store the modified buffer

**Functions**:

- `swapSelector`

### SwapperV2

#### Token Transfer

**Type**: general

**Description**: Transfer tokens between users and the contract

**Steps**:

- User sends tokens to the contract
- Contract checks if the transaction is valid
- Contract transfers tokens to the user or another contract

**Functions**:

- `_depositAndSwap`
- `_executeSwaps`

#### Access Control

**Type**: general

**Description**: Control access to contract functions based on user permissions

**Steps**:

- User sends a request to access a contract function
- Contract checks user permissions
- Contract grants or denies access

**Functions**:

- `_executeSwaps`
- `_depositAndSwap`

#### State Transition

**Type**: general

**Description**: Update the contract's internal state

**Steps**:

- User sends a transaction
- Contract checks the transaction
- Contract updates its internal state

**Functions**:

- `_executeSwaps`
- `_depositAndSwap`

#### External Call

**Type**: general

**Description**: Make external calls to other contracts

**Steps**:

- Contract receives a request to make an external call
- Contract checks the request
- Contract makes the external call

**Functions**:

- `_executeSwaps`
- `_depositAndSwap`

#### Fund Management

**Type**: general

**Description**: Manage funds received by the contract

**Steps**:

- User sends funds to the contract
- Contract checks the funds
- Contract manages the funds

**Functions**:

- `_depositAndSwap`
- `_executeSwaps`

### ReentrancyGuard

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users

**Steps**:

- User A initiates a token transfer request
- Smart contract verifies user authorization
- Smart contract updates internal state to reflect the transfer
- Smart contract executes the actual token transfer
- User B receives the transferred tokens

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling access to the smart contract's functionality

**Steps**:

- User attempts to interact with a restricted function
- Smart contract checks user's authorization level
- Smart contract grants or denies access based on user's authorization level

**Functions**:

- `nonReentrant`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the smart contract's internal state

**Steps**:

- User initiates a state-changing action
- Smart contract verifies user authorization
- Smart contract updates internal state
- Smart contract emits an event to notify state change

**Functions**:

- `reentrancyStorage`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Smart contract receives a request to make an external call
- Smart contract verifies user authorization
- Smart contract executes the external call
- External contract processes the request and sends a response

**Functions**:

- `externalCall`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds within the smart contract

**Steps**:

- User deposits funds into the smart contract
- Smart contract updates internal state to reflect the deposit
- User withdraws funds from the smart contract
- Smart contract updates internal state to reflect the withdrawal

**Functions**:

- `deposit`
- `withdraw`

### WithdrawablePeriphery

#### Token Withdrawal Flow

**Type**: general

**Description**: Flow for withdrawing tokens from the contract

**Steps**:

- Check if the caller is the owner
- Verify if the asset is a native asset or not
- If native asset, call the receiver's address with the specified amount
- If not native asset, transfer the tokens to the receiver
- Emit the TokensWithdrawn event

**Functions**:

- `withdrawToken`

### TransferrableOwnership

#### Ownership Transfer Request

**Type**: general

**Description**: Request for ownership transfer to a new address

**Steps**:

- Check if the sender is the owner
- Check if the new owner is not null
- Check if the new owner is not the sender
- Set the pending owner
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: Cancel the pending ownership transfer

**Steps**:

- Check if the pending owner is not null
- Check if the sender is the owner
- Set the pending owner to null
- Revert NoPendingOwnershipTransfer error if applicable

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: Confirm the transfer of ownership to the calling address

**Steps**:

- Check if the sender is the pending owner
- Set the owner to the pending owner
- Set the pending owner to null
- Emit OwnershipTransferred event

**Functions**:

- `confirmOwnershipTransfer`

### Validatable

#### Token Transfer Validation

**Type**: general

**Description**: Validates the token transfer data before allowing the transfer to proceed.

**Steps**:

- Check if the receiver address is zero
- Check if the minimum amount is zero
- Check if the destination chain ID is the same as the current chain ID

**Functions**:

- `validateBridgeData`

#### Native Asset Disallowance

**Type**: general

**Description**: Disallows the transfer of native assets.

**Steps**:

- Check if the sending asset ID is a native asset
- If yes, revert with an error

**Functions**:

- `noNativeAsset`

#### Source Token Validation

**Type**: general

**Description**: Validates if the sending token is the allowed source token.

**Steps**:

- Check if the sending asset ID matches the allowed source token
- If not, revert with an error

**Functions**:

- `onlyAllowSourceToken`

#### Destination Chain Validation

**Type**: general

**Description**: Validates if the destination chain ID is the allowed chain ID.

**Steps**:

- Check if the destination chain ID matches the allowed chain ID
- If not, revert with an error

**Functions**:

- `onlyAllowDestinationChain`

#### Source Swaps Validation

**Type**: general

**Description**: Validates if the bridge data contains source swaps.

**Steps**:

- Check if the bridge data has source swaps
- If not, revert with an error

**Functions**:

- `containsSourceSwaps`

#### Destination Calls Validation

**Type**: general

**Description**: Validates if the bridge data does not contain destination calls.

**Steps**:

- Check if the bridge data has destination calls
- If yes, revert with an error

**Functions**:

- `doesNotContainDestinationCalls`

### OmniBridgeFacet

#### Token Transfer via OmniBridge

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the OmniBridge

**Steps**:

- User initiates a token transfer request
- Token deposit is made to the contract
- Bridge logic is executed to transfer tokens
- Token transfer is completed

**Functions**:

- `startBridgeTokensViaOmniBridge`
- `swapAndStartBridgeTokensViaOmniBridge`

### OptimismBridgeFacet

#### Token Transfer via Optimism Bridge

**Type**: general

**Description**: Transfer tokens from L1 to L2 using the Optimism Bridge

**Steps**:

- Check if the contract is initialized
- Register the token and bridge if not initialized
- Deposit the required amount of tokens
- Perform any necessary swaps
- Start the bridging process via Optimism Bridge

**Functions**:

- `initOptimism`
- `registerOptimismBridge`
- `startBridgeTokensViaOptimismBridge`
- `swapAndStartBridgeTokensViaOptimismBridge`

### OwnershipFacet

#### Ownership Transfer Request

**Type**: general

**Description**: Request for ownership transfer to a new address

**Steps**:

- Check if the caller is the contract owner
- Check if the new owner is not the same as the current owner
- Set the new owner address in storage
- Emit OwnershipTransferRequested event

**Functions**:

- `transferOwnership`

#### Cancel Ownership Transfer

**Type**: general

**Description**: Cancel the pending ownership transfer

**Steps**:

- Check if the caller is the contract owner
- Check if there is a pending owner
- Reset the new owner address in storage

**Functions**:

- `cancelOwnershipTransfer`

#### Confirm Ownership Transfer

**Type**: general

**Description**: Confirm the ownership transfer to the calling address

**Steps**:

- Check if the caller is the pending owner
- Transfer ownership to the pending owner
- Set the new owner as the contract owner
- Reset the new owner address in storage
- Emit OwnershipTransferred event

**Functions**:

- `confirmOwnershipTransfer`

#### Get Current Owner

**Type**: general

**Description**: Return the current owner address

**Steps**:

- Return the contract owner address

**Functions**:

- `owner`

### PolygonBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via Polygon Bridge

**Steps**:

- User initiates a token transfer request
- Token deposit is made to the contract
- Bridge logic is executed
- Token is bridged to the destination chain

**Functions**:

- `startBridgeTokensViaPolygonBridge`
- `swapAndStartBridgeTokensViaPolygonBridge`

### PeripheryRegistryFacet

#### Register Periphery Contract

**Type**: general

**Description**: Register a periphery contract address with a specified name

**Steps**:

- LibDiamond.enforceIsContractOwner();
- Storage storage s = getStorage();
- s.contracts[_name] = _contractAddress;
- emit PeripheryContractRegistered(_name, _contractAddress);

**Functions**:

- `registerPeripheryContract`

#### Get Periphery Contract

**Type**: general

**Description**: Returns the registered contract address by its name

**Steps**:

- return getStorage().contracts[_name];

**Functions**:

- `getPeripheryContract`

### RelayFacet

#### Token Bridging via Relay

**Type**: general

**Description**: Bridging tokens from the current chain to another chain via Relay

**Steps**:

- Validate the bridge data
- Check if the bridge data contains source swaps
- Check if the bridge data contains destination calls
- Ensure the quote is valid
- Deposit the sending asset
- Perform swaps if necessary
- Start the bridge process

**Functions**:

- `startBridgeTokensViaRelay`
- `swapAndStartBridgeTokensViaRelay`

### StargateFacet

#### Token Transfer via Stargate Bridge

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Stargate Bridge

**Steps**:

- Validate the BridgeData and StargateData
- Quote the LayerZero fee
- Perform the token transfer via Stargate Bridge
- Execute the external call to the destination chain
- Refund any excess gas to the refund address

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`
- `quoteLayerZeroFee`

### StandardizedCallFacet

#### Standardized Call Flow

**Type**: general

**Description**: Flow for making standardized calls to different facets

**Steps**:

- Fetch the facetAddress from the diamond's internal storage
- Execute external function from facet using delegatecall
- Return any return value or error back to the caller

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens

**Steps**:

- Make a standardized call to a facet
- Delegatecall to the facet
- Transfer tokens to the facet

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

#### State Transition Flow

**Type**: general

**Description**: Flow for state transitions

**Steps**:

- Fetch the facetAddress from the diamond's internal storage
- Delegatecall to the facet
- Update state variables

**Functions**:

- `standardizedCall`
- `standardizedSwapCall`
- `standardizedBridgeCall`
- `standardizedSwapAndBridgeCall`
- `execute`

### SquidFacet

#### Token Transfer via Squid Router

**Type**: general

**Description**: Transfer tokens through the Squid Router

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridging process

**Functions**:

- `startBridgeTokensViaSquid`
- `swapAndStartBridgeTokensViaSquid`

#### Access Control

**Type**: general

**Description**: Control access to external methods

**Steps**:

- Check if the sender is the expected actor
- Check if the amount sent is sufficient
- Check if the route type is valid

**Functions**:

- `startBridgeTokensViaSquid`
- `swapAndStartBridgeTokensViaSquid`

#### State Transition

**Type**: general

**Description**: Update the state during the bridging process

**Steps**:

- Update the bridge data
- Update the Squid data
- Calculate the message value

**Functions**:

- `_startBridge`
- `_bridgeCall`
- `_callBridge`
- `_callBridgeCall`
- `_calculateMsgValue`

#### External Call

**Type**: general

**Description**: Make external calls to the Squid Router

**Steps**:

- Bridge call
- Call bridge
- Call bridge call

**Functions**:

- `_bridgeCall`
- `_callBridge`
- `_callBridgeCall`

#### Fund Management

**Type**: general

**Description**: Manage funds during the bridging process

**Steps**:

- Refund excess native
- Deposit asset
- Pay fee

**Functions**:

- `refundExcessNative`
- `depositAsset`
- `_calculateMsgValue`

### StargateFacetV2

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens via Stargate Bridge

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridging process

**Functions**:

- `startBridgeTokensViaStargate`
- `swapAndStartBridgeTokensViaStargate`

### SymbiosisFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the contract for bridging

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _symbiosisData);

**Functions**:

- `startBridgeTokensViaSymbiosis`
- `_startBridge`

### ThorSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to ThorSwap contract for bridging

**Steps**:

- Sender sends tokens to ThorSwap contract
- ThorSwap contract receives tokens
- ThorSwap contract processes the tokens for bridging

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### Access Control Flow

**Type**: general

**Description**: Control access to the ThorSwap contract functions

**Steps**:

- Sender provides necessary permissions
- ThorSwap contract validates permissions
- ThorSwap contract executes the requested function

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

#### State Transition Flow

**Type**: general

**Description**: Update the state of the ThorSwap contract after token processing

**Steps**:

- ThorSwap contract receives tokens
- ThorSwap contract updates its state
- ThorSwap contract emits event indicating state change

**Functions**:

- `_startBridge`

#### External Call Flow

**Type**: general

**Description**: Make external calls to other contracts for token bridging

**Steps**:

- ThorSwap contract calls Thorchain router contract
- Thorchain router contract processes the token bridging

**Functions**:

- `_startBridge`

#### Fund Management Flow

**Type**: general

**Description**: Manage funds received by the ThorSwap contract

**Steps**:

- Sender sends funds to ThorSwap contract
- ThorSwap contract processes the funds
- ThorSwap contract updates its state

**Functions**:

- `startBridgeTokensViaThorSwap`
- `swapAndStartBridgeTokensViaThorSwap`

### AccessManagerFacet

#### Access Control Flow

**Type**: general

**Description**: This flow handles setting and checking access permissions for specific addresses and methods.

**Steps**:

- Check if the caller is the contract owner
- Check if the executor is allowed to execute the specified method
- Add or remove access for the executor
- Emit an event indicating whether access was allowed or denied

**Functions**:

- `setCanExecute`
- `addressCanExecuteMethod`

### WithdrawFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from the contract to an external address

**Steps**:

- Check if the sender has access control
- Verify if the recipient is a contract
- Execute the provided call data
- Withdraw the specified amount of tokens to the recipient address

**Functions**:

- `executeCallAndWithdraw`
- `withdraw`

### HopFacetOptimized

#### ERC20 Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 1 to Layer 2 via Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swap (if required)
- Bridge ERC20 tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1ERC20`
- `swapAndStartBridgeTokensViaHopL1ERC20`

#### Native Token Bridging via Hop Protocol from L1

**Type**: general

**Description**: Bridging native tokens from Layer 1 to Layer 2 via Hop Protocol

**Steps**:

- Bridge native tokens to Layer 2
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL1Native`
- `swapAndStartBridgeTokensViaHopL1Native`

#### ERC20 Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging ERC20 tokens from Layer 2 to Layer 1 via Hop Protocol

**Steps**:

- Deposit ERC20 tokens from sender to contract
- Perform swap (if required)
- Bridge ERC20 tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2ERC20`
- `swapAndStartBridgeTokensViaHopL2ERC20`

#### Native Token Bridging via Hop Protocol from L2

**Type**: general

**Description**: Bridging native tokens from Layer 2 to Layer 1 via Hop Protocol

**Steps**:

- Bridge native tokens to Layer 1
- Notify about transfer start

**Functions**:

- `startBridgeTokensViaHopL2Native`
- `swapAndStartBridgeTokensViaHopL2Native`

### AcrossFacet

#### Token bridging via Across

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via the AcrossFacet contract

**Steps**:

- The user initiates a token bridging request
- The contract validates the bridging data
- The contract checks for any required swaps before bridging
- The contract performs the necessary swaps
- The contract deposits the tokens into the spoke pool
- The contract emits an event indicating the start of the bridge

**Functions**:

- `startBridgeTokensViaAcross`
- `swapAndStartBridgeTokensViaAcross`

### AcrossFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring ERC20 tokens from the contract to the receiving wallet

**Steps**:

- ERC20 tokens are deposited into the contract
- Contract approves the Across spoke pool to pull tokens
- Tokens are transferred to the receiving wallet via the Across bridge

**Functions**:

- `startBridgeTokensViaAcrossERC20Packed`
- `startBridgeTokensViaAcrossERC20Min`
- `executeCallAndWithdraw`

### AmarokFacet

#### Token Transfer via Amarok

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain using the Amarok bridge

**Steps**:

- Validate bridge data
- Deposit asset
- Start bridge transaction

**Functions**:

- `startBridgeTokensViaAmarok`
- `swapAndStartBridgeTokensViaAmarok`

### AllBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the sender to the AllBridge contract and then to the destination chain.

**Steps**:

- Sender sends tokens to the AllBridge contract.
- AllBridge contract receives tokens.
- AllBridge contract bridges tokens to the destination chain.

**Functions**:

- `startBridgeTokensViaAllBridge`
- `swapAndStartBridgeTokensViaAllBridge`
- `_startBridge`

### AcrossFacetV3

#### Token bridging via Across

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain using the AcrossFacetV3 contract

**Steps**:

- Validate bridge data
- Check for source swaps
- Perform deposit and swap (if applicable)
- Start bridging process

**Functions**:

- `startBridgeTokensViaAcrossV3`
- `swapAndStartBridgeTokensViaAcrossV3`

### CelerCircleBridgeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from the source chain to the destination chain via CelerCircleBridge

**Steps**:

- LibAsset.depositAsset(usdc, _bridgeData.minAmount);
- _startBridge(_bridgeData);
- circleBridgeProxy.depositForBurn(...);

**Functions**:

- `startBridgeTokensViaCelerCircleBridge`
- `swapAndStartBridgeTokensViaCelerCircleBridge`
- `_startBridge`

### CBridgeFacetPacked

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- ERC20 token transfer from sender to contract
- Contract receives tokens and triggers a cBridge transfer
- cBridge transfers tokens to the destination address

**Functions**:

- `ERC20(sendingAssetId).safeTransferFrom`
- `cBridge.send`

#### Approval Flow

**Type**: general

**Description**: Flow responsible for setting approval for the CBridge Router to spend the specified token

**Steps**:

- Owner calls setApprovalForBridge function
- Function sets approval for CBridge Router to bridge tokens

**Functions**:

- `setApprovalForBridge`

#### Refund Flow

**Type**: general

**Description**: Flow responsible for triggering a cBridge refund

**Steps**:

- Owner calls triggerRefund function
- Function checks if callTo address is valid
- Function executes external call and checks success
- Contract refunds the sender and emits an event

**Functions**:

- `triggerRefund`

#### Bridge Native Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging native tokens via cBridge

**Steps**:

- Sender calls startBridgeTokensViaCBridgeNativePacked function
- Function extracts data from calldata
- cBridge sends native tokens to the destination address

**Functions**:

- `startBridgeTokensViaCBridgeNativePacked`

#### Bridge ERC20 Tokens Flow

**Type**: general

**Description**: Flow responsible for bridging ERC20 tokens via cBridge

**Steps**:

- Sender calls startBridgeTokensViaCBridgeERC20Packed function
- Function extracts data from calldata
- Contract deposits ERC20 tokens and cBridge transfers them to the destination address

**Functions**:

- `startBridgeTokensViaCBridgeERC20Packed`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds received by the contract

**Steps**:

- Contract receives native tokens via receive() external payable function
- Contract uses funds to trigger a cBridge refund

**Functions**:

- `receive()`

### CelerIMFacetMutable

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens between users

**Steps**:

- User A sends a request to transfer tokens
- The request is processed by the contract
- Tokens are transferred from User A's account to User B's account

**Functions**:

- `transfer`

### DeBridgeDlnFacet

#### Token Transfer via DeBridgeDlnFacet

**Type**: general

**Description**: Transfer tokens from one chain to another using DeBridgeDlnFacet

**Steps**:

- User initiates a token transfer request
- DeBridgeDlnFacet validates the transfer request
- DeBridgeDlnFacet performs the token transfer via DeBridgeDLN
- DLN order creation contract creates an order for the transfer
- Token transfer is executed on the destination chain

**Functions**:

- `startBridgeTokensViaDeBridgeDln`
- `swapAndStartBridgeTokensViaDeBridgeDln`

### DexManagerFacet

#### Add DEX to Allowlist

**Type**: general

**Description**: Add a DEX contract address to the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add the DEX contract address to the allowlist
- Emit the DexAdded event

**Functions**:

- `addDex`

#### Batch Add DEX to Allowlist

**Type**: general

**Description**: Batch add multiple DEX contract addresses to the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of DEX contract addresses
- For each address, check if it is the contract itself
- If not, check if it is already in the allowlist
- If not, add the DEX contract address to the allowlist
- Emit the DexAdded event for each added address

**Functions**:

- `batchAddDex`

#### Remove DEX from Allowlist

**Type**: general

**Description**: Remove a DEX contract address from the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Remove the DEX contract address from the allowlist
- Emit the DexRemoved event

**Functions**:

- `removeDex`

#### Batch Remove DEX from Allowlist

**Type**: general

**Description**: Batch remove multiple DEX contract addresses from the allowlist for swapping

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of DEX contract addresses
- For each address, remove it from the allowlist
- Emit the DexRemoved event for each removed address

**Functions**:

- `batchRemoveDex`

#### Set Function Approval

**Type**: general

**Description**: Add or remove a specific function signature to/from the allowlist

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Add or remove the function signature from the allowlist based on approval
- Emit the FunctionSignatureApprovalChanged event

**Functions**:

- `setFunctionApprovalBySignature`

#### Batch Set Function Approval

**Type**: general

**Description**: Batch add or remove multiple function signatures to/from the allowlist

**Steps**:

- Check if the sender is the contract owner
- If not, enforce access control
- Iterate through the list of function signatures
- For each signature, add or remove it from the allowlist based on approval
- Emit the FunctionSignatureApprovalChanged event for each signature

**Functions**:

- `batchSetFunctionApprovalBySignature`

#### Check Function Approval

**Type**: general

**Description**: Check if a specific function signature is approved

**Steps**:

- Return whether the function signature is approved

**Functions**:

- `isFunctionApproved`

#### Get Approved DEXs

**Type**: general

**Description**: Return a list of all approved DEX contract addresses

**Steps**:

- Return the list of approved DEX contract addresses

**Functions**:

- `approvedDexs`

### DiamondCutFacet

#### Diamond Cut Facet Execution

**Type**: general

**Description**: Execution of the diamond cut operation, which adds/replace/removes functions and optionally executes a function with delegatecall.

**Steps**:

- LibDiamond.enforceIsContractOwner();
- LibDiamond.diamondCut(_diamondCut, _init, _calldata);

**Functions**:

- `diamondCut`

### EmergencyPauseFacet

#### Emergency Pause Flow

**Type**: general

**Description**: This flow allows the pauser wallet or the diamond owner to pause the diamond contract by redirecting all function selectors to the EmergencyPauseFacet.

**Steps**:

- The pauser wallet or diamond owner calls the `pauseDiamond()` function.
- The `pauseDiamond()` function redirects all function selectors to the EmergencyPauseFacet.
- All other facets are removed from the diamond contract.

**Functions**:

- `pauseDiamond`

#### Facet Removal Flow

**Type**: general

**Description**: This flow allows the pauser wallet or the diamond owner to remove a specific facet from the diamond contract.

**Steps**:

- The pauser wallet or diamond owner calls the `removeFacet()` function.
- The `removeFacet()` function checks if the facet to be removed is the EmergencyPauseFacet.
- If the facet is not the EmergencyPauseFacet, the facet is removed from the diamond contract.

**Functions**:

- `removeFacet`

#### Diamond Unpause Flow

**Type**: general

**Description**: This flow allows the diamond owner to unpause the diamond contract by re-adding all facet address-to-function selector mappings to storage.

**Steps**:

- The diamond owner calls the `unpauseDiamond()` function.
- The `unpauseDiamond()` function re-adds all facets to the diamond contract.
- Facets that are in the blacklist are removed from the diamond contract.

**Functions**:

- `unpauseDiamond`

### DiamondLoupeFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request and verifies the sender's permissions
- Smart contract deducts the tokens from the sender's balance
- Smart contract adds the tokens to the recipient's balance
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

#### Access Control Flow

**Type**: general

**Description**: Flow responsible for controlling permissions and access levels

**Steps**:

- User requests access to a specific function
- Smart contract verifies the user's role or permissions
- Smart contract grants or denies access based on the verification result
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `supportsInterface`

#### State Transition Flow

**Type**: general

**Description**: Flow responsible for updating the smart contract's internal state

**Steps**:

- User initiates a state update request
- Smart contract verifies the request and checks for any conditions
- Smart contract updates the state accordingly
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `facets`
- `facetFunctionSelectors`
- `facetAddresses`
- `facetAddress`

#### External Call Flow

**Type**: general

**Description**: Flow responsible for making external calls to other contracts

**Steps**:

- Smart contract receives a request to call another contract
- Smart contract verifies the target contract and the called function
- Smart contract executes the external call
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `externalCall`

#### Fund Management Flow

**Type**: general

**Description**: Flow responsible for managing funds and balances

**Steps**:

- User deposits or withdraws funds
- Smart contract updates the user's balance accordingly
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `deposit`
- `withdraw`

### GenericSwapFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens in a multi-swap transaction

**Steps**:

- Check if the receiver address is valid
- Deposit and perform swaps
- Transfer the post-swap balance to the receiver
- Emit the LiFiGenericSwapCompleted event

**Functions**:

- `swapTokensGeneric`

### GasZipFacet

#### Token bridging flow

**Type**: general

**Description**: Bridging tokens from one network to another using the gas.zip protocol

**Steps**:

- Check if the sending asset is a native asset
- Validate the amount to be bridged
- Deposit native to Gas.zip
- Start bridging process

**Functions**:

- `startBridgeTokensViaGasZip`
- `_startBridge`

#### Token bridging flow with swapping

**Type**: general

**Description**: Bridging tokens from one network to another using the gas.zip protocol after performing swaps

**Steps**:

- Perform swaps to convert ERC20 tokens to native asset
- Check if the output of the last swap is a native asset
- Deposit and swap ERC20 tokens to native
- Deposit native to Gas.zip
- Start bridging process

**Functions**:

- `swapAndStartBridgeTokensViaGasZip`
- `_startBridge`

### GnosisBridgeFacet

#### Token bridging flow

**Type**: general

**Description**: Bridging tokens from the source chain to the destination chain via XDaiBridge

**Steps**:

- Validate bridge data
- Check destination chain
- Deposit source token
- Perform swap (if required)
- Relay tokens via XDaiBridge
- Start bridging process

**Functions**:

- `startBridgeTokensViaXDaiBridge`
- `swapAndStartBridgeTokensViaXDaiBridge`

### LibAccess

#### Access Control Flow

**Type**: general

**Description**: This flow handles the granting and revoking of permissions for different methods in the contract.

**Steps**:

- Fetch the local storage using the accessStorage function
- Check if the executor is trying to grant permission to themselves
- Grant permission to the executor for a specific method selector
- Emit the AccessGranted event
- Fetch the local storage using the accessStorage function
- Check if the executor is trying to revoke permission from themselves
- Revoke permission from the executor for a specific method selector
- Emit the AccessRevoked event
- Check if the sender has permission to execute the method
- Revert the transaction if the sender does not have permission

**Functions**:

- `addAccess`
- `removeAccess`
- `enforceAccessControl`

#### State Transition Flow

**Type**: general

**Description**: This flow handles the state transitions when granting or revoking permissions.

**Steps**:

- Update the execAccess mapping in the AccessStorage struct
- Emit the AccessGranted or AccessRevoked event

**Functions**:

- `addAccess`
- `removeAccess`

### HopFacet

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens via Hop Protocol

**Steps**:

- LibAsset.depositAsset(_bridgeData.sendingAssetId, _bridgeData.minAmount);
- _startBridge(_bridgeData, _hopData);

**Functions**:

- `startBridgeTokensViaHop`
- `_startBridge`

### LibBytes

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens from one address to another

**Steps**:

- User initiates a token transfer request
- Smart contract verifies the sender's balance and the recipient address
- Smart contract deducts the transferred amount from the sender's balance
- Smart contract adds the transferred amount to the recipient's balance
- Transaction is executed and confirmed on the blockchain

**Functions**:

- `transfer`

### LibAsset

#### Token Transfer

**Type**: general

**Description**: Transfer tokens from the contract to a recipient

**Steps**:

- Check if the recipient address is null
- Check if the amount exceeds the contract's balance
- Transfer the tokens to the recipient

**Functions**:

- `transferERC20`
- `transferNativeAsset`

#### Access Control

**Type**: general

**Description**: Control the transfer of tokens based on the sender's balance

**Steps**:

- Check if the sender's balance is sufficient
- Transfer tokens from the sender to the contract

**Functions**:

- `depositAsset`
- `depositAssets`

#### State Transition

**Type**: general

**Description**: Update the contract's state based on the deposited tokens

**Steps**:

- Update the sender's balance
- Update the contract's balance

**Functions**:

- `depositAsset`
- `depositAssets`

#### External Call

**Type**: general

**Description**: Make external calls to transfer tokens

**Steps**:

- Call the recipient's address to transfer native assets
- Call the ERC20 token contract to transfer tokens

**Functions**:

- `transferNativeAsset`
- `transferERC20`

#### Fund Management

**Type**: general

**Description**: Manage the contract's funds

**Steps**:

- Transfer funds to the contract
- Transfer funds from the contract

**Functions**:

- `depositAsset`
- `transferERC20`
- `transferNativeAsset`

### LibAllowList

#### Adding a contract address to the allow list

**Type**: general

**Description**: A contract address is added to the allow list by the contract owner or authorized actor.

**Steps**:

- Check if the contract address is valid.
- Check if the contract address is already in the allow list.
- Add the contract address to the allow list if it is not already present.

**Functions**:

- `addAllowedContract`

#### Removing a contract address from the allow list

**Type**: general

**Description**: A contract address is removed from the allow list by the contract owner or authorized actor.

**Steps**:

- Check if the contract address is present in the allow list.
- Remove the contract address from the allow list if it is present.

**Functions**:

- `removeAllowedContract`

#### Adding a selector to the allow list

**Type**: general

**Description**: A selector is added to the allow list by the contract owner or authorized actor.

**Steps**:

- Check if the selector is valid.
- Add the selector to the allow list.

**Functions**:

- `addAllowedSelector`

#### Removing a selector from the allow list

**Type**: general

**Description**: A selector is removed from the allow list by the contract owner or authorized actor.

**Steps**:

- Check if the selector is present in the allow list.
- Remove the selector from the allow list if it is present.

**Functions**:

- `removeAllowedSelector`

#### Checking if a contract address is allowed

**Type**: general

**Description**: Check if a contract address is present in the allow list.

**Steps**:

- Check if the contract address is present in the allow list.

**Functions**:

- `contractIsAllowed`

#### Checking if a selector is allowed

**Type**: general

**Description**: Check if a selector is present in the allow list.

**Steps**:

- Check if the selector is present in the allow list.

**Functions**:

- `selectorIsAllowed`

#### Fetching allowed contract addresses

**Type**: general

**Description**: Fetch all contract addresses present in the allow list.

**Steps**:

- Return all contract addresses present in the allow list.

**Functions**:

- `getAllowedContracts`

### LibDiamondLoupe

#### Token Transfer Flow

**Type**: general

**Description**: Flow for transferring tokens within the contract

**Steps**:

- User initiates a token transfer request
- Contract verifies the user's request
- Contract updates the token balances
- Contract sends the tokens to the recipient

**Functions**:

- `transfer`

### LibSwap

#### Token Transfer Flow

**Type**: general

**Description**: Transfer tokens from sender to receiver through a decentralized exchange (DEX) contract.

**Steps**:

- Sender initiates a swap request with the DEX contract.
- The DEX contract checks if the sender has sufficient balance.
- The DEX contract approves the transfer of tokens if necessary.
- The DEX contract executes the swap by calling the external contract specified in the swap data.
- The DEX contract updates the balances of the sender and receiver.
- The DEX contract emits an event to log the swap details.

**Functions**:

- `swap`

### LibDiamond

#### Diamond Facet Addition

**Type**: general

**Description**: Add a new facet to the diamond

**Steps**:

- Check if the facet address is zero
- Add the facet address to the facet addresses array
- Add the facet address position to the facetFunctionSelectors array
- Add the facet address to the selectorToFacetAndPosition mapping

**Functions**:

- `addFacet`
- `addFunction`

#### Diamond Facet Replacement

**Type**: general

**Description**: Replace an existing facet with a new one

**Steps**:

- Check if the facet address is zero
- Remove the old facet address from the facet addresses array
- Remove the old facet address position from the facetFunctionSelectors array
- Add the new facet address to the facet addresses array
- Add the new facet address position to the facetFunctionSelectors array
- Add the new facet address to the selectorToFacetAndPosition mapping

**Functions**:

- `replaceFunctions`

#### Diamond Facet Removal

**Type**: general

**Description**: Remove a facet from the diamond

**Steps**:

- Check if the facet address is not zero
- Remove the facet address from the facet addresses array
- Remove the facet address position from the facetFunctionSelectors array
- Remove the facet address from the selectorToFacetAndPosition mapping

**Functions**:

- `removeFunctions`

#### Diamond Initialization

**Type**: general

**Description**: Initialize the diamond with a new facet

**Steps**:

- Check if the init address is zero
- Delegatecall to the init address with the calldata
- If the calldata is empty, check if the init address is the contract owner

**Functions**:

- `initializeDiamondCut`

#### Ownership Transfer

**Type**: general

**Description**: Transfer ownership of the contract

**Steps**:

- Check if the new owner is zero
- Set the new owner as the contract owner
- Emit the OwnershipTransferred event

**Functions**:

- `setContractOwner`

### LibUtil

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- Check if the sender is the zero address
- Extract the revert message from the transaction data
- Decode the revert message to get the actual error message

**Functions**:

- `getRevertMsg`

### OFTComposeMsgCodec

#### Token Transfer Flow

**Type**: general

**Description**: Flow responsible for transferring tokens

**Steps**:

- User initiates a token transfer request
- Smart contract receives the request
- Smart contract verifies the request
- Smart contract executes the transfer
- Transfer is confirmed

**Functions**:

- `encode`
- `nonce`
- `srcEid`
- `amountLD`
- `composeFrom`
- `composeMsg`

## Cognitive Bias Analysis

### GasZipPeriphery

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LiFiDEXAggregator

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### Permit2Proxy

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### RelayerCelerIM

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### TransferrableOwnership

#### Authority Bias
- **Description**: Centralized control pattern may indicate authority bias
- **Impact**: Medium - May lead to centralization risks

### WithdrawFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### AcrossFacetPackedV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacet

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### CBridgeFacetPacked

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### GenericSwapFacetV3

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

### LibDiamond

#### Overconfidence Bias
- **Description**: Function assumes external call will succeed without proper error handling
- **Impact**: High - May lead to transaction failures or lock funds

## Recommendations

Based on the analysis, consider the following recommendations:

- No specific recommendations available from the analysis

## Debug Information

This report was generated as part of the debugging process.
- Pipeline executed at: 2025-03-30 01:18:22
- Input directory: examples/src
- Output directory: debug_output